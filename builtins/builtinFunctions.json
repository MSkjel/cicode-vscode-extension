{
  "v": 6,
  "functions": {
    "abs": {
      "name": "Abs",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The absolute (positive) value of Number.",
      "paramDocs": {
        "Number": "Abs(Number)"
      },
      "helpPath": "Abs.html"
    },
    "acccontrol": {
      "name": "AccControl",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "nMode [",
        "sClusterName]"
      ],
      "doc": "Controls accumulators, for example, motor run hours. You can reset the values of Run Time, Totalizer Inc, and Number of Starts (defined in the Accumulator database), re-read these values from the I/O device, or flush pending writes of these values to the I/O device.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName": "AccControl(sName, nMode [, sClusterName] )",
        "nMode": "The mode of the control:",
        "1 -": "Reset Run Time and Totalizer value",
        "2 -": "Reset No. of Starts",
        "3 -": "Reset Run Time, Totalizer value, and No. of Starts",
        "4 -": "Flush pending writes to the I/O device",
        "5 -": "Re-read Run Time, Totalizer value, and No. of Starts from the I/O device",
        "sClusterName": "Name of the cluster in which the accumulator resides. This is optional if you have one cluster or are resolving the reports server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AccControl.html"
    },
    "accumbrowseclose": {
      "name": "AccumBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AccumBrowseClose function terminates an active data browse session and cleans up all resources associated with the session.",
      "returns": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AccumBrowseClose(iSession)"
      },
      "helpPath": "AccumBrowseClose.html"
    },
    "accumbrowsefirst": {
      "name": "AccumBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AccumBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AccumBrowseFirst(iSession)"
      },
      "helpPath": "AccumBrowseFirst.html"
    },
    "accumbrowsegetfield": {
      "name": "AccumBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING FieldName"
      ],
      "doc": "The AccumBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG Session, STRING FieldName": "STRING AccumBrowseGetField(LONG Session, STRING FieldName)",
        "Session": "The handle to a browse session previously returned by a AccumBrowseOpen call.",
        "FieldName": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "AccumBrowseGetField.html"
    },
    "accumbrowsenext": {
      "name": "AccumBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AccumBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AccumBrowseNext(iSession)"
      },
      "helpPath": "AccumBrowseNext.html"
    },
    "accumbrowsenumrecords": {
      "name": "AccumBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AccumBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "iSession": "AccumBrowseNumRecords(iSession)"
      },
      "helpPath": "AccumBrowseNumRecords.html"
    },
    "accumbrowseopen": {
      "name": "AccumBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters]"
      ],
      "doc": "The AccumBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "Filter": "INT AccumBrowseOpen( STRING Filter, STRING Fields [, STRING Clusters] )",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed."
      },
      "helpPath": "AccumBrowseOpen.html"
    },
    "accumbrowseprev": {
      "name": "AccumBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AccumBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the accumulator browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AccumBrowsePrev(iSession)"
      },
      "helpPath": "AccumBrowsePrev.html"
    },
    "alarmackrec": {
      "name": "AlarmAckRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record [",
        "STRING ClusterName]"
      ],
      "doc": "Acknowledges alarms by record number on both the primary and standby alarm servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Record [, STRING ClusterName]": "INT AlarmAckRec(LONG Record [, STRING ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmAckRec.html"
    },
    "alarmacktag": {
      "name": "AlarmAckTag",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "[",
        "STRING ClusterName]"
      ],
      "doc": "Acknowledge a specified alarm.",
      "returns": "0 (zero) if successful, otherwise an error code will return",
      "paramDocs": {
        "INT": "INT AlarmAckTag(STRING Tag, [, STRING ClusterName])",
        "Tag": "A string that identifies the alarm to acknowledge. It can be one of the following:",
        "ClusterName": "The cluster where the tag resides"
      },
      "helpPath": "AlarmAckTag.html"
    },
    "alarmack": {
      "name": "AlarmAck",
      "returnType": "UNKNOWN",
      "params": [
        "INT Mode",
        "INT Value [",
        "STRING ClusterName]"
      ],
      "doc": "Acknowledges alarms. You can acknowledge the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.",
      "returns": "0 (zero) if successful, otherwise an error code will return",
      "paramDocs": {
        "0": "Acknowledge a single alarm.",
        "1": "Acknowledge a page of alarms. An alarm page can contain more than one alarm list:",
        "2": "Acknowledge a category of alarms:",
        "3": "Acknowledge alarms of a specific priority.",
        "INT Mode": "INT AlarmAck(INT Mode, INT Value [, STRING ClusterName])",
        "Mode": "The type of acknowledgment:",
        "Value": "Used with Mode 1 and 2 to specify which alarms to acknowledge.",
        "sClusterName": "Used with Mode 2 or 3 to specify the name of the cluster in which the alarms being acknowledged reside. This argument is optional if the client is connected to only one cluster containing an Alarm Server or are resolving the alarm server via the current cluster context."
      },
      "helpPath": "AlarmAck_CIREF.html"
    },
    "alarmactive": {
      "name": "AlarmActive",
      "returnType": "UNKNOWN",
      "params": [
        "Type [",
        "sClusterName]"
      ],
      "doc": "Determines if any alarms are active in the user's area.",
      "paramDocs": {
        "Type [, sClusterName]": "AlarmActive(Type [, sClusterName] )",
        "nType": "The type of alarms to check:",
        "sClusterName": "The name of the cluster to check for active alarms. If this argument is blank or empty, the function will check the connected clusters."
      },
      "helpPath": "AlarmActive_CIREF.html"
    },
    "alarmcatgetformat": {
      "name": "AlarmCatGetFormat",
      "returnType": "UNKNOWN",
      "params": [
        "INT Category [",
        "INT Type]"
      ],
      "doc": "Returns the display format string of the specified alarm category.",
      "returns": "The display format string of the specified category. If the alarm category is not specifically defined or it has no format string specified in your project, the format string of category 0 will be returned.",
      "paramDocs": {
        "INT Category [, INT Type]": "STRING AlarmCatGetFormat(INT Category [, INT Type] )",
        "Category": "The alarm category.",
        "Type": "The type of display format string:"
      },
      "helpPath": "AlarmCatGetFormat.html"
    },
    "alarmclear": {
      "name": "AlarmClear",
      "returnType": "UNKNOWN",
      "params": [
        "Mode",
        "Value [",
        "ClusterName]"
      ],
      "doc": "Clears an acknowledged (and off) alarm from the active alarm list.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Clear a single alarm where the cursor is positioned:",
        "1": "Clear a page of alarms. AN alarm page can contain more than one alarm list:",
        "2": "Clear a category of alarms:",
        "3": "Clear alarms of a specific priority.",
        "Mode": "AlarmClear(Mode, Value [, ClusterName] )",
        "Value": "Used with Mode 1 or 2 to specify which alarms to clear.",
        "ClusterName": "Used with Mode 2 or 3 to specify the name of the cluster in which the alarms being cleared reside. This argument is optional if the client is connected to only one cluster containing an Alarm Server or you are resolving the alarm server via the current cluster context."
      },
      "helpPath": "AlarmClear.html"
    },
    "alarmclearrec": {
      "name": "AlarmClearRec",
      "returnType": "UNKNOWN",
      "params": [
        "Record [",
        "ClusterName]"
      ],
      "doc": "Clears an alarm by its record number on both the primary and standby alarms servers.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Record [, ClusterName]": "AlarmClearRec(Record [, ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmClearRec.html"
    },
    "alarmcleartag": {
      "name": "AlarmClearTag",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "[",
        "STRING ClusterName]"
      ],
      "doc": "Clears alarms by tag on both the primary and standby alarms servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Tag": "INT AlarmClearTag(STRING Tag, [, STRING ClusterName])",
        "Tag": "A string that identifies the alarm to acknowledge. It can be one of the following:",
        "ClusterName": "The cluster where the tag resides,"
      },
      "helpPath": "AlarmClearTag.html"
    },
    "alarmcomment": {
      "name": "AlarmComment",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Comment[",
        "INT An]"
      ],
      "doc": "Allows an operator to add a comment to a selected alarm summary or SOE entry during runtime. You would normally call this function from a keyboard command.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Comment": "INT AlarmComment(STRING Comment[,INT An])",
        "Comment": "The comment to add to the alarm summary entry or SOE entry. Currently for the Alarm summary page the maximum length of a comment is 128 characters. The maximum length for a comment on the SOE page is 244 characters. If you exceed the maximum length it will be truncated and an ellipsis appended."
      },
      "helpPath": "AlarmComment.html"
    },
    "alarmcommentrecid": {
      "name": "AlarmCommentRecID",
      "returnType": "UNKNOWN",
      "params": [
        "sComment",
        "sRecID",
        "nListType",
        "sCluster"
      ],
      "doc": "Allows an operator to add a comment to a selected alarm summary or SOE entry during runtime. You would normally call this function from a keyboard command.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sComment,": "INT AlarmCommentRecID(sComment, sRecID, nListType, sCluster)",
        "Comment": "The comment to add to the alarm summary entry or SOE entry. Currently for the Alarm summary page the maximum length of a comment is 128 characters. The maximum length for a comment on the SOE page is 244 characters. If you exceed the maximum length it will be truncated and an ellipsis appended.",
        "nListType": "Following are the nListType values for SOE or Alarm Summary lists.",
        "sCluster": "Specifies the cluster context for the alarms displayed in the list."
      },
      "helpPath": "AlarmCommentRecID.html"
    },
    "alarmcount": {
      "name": "AlarmCount",
      "returnType": "UNKNOWN",
      "params": [
        "INT Type [",
        "STRING FilterCriteria [",
        "LONG KeepAliveSeconds [",
        "INT CachedMode]]]"
      ],
      "doc": "Counts the available alarms for the selected filter criteria.",
      "returns": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
      "paramDocs": {
        "CachedMode": "This function is a blocking function if CachedMode is set to zero (0).",
        "INT Type [, STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode]]]": "LONG AlarmCount(INT Type [, STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode]]])",
        "nType": "The type of alarms to display:",
        "FilterCriteria": "A filter name OR filter text",
        "KeepAliveSeconds": "Optional length of time (in seconds) that the count will remain in memory. Default is 30 seconds."
      },
      "helpPath": "AlarmCount.html"
    },
    "alarmcountequipment": {
      "name": "AlarmCountEquipment",
      "returnType": "UNKNOWN",
      "params": [
        "INT Type [",
        "STRING EquipmentFilter",
        "[STRING FilterCriteria [",
        "LONG KeepAliveSeconds [",
        "INT CachedMode",
        "[INT IncludingReference]]]]]"
      ],
      "doc": "Counts the available alarms for the given equipments in conjunction with the selected filter criteria.",
      "returns": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
      "paramDocs": {
        "INT Type [,STRING EquipmentFilter, [STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode, [INT IncludingReference]]]]]": "LONG AlarmCountEquipment(INT Type [,STRING EquipmentFilter, [STRING FilterCriteria [, LONG KeepAliveSeconds [, INT CachedMode, [INT IncludingReference]]]]])",
        "nType": "The type of alarms to display:",
        "EquipmentFilter": "A comma-separated list of equipment names or categories (RefCat) to filter alarms prior to applying the other filter specified on the FilterCriteria argument. This field has been extended to support wildcards, and hence accept partial filter strings.",
        "FilterCriteria": "A filter name OR filter text.",
        "KeepAliveSeconds": "Optional length of time (in seconds) that the count will remain in memory. Default is 30 seconds.",
        "CachedMode": "Optional flag that causes the current cached value to be supplied even when the value is being refreshed. This makes the function non-blocking. If the property has not yet been cached, an error is set.",
        "IncludingReference": "0 - Do not include alarms belonging to referenced equipment in Alarm Count for current equipment"
      },
      "helpPath": "AlarmCountEquipment.html"
    },
    "alarmcountlist": {
      "name": "AlarmCountList",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN"
      ],
      "doc": "Counts the available alarms for the selected filter criteria.",
      "returns": "Returns counted alarms for the selected filter criteria. Returns -1 when an error is detected.",
      "paramDocs": {
        "INT AN": "LONG AlarmCountList(INT AN)"
      },
      "helpPath": "AlarmCountList.htm"
    },
    "alarmdelete": {
      "name": "AlarmDelete",
      "returnType": "UNKNOWN",
      "params": [
        "Mode",
        "Value [",
        "ClusterName]"
      ],
      "doc": "Deletes alarm summary entries that are currently displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "0 - Delete a single alarm.",
        "2": "2 - Delete a category of alarms.",
        "3": "3 - Delete alarms of a specific priority.",
        "Mode": "AlarmDelete(Mode, Value [, ClusterName] )",
        "Value": "Used with Mode 1 or 2 to specify which alarms to delete.",
        "ClusterName": "Used with Mode 2 or 3 to specify the name of the cluster in which the alarms being deleted reside. This argument is optional if the client is connected to only one cluster containing an Alarm Server or you are resolving the alarm server via the current cluster context. This argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmDelete.html"
    },
    "alarmdisable": {
      "name": "AlarmDisable",
      "returnType": "UNKNOWN",
      "params": [
        "INT Mode",
        "INT Value [",
        "STRING ClusterName [",
        "INT EndTime [",
        "STRING Comment]]]"
      ],
      "doc": "Disables alarms. You can disable the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Disable a single alarm.",
        "1": "Disable a page of alarms. An alarm page can contain more than one alarm list:",
        "2": "Disable a category of alarms.",
        "3": "Disable alarms of a specific priority.",
        "Mode": "INT AlarmDisable(INT Mode, INT Value [, STRING ClusterName [, INT EndTime [, STRING Comment]]] )",
        "Value": "Used with Mode 1 and 2 to specify which alarms to disable.",
        "ClusterName": "Used with Mode 2 or 3 to specify the name of the cluster where the alarms being disabled reside in. This argument is optional if the client is connected to only one cluster containing an alarm server, or if the alarm server is resolved via the current cluster context.",
        "EndTime": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
        "Comment": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed."
      },
      "helpPath": "AlarmDisable.html"
    },
    "alarmdisablerec": {
      "name": "AlarmDisableRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record [",
        "STRING ClusterName [",
        "INT EndTime [",
        "STRING Comment]]]"
      ],
      "doc": "Disables alarms by record number on both the Primary and Standby Alarms Servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Record": "INT AlarmDisableRec(LONG Record [, STRING ClusterName [, INT EndTime [, STRING Comment]]] )",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "EndTime": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
        "Comment": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed."
      },
      "helpPath": "AlarmDisableRec.html"
    },
    "alarmdisabletag": {
      "name": "AlarmDisableTag",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "[",
        "STRING ClusterName] [",
        "INT EndTime [",
        "STRING Comment]]]"
      ],
      "doc": "Disables alarms by Tag on both the Primary and Standby Alarms Servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Tag": "INT AlarmDisableTag(STRING Tag, [, STRING ClusterName] [, INT EndTime [, STRING Comment]]] )",
        "ClusterName": "The cluster where the tag resides.",
        "EndTime": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
        "Comment": "An optional comment explaining why the alarm is disabledAn optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed."
      },
      "helpPath": "AlarmDisableTag.html"
    },
    "alarmdsp": {
      "name": "AlarmDsp",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN",
        "Count [",
        "INT Type] [",
        "STRING ClusterName] [",
        "INT NoDraw] [",
        "STRING CallbackFunc]"
      ],
      "doc": "Displays an alarm list, starting at a specified AN and then on subsequent ANs.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT AN": "INT AlarmDsp(INT AN, Count [, INT Type] [, STRING ClusterName] [, INT NoDraw] [, STRING CallbackFunc] )",
        "AN": "The AN where the first alarm is to display.",
        "Count": "The number of alarms to display.",
        "nType": "The type of alarms to display:",
        "ClusterName": "The cluster name to which the alarms belong. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "NoDraw": "Makes call to Alarm Server to update the ALMCB but does not automatically perform the animation of the data when the result is returned.",
        "CallbackFunc": "Callback function to associate with the return of the ALMCB data from the Alarm Server."
      },
      "helpPath": "AlarmDsp.html"
    },
    "alarmdspclusteradd": {
      "name": "AlarmDspClusterAdd",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sClusterName"
      ],
      "doc": "Adds a cluster to a client's alarm list. Alarms in the specified cluster (that correspond to the mode set in AlarmDsp) will be added to the alarm list at the AN number.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN": "AlarmDspClusterAdd(nAN, sClusterName)",
        "sClusterName": "The name of the cluster to be used for this alarm list. The argument is enclosed in quotation marks (\"\")."
      },
      "helpPath": "AlarmDspClusterAdd.html"
    },
    "alarmdspclusterinuse": {
      "name": "AlarmDspClusterInUse",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sClusterName"
      ],
      "doc": "Determines if a cluster is included in a client's alarm list.",
      "returns": "Returns a Boolean value: True(1) if successful, otherwise False(0) is returned.",
      "paramDocs": {
        "nAN": "AlarmDspClusterInUse(nAN, sClusterName)",
        "sClusterName": "The name of the cluster to query an alarm list for to determine if it's included. The argument is enclosed in quotation marks (\"\")."
      },
      "helpPath": "AlarmDspClusterInUse.html"
    },
    "alarmdspclusterremove": {
      "name": "AlarmDspClusterRemove",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sClusterName"
      ],
      "doc": "Removes a cluster from a client's alarms list. Alarms for the specified cluster will be removed from the alarms list at the AN number.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN": "AlarmDspClusterRemove(nAN, sClusterName)",
        "sClusterName": "The name of the cluster to remove from this alarm list. The argument is enclosed in quotation marks (\"\")."
      },
      "helpPath": "AlarmDspClusterRemove.html"
    },
    "alarmdsplast": {
      "name": "AlarmDspLast",
      "returnType": "UNKNOWN",
      "params": [
        "nAN [",
        "nCount] [",
        "nType] [",
        "sClusterName] [",
        "iNoDraw] [",
        "sCallbackFunc]"
      ],
      "doc": "Displays the latest alarms, at a specified AN with the cluster name. Use this function to display the last alarms.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "AN [, nCount] [, nType] [, sClusterName] [, iNoDraw] [, sCallbackFunc]": "AlarmDspLast(nAN [, nCount] [, nType] [, sClusterName] [, iNoDraw] [, sCallbackFunc] )",
        "nAN": "Note: The [Animator]MaxAn citect.ini parameter sets the maximum AN which AlarmDspLast will work with.",
        "Count": "The number of alarms to display. If you omit the Count, the default is 1.",
        "nType": "nType:",
        "sClusterName": "The cluster name to which the alarms belong. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "iNoDraw": "Makes call to Alarm Server to update the ALMCB but does not automatically perform the animation of the data when the result is returned.",
        "sCallbackFunc": "Callback function to associate with the return of the ALMCB data from the Alarm Server."
      },
      "helpPath": "AlarmDspLast.html"
    },
    "alarmdspnext": {
      "name": "AlarmDspNext",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN"
      ],
      "doc": "Displays the next page of alarms. This function pages down (scrolls) the alarms displayed by the AlarmDsp() function. You would normally call this function from a keyboard command.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Scroll the alarm list where the cursor is positioned.",
        "AN": "INT AlarmDspNext(INT AN)",
        "-1": "Scroll every alarm list displayed on the page."
      },
      "helpPath": "AlarmDspNext.html"
    },
    "alarmdspprev": {
      "name": "AlarmDspPrev",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN"
      ],
      "doc": "Displays the previous page of alarms. This function pages up (scrolls) the alarms displayed by the AlarmDsp() function. You would normally call this function from a keyboard command.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Scroll the alarm list where the cursor is positioned.",
        "INT": "INT AlarmDspPrev(INT AN)",
        "AN": "The AN where the alarm list is displayed, or:",
        "-1": "Scroll every alarm list displayed on the page."
      },
      "helpPath": "AlarmDspPrev.html"
    },
    "alarmenable": {
      "name": "AlarmEnable",
      "returnType": "UNKNOWN",
      "params": [
        "INT Mode",
        "INT Value [",
        "STRING ClusterName [",
        "INT bAcknowledge]]"
      ],
      "doc": "Enables an alarm on the active alarm list. You can enable the alarm where the cursor is positioned, one or more alarm lists on the active page, a whole category of alarms, or alarms of a particular priority.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Enable a single alarm where the cursor is positioned.",
        "1": "Enable a page of alarms. An alarm page can contain more than one alarm list:",
        "2": "Enable a category of alarms.",
        "3": "Enable alarms of a specific priority.",
        "Mode": "INT AlarmEnable(INT Mode, INT Value [, STRING ClusterName [, INT bAcknowledge]] )",
        "Value": "Alarm priority 0 indicates all priorities. Hardware alarms are not affected by priority. 3) Set Value to the group handle to enable a group of alarms of different priorities.",
        "ClusterName": "Used with Mode 2 or 3 to specify the name of the cluster where the alarms being enabled reside in. This argument is optional if the client is connected to only one cluster containing an Alarm Server or are resolving the alarm server via the current cluster context.",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlarmEnable.html"
    },
    "alarmenablerec": {
      "name": "AlarmEnableRec",
      "returnType": "UNKNOWN",
      "params": [
        "INT Record [",
        "STRING ClusterName [",
        "INT bAcknowledge]]"
      ],
      "doc": "Enables alarms by record number on both the Primary and Standby Alarms Servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "(default) enforced acknowledgment will not be applied.",
        "1": "alarm will be acknowledged when enabled.",
        "Record": "INT AlarmEnableRec(INT Record [, STRING ClusterName [, INT bAcknowledge]])",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlarmEnableRec.html"
    },
    "alarmenabletag": {
      "name": "AlarmEnableTag",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "STRING ClusterName [",
        "INT bAcknowledge]]"
      ],
      "doc": "Enables alarms by Tag on both the Primary and Standby Alarms Servers.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "(default) enforced acknowledgment will not be applied.",
        "1": "alarm will be acknowledged when enabled.",
        "Tag": "INT AlarmEnableTag(STRING Tag [, STRING ClusterName [, INT bAcknowledge]])",
        "ClusterName": "The cluster where the tag resides,",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlarmEnableTag.html"
    },
    "alarmeventque": {
      "name": "AlarmEventQue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Opens the alarm event queue. The Alarms Server writes events into this queue as they are processed. These events include activated, reset, acknowledged, enabled and disabled alarms.",
      "returns": "The handle of the alarm event queue, or -1 if the queue cannot be opened.",
      "paramDocs": {},
      "helpPath": "AlarmEventQue_CIREF.html"
    },
    "alarmfilterclose": {
      "name": "AlarmFilterClose",
      "returnType": "UNKNOWN",
      "params": [
        "STRING FilterName"
      ],
      "doc": "This function removes the named filter from memory.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING FilterName": "INT AlarmFilterClose(STRING FilterName)"
      },
      "helpPath": "AlarmFilterClose.html"
    },
    "alarmfiltereditappend": {
      "name": "AlarmFilterEditAppend",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession",
        "STRING FilterCriteria"
      ],
      "doc": "The AlarmFilterEditAppend function takes a session handle and a filter expression as parameters. It appends the provided expression to the current filter session content without any validation.",
      "returns": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT AlarmFilterEditAppend(INT hSession, STRING FilterCriteria)"
      },
      "helpPath": "AlarmFilterEditAppend.html"
    },
    "alarmfiltereditappendequipment": {
      "name": "AlarmFilterEditAppendEquipment",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession",
        "STRING EquipmentFilter",
        "STRING Ref"
      ],
      "doc": "The AlarmFilterEditAppendEquipment function takes a session handle and a filter expression as parameters. It appends the provided expression to the current filter session content without any validation.",
      "returns": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT AlarmFilterEditAppendEquipment(INT hSession, STRING EquipmentFilter, STRING Ref)"
      },
      "helpPath": "AlarmFilterEditAppendEquipment.html"
    },
    "alarmfiltereditclose": {
      "name": "AlarmFilterEditClose",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession"
      ],
      "doc": "The AlmFilterEditClose function removes the session from the memory. The filter is not reset and is valid until a new filter is created and applied.",
      "returns": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT AlarmFilterEditClose(INT hSession)"
      },
      "helpPath": "AlarmFilterEditClose.html"
    },
    "alarmfiltereditcommit": {
      "name": "AlarmFilterEditCommit",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession"
      ],
      "doc": "The AlarmFilterEditCommit function takes a session handle as parameter. It validate the filter created in this session and, if valid, applies this filter to the list associated with the session.",
      "returns": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT AlarmFilterEditCommit(INT hSession)"
      },
      "helpPath": "AlarmFilterEditCommit.html"
    },
    "alarmfiltereditfirst": {
      "name": "AlarmFilterEditFirst",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession"
      ],
      "doc": "This function takes a session handle parameter. It gets the first part of the filter.",
      "returns": "First part of filter or if does not exist an empty string \"\".",
      "paramDocs": {
        "STRING": "STRING AlarmFilterEditFirst(INT hSession)",
        "Session": "Session"
      },
      "helpPath": "AlarmFilterEditFirst.html"
    },
    "alarmfilteredithasfield": {
      "name": "AlarmFilterEditHasField",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession",
        "STRING sFieldName"
      ],
      "doc": "The AlarmFilterEditHasField function checks whether an alarm field name or any field in a set of field names is used in the filter specified in an alarm filter edit session.",
      "returns": "1 (TRUE) if the filter criteria is valid and alarm field name is used, otherwise 0 (FALSE) is returned.",
      "paramDocs": {
        "INT": "INT AlarmFilterEditHasField(INT hSession, STRING sFieldName)"
      },
      "helpPath": "AlarmFilterEditHasField.htm"
    },
    "alarmfiltereditlast": {
      "name": "AlarmFilterEditLast",
      "returnType": "UNKNOWN",
      "params": [
        "hSession"
      ],
      "doc": "This function takes a session handle parameter. It gets the last part of the filter.",
      "returns": "First part of filter or if does not exist an empty string \"\".",
      "paramDocs": {
        "hSession": "STRING AlarmFilterEditLast(hSession)",
        "Session": "Session"
      },
      "helpPath": "AlarmFilterEditLast.html"
    },
    "alarmfiltereditnext": {
      "name": "AlarmFilterEditNext",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession"
      ],
      "doc": "This function takes a session handle parameter. It gets the next part of the filter.",
      "returns": "Next part of filter or if does not exist an empty string \"\".",
      "paramDocs": {
        "INT hSession": "INT AlarmFilterEditNext(INT hSession)",
        "Session": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen()."
      },
      "helpPath": "AlarmFilterEditNext.html"
    },
    "alarmfiltereditopen": {
      "name": "AlarmFilterEditOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING FilterName or INT AN or INT -1 [",
        "INT AutoCloseMode]"
      ],
      "doc": "The AlmFilterEditOpen function creates a session for the historical list (or lists) associated with the provided animation number (AN) or FilterName or all alarm lists displayed on the page via (-1) option.",
      "returns": "Returns a session handle to the filter browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING FilterName or INT AN or INT -1 [, INT AutoCloseMode]": "INT AlarmFilterEditOpen(STRING FilterName or INT AN or INT -1 [, INT AutoCloseMode])"
      },
      "helpPath": "AlarmFilterEditOpen.html"
    },
    "alarmfiltereditprev": {
      "name": "AlarmFilterEditPrev",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession"
      ],
      "doc": "This function takes a session handle parameter. It gets the previous part of the filter.",
      "returns": "Previous part of filter or if does not exist an empty string \"\".",
      "paramDocs": {
        "INT hSession": "STRING AlarmFilterEditPrev(INT hSession )",
        "Session": "Session handle for the historical list previously returned by the function AlarmFilterEditOpen()."
      },
      "helpPath": "AlarmFilterEditPrev.html"
    },
    "alarmfiltereditset": {
      "name": "AlarmFilterEditSet",
      "returnType": "UNKNOWN",
      "params": [
        "INT hSession",
        "STRING FilterCriteria"
      ],
      "doc": "The AlarmFilterEditSet function takes a session handle and a filter expression as parameters. It replaces the current filter session content by the provided expression without any validation.",
      "returns": "0 (zero) if the alarm filter session exists, otherwise an error code is returned.",
      "paramDocs": {
        "INT hSession, STRING FilterCriteria": "INT AlarmFilterEditSet(INT hSession, STRING FilterCriteria)"
      },
      "helpPath": "AlarmFilterEditSet.html"
    },
    "alarmfilterform": {
      "name": "AlarmFilterForm",
      "returnType": "UNKNOWN",
      "params": [
        "INT nIndex",
        "INT nMode = 0",
        "INT nDebug = 0",
        "STRING nFilterSrc = \"-1\""
      ],
      "doc": "Displays a form for specifying filtering criteria for either an alarm list or a named filter. This function uses the AlarmFilterEdit family of Cicode functions to set the filter.",
      "returns": "1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made.",
      "paramDocs": {
        "INT nIndex, INT nMode = 0, INT nDebug = 0, STRING nFilterSrc = \"-1\"": "INT AlarmFilterForm(INT nIndex, INT nMode = 0, INT nDebug = 0, STRING nFilterSrc = \"-1\")"
      },
      "helpPath": "AlarmFilterForm.html"
    },
    "alarmfilteropen": {
      "name": "AlarmFilterOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING FilterName",
        "INT OpenMode [",
        "INT AutoCloseMode]"
      ],
      "doc": "This function creates a named filter. The filter is initialized with empty content (matches all alarms). If unable to open the named filter an error code is returned.",
      "returns": "0 (zero) if the filter was opened or created or an error if unsuccessful.",
      "paramDocs": {
        "STRING FilterName, INT OpenMode [, INT AutoCloseMode]": "INT AlarmFilterOpen(STRING FilterName, INT OpenMode [, INT AutoCloseMode])"
      },
      "helpPath": "AlarmFilterOpen.html"
    },
    "alarmfirstcatrec": {
      "name": "AlarmFirstCatRec",
      "returnType": "UNKNOWN",
      "params": [
        "INT Category",
        "INT Type [",
        "INT Area] [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the first occurrence of an alarm category and type. You can search all areas, the current area only, or specify an area to limit the search.",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "INT Category, INT Type [, INT Area] [, STRING ClusterName]": "LONG AlarmFirstCatRec(INT Category, INT Type [, INT Area] [, STRING ClusterName] )",
        "Category": "The alarm category or group number to match. Set Category to 0 (zero) to match all alarm categories.",
        "nType": "The type of alarms to display:",
        "Area": "The area in which to search for alarms. If you do not specify an area, or if you set Area to -1, only the current area will be searched.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmFirstCatRec.html"
    },
    "alarmfirstprirec": {
      "name": "AlarmFirstPriRec",
      "returnType": "UNKNOWN",
      "params": [
        "INT Priority",
        "INT Type [",
        "INT Area] [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the first occurrence of an alarm priority and type. You can search all areas, the current area only, or specify an area to limit the search.",
      "returns": "The alarm record identifier or -1 if no match is found. If you do not specify an area, only alarms in the current area on the alarms server are searched.",
      "paramDocs": {
        "INT Priority, INT Type [, INT Area] [, STRING ClusterName]": "LONG AlarmFirstPriRec(INT Priority, INT Type [, INT Area] [, STRING ClusterName] )",
        "Priority": "The alarm Priority or group handle of a group of alarm priorities. Set Priority to 0 (zero) to match all alarm priorities.",
        "nType": "The type of alarms to display:",
        "Area": "The area in which to search for alarms. If you do not specify an area, or if you set Area to -1, only the current area will be searched.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmFirstPriRec.html"
    },
    "alarmfirsttagrec": {
      "name": "AlarmFirstTagRec",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "STRING Name",
        "STRING Description [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the first occurrence of an alarm tag, name, and description.",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "STRING Tag": "LONG AlarmFirstTagRec(STRING Tag, STRING Name, STRING Description [, STRING ClusterName] )",
        "Tag": "A string that identifies the tag to be matched. It can be one of the following:",
        "Name": "The alarm name to be matched. Specify an empty string (\" \") to match all alarm names.",
        "Description": "The alarm description to be matched. Specify an empty string (\" \") to match all alarm descriptions.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmFirstTagRec.html"
    },
    "alarmgetdelay": {
      "name": "AlarmGetDelay",
      "returnType": "UNKNOWN",
      "params": [
        "Type"
      ],
      "doc": "Gets the delay setting for the alarm the cursor is currently positioned over.",
      "returns": "The alarm delay if successful, otherwise -1 is returned. Use IsError() to retrieve extended error information.",
      "paramDocs": {
        "0": "Delay (digital alarm/advancedalarm)",
        "1": "High high delay (analog alarm)",
        "2": "High delay (analog alarm)",
        "3": "Low delay (analog alarm)",
        "4": "Low low delay (analog alarm)",
        "5": "Deviation delay (analog alarm)",
        "Type": "LONG AlarmGetDelay(Type)",
        "nType": "The type of delay:"
      },
      "helpPath": "AlarmGetDelay.html"
    },
    "alarmgetdelayrec": {
      "name": "AlarmGetDelayRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Type [",
        "STRING ClusterName]"
      ],
      "doc": "Gets the delay setting for an alarm via the alarm record number.",
      "returns": "The alarm delay if successful, otherwise -1 is returned. Use IsError() to retrieve extended error information.",
      "paramDocs": {
        "0": "Delay (digital alarm/advancedalarm)",
        "1": "High high delay (analog alarm)",
        "2": "High delay (analog alarm)",
        "3": "Low delay (analog alarm)",
        "4": "Low low delay (analog alarm)",
        "5": "Deviation delay (analog alarm)",
        "LONG Record": "LONG AlarmGetDelayRec(LONG Record, INT Type [, STRING ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Type": "The type of delay:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmGetDelayRec.html"
    },
    "alarmgetdsp": {
      "name": "AlarmGetDsp",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN",
        "STRING Field"
      ],
      "doc": "Gets field data from the alarm record that is displayed at the specified AN.",
      "returns": "The alarm field data (as a string) or empty string \"\".",
      "paramDocs": {
        "STRING": "STRING AlarmGetDsp(INT AN, STRING Field)",
        "AN": "AN number of an ALMCB Alarm record. Equal to AN where actual ALMCB resides + Offset into the list of ALMCB records.",
        "Field": "The name of the field from which the data is retrieved. The contents of the following fields can be retrieved when the Alarm Page is displayed:"
      },
      "helpPath": "AlarmGetDsp.html"
    },
    "alarmgetfieldrec": {
      "name": "AlarmGetFieldRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "STRING Field [",
        "INT Ver [",
        "STRING ClusterName]]"
      ],
      "doc": "Gets the contents of the specified field in the specified alarm record.",
      "returns": "The alarm field data (as a string) or empty string \"\".",
      "paramDocs": {
        "(LONG Record, STRING Field [, INT Ver [, STRING ClusterName]])": "STRING AlarmGetFieldRec(LONG Record, STRING Field [, INT Ver [, STRING ClusterName]])",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Field": "The name of the field from which the data is retrieved.",
        "nVer": "The version of an alarm.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmGetFieldRec.html"
    },
    "alarmgetfiltername": {
      "name": "AlarmGetFilterName",
      "returnType": "UNKNOWN",
      "params": [
        "INT An"
      ],
      "doc": "Retrieves the name of the linked named filter for the supplied An. If empty text, there is currently no linked named filter.",
      "returns": "Name of linked filter or \"\".",
      "paramDocs": {
        "INT An": "STRING AlarmGetFilterName(INT An)"
      },
      "helpPath": "AlarmGetFilterName.html"
    },
    "alarmgetinfo": {
      "name": "AlarmGetInfo",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN",
        "INT Type [",
        "STRING ClusterName]"
      ],
      "doc": "Gets data on the alarm list displayed at a specified AN. Use this function to display the current alarm list information on an alarm page. If only one alarm list has been configured on an alarm page, modes 2 and 3 of this function return the current alarm page information.",
      "returns": "Alarm list data as a numeric value.",
      "paramDocs": {
        "0": "Alarm page number. The vertical offset (in pages) from the AN where the alarm list commenced. The alarm list need to have scrolled off the first page for this type to return a non-zero value.",
        "1": "Alarm list offset. The vertical offset (in lines) from the AN where the alarm list commenced. You need to have scrolled off the first page of alarms for this type to return a non zero value.",
        "2": "Category of alarms displayed on the alarm list. You can use a group number to display a group of categories.",
        "3": "Type of alarms displayed on the alarm list. See AlarmDsp() for a list of these types.",
        "7": "Priority of alarms displayed on the alarm list. The return value may be a group number if the alarm list contains alarms of more than one priority.",
        "8": "Display mode of the alarm list.",
        "9": "Sorting mode of the alarm list.",
        "10": "Reading this field is invalid, use the function AlarmGetOrderbyKey.",
        "11": "Retrieves the error code for the last alarm summary request that was not able to be processed due to a buffer overflow. The last request error value will be reset on the next successful response from the servers.",
        "12": "Returns values as follows:",
        "13": "Returns values as follows;",
        "14": "Identifies if the data is available for a particular cluster. Returns 1 if data is ready, or 0.",
        "15": "Auto-refresh mode, where mode is:",
        "16": "Timeout occurred. This value is set to 0 when a data fetch is initiated for the supplied alarm list (indicated by AN). This value is set to 1 if a timeout occurs within the fetch. The timeout period is specified by the INI parameter [Alarm]AlarmListRequestTimeout.",
        "17": "Alarm page number for specified AN is displayed. When the alarm list is scrolled by vertical offset (in lines), the list may span across two pages of alarms. Calling this function returns the page number of the alarm list that the specified AN is displaying. This differs to Type 0 which returns the page number based on the first line of the alarm display.",
        "LONG": "LONG AlarmGetInfo(INT AN, INT Type [, STRING ClusterName])",
        "AN": "The AN where the alarm list (with the required information) is displayed. Set the AN to 0 (zero) to get information on the alarm list where the cursor is positioned.",
        "Type": "The type of data:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is only required for type 14. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmGetInfo.html"
    },
    "alarmgetorderbykey": {
      "name": "AlarmGetOrderbyKey",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Retrieves the list of key(s) that are used to determine the order of the alarm list. These keys can be set by the AlarmSetInfo() function.",
      "returns": "Order-by key (as a string).",
      "paramDocs": {
        "nAN": "AlarmGetOrderbyKey(nAN)"
      },
      "helpPath": "AlarmGetOrderbyKey.html"
    },
    "alarmgetthreshold": {
      "name": "AlarmGetThreshold",
      "returnType": "UNKNOWN",
      "params": [
        "Type"
      ],
      "doc": "Gets the threshold of the analog alarm where the cursor is positioned.",
      "returns": "The alarm threshold.",
      "paramDocs": {
        "0": "High high",
        "1": "High",
        "2": "Low",
        "3": "Low low",
        "4": "Deadband",
        "5": "Deviation",
        "6": "Rate of change",
        "Type": "AlarmGetThreshold(Type)",
        "nType": "The type of threshold:"
      },
      "helpPath": "AlarmGetThreshold.html"
    },
    "alarmgetthresholdrec": {
      "name": "AlarmGetThresholdRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Type [",
        "STRING ClusterName]"
      ],
      "doc": "Gets the threshold of analog alarms by the alarm record number.",
      "returns": "The alarm threshold or 0.0.",
      "paramDocs": {
        "0": "High high",
        "1": "High",
        "2": "Low",
        "3": "Low low",
        "4": "Deadband",
        "5": "Deviation",
        "6": "Rate of change",
        "(LONG Record, INT Type [, STRING ClusterName])": "INT AlarmGetThresholdRec(LONG Record, INT Type [, STRING ClusterName])",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Type": "The type of threshold:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmGetThresholdRec.html"
    },
    "alarmhelp": {
      "name": "AlarmHelp",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the alarm help page (associated with the alarm) where the cursor is positioned. You can assign a help page to each alarm when you define it (using the Digital Alarms or the Analog Alarms database, depending on the type of alarm). You need to also define the help page in the Pages database.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "AlarmHelp.html"
    },
    "alarmhighestpriority": {
      "name": "AlarmHighestPriority",
      "returnType": "UNKNOWN",
      "params": [
        "INT Mode [",
        "STRING EquipmentFilter] [",
        "STRING FilterCriteria] [",
        "LONG KeepAliveSeconds] [",
        "INT CachedMode] [",
        "INT IncludingReference]"
      ],
      "doc": "Returns the alarm priority and/or state of the current highest priority alarm for the given equipment in conjunction with the selected filter criteria.",
      "returns": "For Mode 0, return the priority ID of the current highest priority alarm.",
      "paramDocs": {
        "Mode": "Mode",
        "EquipmentFilter": "A comma-separated list of equipment names to filter alarms prior to applying the filter specified in the FilterCriteria argument. Each equipment name may be a part of full equipment name from the root. For example, \"Region.Plant\" will count alarms with equipment names literally starting with \"Region.Plant\" that includes \"Region.PlantA\" and \"Region.Plant.AreaB\". If it is needed to count children of a particular equipment tree only, the equipment name should end with a period('.'). A comma in between equipment expressions is regarded as an OR operator. If an empty string is specified, return Highest Priority for all Alarms.",
        "FilterCriteria": "A filter name OR filter text. See the topic Implementing Alarm Filters Using Cicode in the main Plant SCADA help for more information about filter syntax.",
        "KeepAliveSeconds": "Optional length of time (in seconds) for which the count will remain in memory. Default is 30 seconds.",
        "CachedMode": "Optional flag that causes the current cached value to be supplied even when the value is being refreshed. This makes the function non-blocking. If the property has not yet been cached, an error is set.",
        "IncludingReference": "0 - Do not include alarms belonging to referenced equipment in AlarmHighestPriority for current equipment",
        "Type": "The rule used to determine the relative priority of alarms (currently fixed to 0)."
      },
      "helpPath": "AlarmHighestPriority.htm"
    },
    "alarmlistcreate": {
      "name": "AlarmListCreate",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT alarm_type",
        "INT width",
        "INT height",
        "INT rowheight",
        "INT drawheader [",
        "STRING sCluster [",
        "STRING sFormat [",
        "INT hFontRow [",
        "INT hFontHeader]]]]"
      ],
      "doc": "Creates an alarms list at a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTAlarmListCreate(INT nAN, INT alarm_type, INT width, INT height, INT rowheight, INT drawheader [, STRING sCluster [, STRING sFormat [, INT hFontRow [, INT hFontHeader]]]])",
        "alarm_type": "The type of alarms to display in the alarms list:",
        "width": "The width of the area in which the alarms list will display (in pixels).",
        "height": "The height of the area in which the alarms list will display (in pixels).",
        "rowheight": "The height of each row in the alarms list (in pixels).",
        "drawheader": "Determines if the alarms list includes a header row. You need to enter a value; there is no default.",
        "sCluster": "Specifies the cluster context for the alarms displayed in the list. This value is optional. If not specified, it defaults to all clusters.",
        "sFormat": "The name of the display format applied to the alarms list. This determines the arrangement of columns that are presented. A customized name can be defined for a display format using the parameter [Format]FormatName.",
        "hFontRow": "The handle for the font you would like to use in the alarm list rows. This value is optional. If not specified, it defaults to 1 (the default font).",
        "hFontHeader": "The handle for the font you would like to use in the alarm list header row. This value is optional. If not specified, it defaults to 1 (the default font)."
      },
      "helpPath": "AlarmListCreate.html"
    },
    "alarmlistdestroy": {
      "name": "AlarmListDestroy",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Destroys an alarms list at a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTAlarmListDestroy(INT nAN)"
      },
      "helpPath": "AlarmListDestroy.html"
    },
    "alarmlistdisplay": {
      "name": "AlarmListDisplay",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Displays an alarms list at a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTAlarmListDisplay(INT nAN)"
      },
      "helpPath": "AlarmListDisplay.html"
    },
    "alarmlistfill": {
      "name": "AlarmListFill",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Fills an alarms list at a specified AN to be used by another routine.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTAlarmListFill(INT nAN)"
      },
      "helpPath": "AlarmListFill.html"
    },
    "alarmnextcatrec": {
      "name": "AlarmNextCatRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Category",
        "INTType [",
        "INT Area] [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the next occurrence of an alarm category and type, commencing with the specified alarm record identifier (returned from the previous search through the AlarmFirstCatRec function).",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "LONG Record": "LONG AlarmNextCatRec(LONG Record, INT Category, INTType [, INT Area] [, STRING ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Category": "The alarm category or group number to match. Set Category to 0 (zero) to match all alarm categories.",
        "nType": "The type of alarms to display:",
        "Area": "The area in which to search for alarms. If you choose to omit the area, or if you set Area to -1, only the current area will be searched.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmNextCatRec.html"
    },
    "alarmnextprirec": {
      "name": "AlarmNextPriRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Priority",
        "INT Type [",
        "INT Area] [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the next occurrence of an alarm of a specified priority and type, commencing with the specified alarm record identifier (returned from the previous search through the AlarmFirstPriRec() function).",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "LONG Record": "INT AlarmNextPriRec(LONG Record, INT Priority, INT Type [, INT Area] [, STRING ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Priority": "The alarm Priority or group handle of a group of alarm priorities. Set Priority to 0 (zero) to match all alarm priorities.",
        "nType": "The type of alarms to display:",
        "Area": "The area in which to search for alarms. Set Area to -1 to search all areas. If you do not specify an area, only alarms in the current area on the Alarms Server are searched.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmNextPriRec.html"
    },
    "alarmnexttagrec": {
      "name": "AlarmNextTagRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "STRING Tag",
        "STRING Name",
        "VDescription [",
        "STRING ClusterName]"
      ],
      "doc": "Searches for the next occurrence of an alarm tag, name, and description, starting with the alarm record identifier (returned from the previous search through the AlarmFirstTagRec() function).",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "LONG Record": "LONG AlarmNextTagRec(LONG Record, STRING Tag, STRING Name, VDescription [,STRING ClusterName] )",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Tag": "A string that identifies the tag to be matched. It can be one of the following:",
        "Name": "The alarm name to be matched. Specify an empty string (\" \") to match all alarm names.",
        "Description": "The alarm description to be matched. Specify an empty string (\" \") to match all alarm descriptions.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmNextTagRec.html"
    },
    "alarmnotifyvarchange": {
      "name": "AlarmNotifyVarChange",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "Value",
        "Timestamp [",
        "TimestampMS] [",
        "sClusterName] [",
        "bSync]"
      ],
      "doc": "This function is used to provide time-stamped digital and time-stamped analog alarms with data. When called, it notifies the alarm server that the specified variable tag has changed.",
      "returns": "For synchronous mode, the return value will be the error that was detected when the function was called. For asynchronous mode, the return value will be 0, unless there was no server available.",
      "paramDocs": {
        "Tag, Value, Timestamp [, TimestampMS] [, sClusterName] [, bSync]": "AlarmNotifyVarChange(Tag, Value, Timestamp [, TimestampMS] [, sClusterName] [, bSync] )",
        "Tag": "Name of the variable tag that has changed as a string. This name may include the name of the tag's cluster in the form cluster.tagname. This cluster name may be different from the cluster of the alarm server indicated by ClusterName below.",
        "Value": "Value of the variable tag at the time of the change as a floating-point number",
        "Timestamp": "Time/date at which the variable tag changed in the standard Plant SCADA time/date variable format (Seconds since 1970).",
        "TimestampMS": "Millisecond portion of the time at which the variable tag changed.",
        "sClusterName": "Name of the cluster of the alarm server. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "bSync": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non-blocking). If it is specified as synchronous (true) the function will wait until the notification has been recorded into the alarm database before further code execution. If it is specified as asynchronous (false) the function will only return an error if no alarm server is currently available."
      },
      "helpPath": "AlarmNotifyVarChange.html"
    },
    "alarmqueryfirstrec": {
      "name": "AlarmQueryFirstRec",
      "returnType": "UNKNOWN",
      "params": [
        "Group",
        "nType",
        "Area",
        "QueryType [",
        "sClusterName]"
      ],
      "doc": "Searches for the first occurrence of an alarm category (or priority) and type. This is a wrapper function of AlarmFirstCatRec and AlarmFirstPriRec.",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "Group, nType, Area, QueryType [, sClusterName]": "AlarmQueryFirstRec(Group, nType, Area, QueryType [, sClusterName] )",
        "Group": "Alarm category if QueryType is 0 or alarm priority if QueryType is 1.",
        "nType": "The type of alarms to display:",
        "Area": "Area in which to search for alarms. Set Area to -1 to search all areas.",
        "QuerynType": "Query type.",
        "sClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmQueryFirstRec.html"
    },
    "alarmquerynextrec": {
      "name": "AlarmQueryNextRec",
      "returnType": "UNKNOWN",
      "params": [
        "Record",
        "Group",
        "nType",
        "Area",
        "QueryType [",
        "sClusterName]"
      ],
      "doc": "Searches for the next occurrence of an alarm category (or priority) and type, commencing with the specified alarm record identifier (returned from the previous search through the alarm query functions).",
      "returns": "The alarm record identifier or -1 if no match is found.",
      "paramDocs": {
        "Record, Group, nType, Area, QueryType [, sClusterName]": "AlarmQueryNextRec(Record, Group, nType, Area, QueryType [, sClusterName] )",
        "Record": "Alarm record number.",
        "Group": "Alarm Category if QueryType is 0 or alarm priority if QueryType is 1.",
        "nType": "The type of alarms to display:",
        "Area": "Area in which to search for alarms. Set Area to -1 to search all areas.",
        "QuerynType": "Query type.",
        "sClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmQueryNextRec.html"
    },
    "alarmresetquery": {
      "name": "AlarmResetQuery",
      "returnType": "UNKNOWN",
      "params": [
        "STRING FilterSrc"
      ],
      "doc": "Clears the filter of the specified filter source. Used to reset the filter set up by the Cicode function AlarmFilterForm().",
      "returns": "None",
      "paramDocs": {
        "STRING FilterSrc": "AlarmResetQuery(STRING FilterSrc)"
      },
      "helpPath": "AlarmResetQuery.html"
    },
    "alarmsetdelay": {
      "name": "AlarmSetDelay",
      "returnType": "UNKNOWN",
      "params": [
        "Type",
        "Value"
      ],
      "doc": "Changes the delay setting for an alarm (that is Delay, High High Delay, Deviation Delay, etc.). This function acts on the alarm that the cursor is positioned over. Use this function during runtime to change the delay values that were specified in the alarms database.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Delay (digital alarm/advanced alarm)",
        "1": "High high delay (analog alarm)",
        "2": "High delay (analog alarm)",
        "3": "Low delay (analog alarm)",
        "4": "Low low delay (analog alarm)",
        "5": "Deviation delay (analog alarm)",
        "Type": "AlarmSetDelay(Type, Value)",
        "nType": "The type of delay:",
        "Value": "The new value for the delay. Enter a blank value \" \" to remove the delay setting."
      },
      "helpPath": "AlarmSetDelay.html"
    },
    "alarmsetdelayrec": {
      "name": "AlarmSetDelayRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Type",
        "INT Value",
        "STRING ClusterName"
      ],
      "doc": "Changes the delay setting for an alarm (that is Delay, High High Delay, Deviation Delay, etc.) by the alarm record number. You can only call this function on an alarms server for local alarms, or on a redundant server if one has been configured.",
      "paramDocs": {
        "0": "Delay (digital alarm/advanced alarm)",
        "1": "High high delay (analog alarm)",
        "2": "High delay (analog alarm)",
        "3": "Low delay (analog alarm)",
        "4": "Low low delay (analog alarm)",
        "5": "Deviation delay (analog alarm)",
        "LONG": "INT AlarmSetDelayRec(LONG Record, INT Type, INT Value, STRING ClusterName)",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "nType": "The type of delay:",
        "Value": "The new value for the delay. Enter a blank value \" \" to remove the delay setting.",
        "sClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSetDelayRec.html"
    },
    "alarmsetinfo": {
      "name": "AlarmSetInfo",
      "returnType": "UNKNOWN",
      "params": [
        "INT AN",
        "INT Type",
        "STRING Value"
      ],
      "doc": "Controls different aspects of the alarm list displayed at a specified AN. Currently applies only to non-hardware alarm lists.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Change the display parameters of the alarm list where the cursor is positioned.",
        "1": "Alarm list offset. The vertical offset (in lines) from the AN where the alarm list commenced.",
        "2": "Category of alarms displayed on the alarm list. To specify all categories use a value of 0.",
        "3": "Type of alarms displayed on the alarm list. See AlarmDsp() for a list of these types.",
        "4": "Display all alarms according to the format and fonts specified for one category (specified in Value).",
        "5": "The display format for all alarms specified by a format handle. All of the alarm categories will display in the same format.",
        "6": "The display font for all user alarms specified by a font handle. All of the user alarms will appear in the same font and color.",
        "7": "The priority of the alarms to be displayed in the alarm list. You can use a group number to display a group of priorities.",
        "8": "Use the Value argument of the AlarmSetInfo() function to specify whether the display mode of the alarm list is based on Alarm Category or Priority:",
        "9": "Use the Value argument of the AlarmSetInfo() function to specify the sorting mode of the alarm list:",
        "10": "Use the Alarm Order-by key specified in the Value argument of the AlarmSetInfo() function to determine the order in which the alarm list will be displayed.",
        "11": "Invalid to set this field.",
        "12": "Associate or disassociate a named filter. By setting this field to text, you associate the specified AN to a named filter which is then applied to an alarm display list. Setting this type to empty text, will unlink from any named filter, but the disassociated alarm list will retain its value, hence the filter will still be in place until a new filter is applied. If setting the Value to text that does not correspond to a named filter, the value read back (using AlarmGetFilterName()) will be empty.",
        "15": "Auto-refresh mode, where mode is:",
        "16": "Invalid to set this field.",
        "INT": "INT AlarmSetInfo(INT AN, INT Type, STRING Value)",
        "AN": "The AN where the alarm list originally commenced. (AN alarm page can contain more than one alarm list). You can also specify:",
        "-1": "Change the display parameters of all alarm lists displayed on the page.",
        "Type": "The type of data. The aspects and related types are listed below:",
        "Value": "The meaning of the Value argument depends on the data type specified in the Type argument."
      },
      "helpPath": "AlarmSetInfo.html"
    },
    "alarmsetthreshold": {
      "name": "AlarmSetThreshold",
      "returnType": "UNKNOWN",
      "params": [
        "Type",
        "Value"
      ],
      "doc": "Changes the thresholds (that is High High, Low etc.) of analog alarms. This function acts on the analog alarm where the cursor is positioned. Use this function to change (at run time) the threshold values that were specified in the Analog Alarms database.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "High high",
        "1": "High",
        "2": "Low",
        "3": "Low low",
        "4": "Deadband",
        "5": "Deviation",
        "6": "Rate of change",
        "Type": "AlarmSetThreshold(Type, Value)",
        "nType": "The type of threshold:",
        "Value": "The new value of the threshold. Enter a blank value \"\" to remove the threshold."
      },
      "helpPath": "AlarmSetThreshold.html"
    },
    "alarmsetthresholdrec": {
      "name": "AlarmSetThresholdRec",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Record",
        "INT Type",
        "STRING Value [",
        "STRING ClusterName]"
      ],
      "doc": "Changes the threshold (that is High High, Low etc.) of analog alarms by the alarm record number. You can call this function only on an Alarms Server for alarms on that server, or on the redundant server (if a redundant server is configured).",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "High high",
        "1": "High",
        "2": "Low",
        "3": "Low low",
        "4": "Deadband",
        "5": "Deviation",
        "6": "Rate of change",
        "Record": "The alarm record number, returned from any of the following alarm functions:",
        "Type": "The type of threshold:",
        "Value": "The new value of the threshold. Enter a blank value \"\" to remove the threshold.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSetThresholdRec.html"
    },
    "alarmsplit": {
      "name": "AlarmSplit",
      "returnType": "UNKNOWN",
      "params": [
        "[INT AN]"
      ],
      "doc": "Splits an alarm summary entry which has no Off time. The current entry will be given an off time equal to the time when AlarmSplit() is called, and the new entry will have the same On time, with empty Off time.",
      "paramDocs": {
        "[INT AN]": "AlarmSplit([INT AN])",
        "AN": "Animation Number where alarm is displayed. You can:"
      },
      "helpPath": "AlarmSplit.html"
    },
    "alarmsumappend": {
      "name": "AlarmSumAppend",
      "returnType": "UNKNOWN",
      "params": [
        "sTag [",
        "ClusterName",
        "OnTime",
        "OnMilli",
        "bRedundant=true]"
      ],
      "doc": "Appends a new blank record to the alarm summary. Use this function to add new alarm summary entries, either for actual alarms or as special user summary entries.",
      "returns": "The index of the alarm summary entry, or -1 if the record could not be appended.",
      "paramDocs": {
        "sTag": "If you specify a valid alarm tag in the sTag field, the summary entry is linked to the actual alarm. If you specify an asterisk '*' as the first letter of the tag, the summary entry becomes a user event.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "OnTime": "The alarm OnTime (if omitted or is equal to 0, will default to current time, i.e. the time the function was invoked).",
        "OnMilli": "Milliseconds part of the alarm's ON time",
        "bRedundant": "(optional)"
      },
      "helpPath": "AlarmSumAppend.html"
    },
    "alarmsumcommit": {
      "name": "AlarmSumCommit",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName]"
      ],
      "doc": "Commits the alarm summary entry to the Summary Device specified in the alarm category of the entry.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Index [, ClusterName]": "AlarmSumCommit(Index [, ClusterName] )",
        "Index": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumCommit.html"
    },
    "alarmsumdelete": {
      "name": "AlarmSumDelete",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName]"
      ],
      "doc": "Deletes an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.",
      "returns": "0 (zero) if the specified alarm entry exists, otherwise an error is returned.",
      "paramDocs": {
        "Index": "Deletes an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.",
        "Index [, ClusterName]": "AlarmSumDelete(Index [, ClusterName] )",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumDelete.html"
    },
    "alarmsumfind": {
      "name": "AlarmSumFind",
      "returnType": "UNKNOWN",
      "params": [
        "Record",
        "OnTime [",
        "ClusterName]"
      ],
      "doc": "Finds the alarm summary index for an alarm that you specify by the alarm record identifier and alarm activation time (OnTime).",
      "returns": "The index of the alarm summary entry, or -1 if no alarm summary entry is found.",
      "paramDocs": {
        "Record": "AlarmSumFind(Record, OnTime [, ClusterName] )",
        "OnTime": "The ON time of the alarm associated with the Record, that is, the time that the alarm was activated.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumFind.html"
    },
    "alarmsumfirst": {
      "name": "AlarmSumFirst",
      "returnType": "UNKNOWN",
      "params": [
        "[ClusterName]"
      ],
      "doc": "Gets the index of the oldest alarm summary entry.",
      "returns": "The index of the oldest alarm summary entry, or -1 if no alarm summary entry is found.",
      "paramDocs": {
        "[ClusterName]": "AlarmSumFirst( [ClusterName] )",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumFirst.html"
    },
    "alarmsumget": {
      "name": "AlarmSumGet",
      "returnType": "UNKNOWN",
      "params": [
        "Index",
        "sField [",
        "ClusterName]"
      ],
      "doc": "Gets field data from an alarm summary entry. The data is returned as a string. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.",
      "returns": "Field data from the alarm summary entry (as a string).",
      "paramDocs": {
        "Index": "Gets field data from an alarm summary entry. The data is returned as a string. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions. If calling this function from a remote client, use the MsgRPC() function.",
        "sField": "The name of the field from which to extract the data:",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumGet.html"
    },
    "alarmsumlast": {
      "name": "AlarmSumLast",
      "returnType": "UNKNOWN",
      "params": [
        "[ClusterName]"
      ],
      "doc": "Gets the index of the most recent alarm summary entry.",
      "returns": "The index of the most recent alarm summary entry, or -1 if no alarm summary entry is found.",
      "paramDocs": {
        "[ClusterName]": "AlarmSumLast( [ClusterName] )",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumLast.html"
    },
    "alarmsumnext": {
      "name": "AlarmSumNext",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName]"
      ],
      "doc": "Gets the index of the next alarm summary entry, that is, the entry that occurred later than the entry specified by Index.",
      "returns": "The index of the next alarm summary entry or -1 if no more alarm summary entries are found.",
      "paramDocs": {
        "Index [, ClusterName]": "AlarmSumNext(Index [, ClusterName] )",
        "Index": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), or AlarmSumFind() function).",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "See AlarmSumFirst": "See AlarmSumFirst"
      },
      "helpPath": "AlarmSumNext.html"
    },
    "alarmsumprev": {
      "name": "AlarmSumPrev",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName]"
      ],
      "doc": "Gets the index of the previous alarm summary entry, that is, the entry that occurred before the entry specified by Index.",
      "returns": "The index of the previous alarm summary entry or -1 if no more alarm summary entries are found.",
      "paramDocs": {
        "Index.": "Gets the index of the previous alarm summary entry, that is, the entry that occurred before the entry specified by Index. You can use this index in the AlarmSumGet() function to get field data from an alarm record, in the AlarmSumSet() function to change the existing data in that record, or in the AlarmSumDelete() function to delete the record.",
        "Index [, ClusterName]": "AlarmSumPrev(Index [, ClusterName] )",
        "Index": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), or AlarmSumFind() function).",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumPrev.html"
    },
    "alarmsumset": {
      "name": "AlarmSumSet",
      "returnType": "UNKNOWN",
      "params": [
        "Index",
        "sField",
        "sData [",
        "ClusterName]"
      ],
      "doc": "Sets field information in an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.",
      "returns": "0 (zero) if the alarm summary entry exists, otherwise an error is returned.",
      "paramDocs": {
        "Index": "Sets field information in an alarm summary entry. You identify the alarm summary entry by the Index, returned by one of the alarm summary search functions.",
        "sField": "The name of the field in which data is to be set:",
        "sData": "The new value of the field.",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumSet.html"
    },
    "alarmsumsplit": {
      "name": "AlarmSumSplit",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName",
        "OnTime",
        "OnMilli",
        "bRedundant=true]"
      ],
      "doc": "Splits the alarm summary entry identified by index.",
      "returns": "The Index of the new entry, or -1 on error.",
      "paramDocs": {
        "Index [, ClusterName, OnTime, OnMilli, bRedundant=true]": "AlarmSumSplit(Index [, ClusterName, OnTime, OnMilli, bRedundant=true] )",
        "Index": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "OnTime": "The alarm OnTime (if omitted or is equal to 0, will default to current time, i.e. the time the function was invoked).",
        "OnMilli": "Milliseconds part of the alarm's ON time",
        "bRedundant": "(optional)"
      },
      "helpPath": "AlarmSumSplit.html"
    },
    "alarmsumtype": {
      "name": "AlarmSumType",
      "returnType": "UNKNOWN",
      "params": [
        "Index [",
        "ClusterName]"
      ],
      "doc": "Retrieves a value that indicates a specified alarm's type, that is whether it's a digital alarm, an analog alarm, hardware alarm, etc.",
      "returns": "A number that represents one of the following alarm types:",
      "paramDocs": {
        "Index [, ClusterName]": "AlarmSumType(Index [, ClusterName] )",
        "Index": "The alarm summary index (returned from the AlarmSumFirst(), AlarmSumNext(), AlarmSumLast(), AlarmSumPrev(), AlarmSumAppend(), or AlarmSumFind() function).",
        "ClusterName": "Specifies the name of the cluster in which the Alarm Server resides. This is optional if you have one cluster or are resolving the alarm server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AlarmSumType.html"
    },
    "alarmtagfromequipment": {
      "name": "AlarmTagFromEquipment",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "[",
        "STRING ClusterName]"
      ],
      "doc": "Returns the first tag asscoiated with a piece of equipment.",
      "returns": "0 (zero) if successful, otherwise an error code will be returned",
      "paramDocs": {
        "INT": "INT AlarmTagFromEquipment(STRING Tag, [, STRING ClusterName])",
        "Tag": "A string that identifies the alarm to acknowledge. It can be one of the following:",
        "ClusterName": "The cluster in which the tag resides"
      },
      "helpPath": "AlarmTagFromEquipment.htm"
    },
    "almbrowseack": {
      "name": "AlmBrowseAck",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowseAck function acknowledges the alarm tag at the current cursor position in an active data browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG": "INT AlmBrowseAck(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowseAck.html"
    },
    "almbrowseclose": {
      "name": "AlmBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG": "INT AlmBrowseClose(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowseClose.html"
    },
    "almbrowsedisable": {
      "name": "AlmBrowseDisable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT EndTime [",
        "STRING Comment]]"
      ],
      "doc": "The AlmBrowseDisable function disables the alarm tag at the current cursor position in an active data browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "INT AlmBrowseDisable(INT iSession [, INT EndTime [, STRING Comment]] )",
        "Comment": "Comment"
      },
      "helpPath": "AlmBrowseDisable.html"
    },
    "almbrowseenable": {
      "name": "AlmBrowseEnable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT bAcknowledge]"
      ],
      "doc": "The AlmBrowseEnable function enables the alarm tag at the current cursor position in an active data browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "0": "(default) enforced acknowledgment will not be applied.",
        "1": "alarm will be acknowledged when enabled.",
        "iSession": "INT AlmBrowseEnable(INT iSession [, INT bAcknowledge])",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlmBrowseEnable.html"
    },
    "almbrowsefirst": {
      "name": "AlmBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG": "INT AlmBrowseFirst(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowseFirst.html"
    },
    "almbrowsegetfield": {
      "name": "AlmBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession",
        "STRING FieldName"
      ],
      "doc": "The AlmBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG": "STRING AlmBrowseGetField(LONG iSession, STRING FieldName)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call.",
        "sFieldName": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "AlmBrowseGetField.html"
    },
    "almbrowsenext": {
      "name": "AlmBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the browse has successfully been moved to the next record, otherwise an error code is returned.",
      "paramDocs": {
        "LONG": "INT AlmBrowseNext(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowseNext.html"
    },
    "almbrowsenumrecords": {
      "name": "AlmBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "LONG": "LONG AlmBrowseNumRecords(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowseNumRecords.html"
    },
    "almbrowseopen": {
      "name": "AlmBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "Filter",
        "STRING Fields [",
        "STRING Clusters [",
        "INT AutoCloseMode]]"
      ],
      "doc": "The AlmBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls. Use this function to browse all configured alarms.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "Filter, STRING Fields [, STRING Clusters [,INT AutoCloseMode]]": "LONG AlmBrowseOpen( Filter, STRING Fields [, STRING Clusters [,INT AutoCloseMode]] )",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned. Where a fieldname is not specified in the filter, it is assumed to be tagname. For example, the filter \"AAA\" is equivalent to \"Tag=AAA\". Multiple filters separated by semicolons are supported.",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.",
        "AutoCloseMode": "AutoCloseMode"
      },
      "helpPath": "AlmBrowseOpen.html"
    },
    "almbrowseprev": {
      "name": "AlmBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG": "INT AlmBrowsePrev(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmBrowseOpen call."
      },
      "helpPath": "AlmBrowsePrev.html"
    },
    "almsummaryack": {
      "name": "AlmSummaryAck",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The AlmSummaryAck function acknowledges the alarm in the active alarm list which is linked to the current entry of the alarm summary browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT AlmSummaryAck(LONG Session)",
        "Session": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryAck.html"
    },
    "almsummaryclear": {
      "name": "AlmSummaryClear",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The AlmSummaryClear function clears the latched alarm at the current cursor position in an active data browse session. A latched alarm is an alarm which is OFF and acknowledged when [Alarm]AckHold is set to 1.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT AlmSummaryClear(LONG Session)",
        "Session": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryClear.html"
    },
    "almsummaryclose": {
      "name": "AlmSummaryClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryClose function terminates an active data browse session and cleans up all resources associated with the session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG iSession": "INT AlmSummaryClose(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryClose.html"
    },
    "almsummarycommit": {
      "name": "AlmSummaryCommit",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The AlmSummaryCommit function triggers the actual write of the value for the field previously specified by AlmSummarySetFieldValue.",
      "paramDocs": {
        "iSession": "AlmSummaryCommit(iSession)"
      },
      "helpPath": "AlmSummaryCommit.html"
    },
    "almsummarydelete": {
      "name": "AlmSummaryDelete",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryDelete function deletes the record in the filtered list that the cursor is currently referencing. The cursor moves to the next available entry in the data browse session after the current alarm summary is deleted.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "(LONG iSession)": "INT AlmSummaryDelete(LONG iSession)",
        "iSession": "The handle to a filtered list previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryDelete.html"
    },
    "almsummarydeleteall": {
      "name": "AlmSummaryDeleteAll",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryDeleteAll function deletes every record from the filtered list source.",
      "returns": "0 (zero) if the alarm filtered list session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG iSession": "INT AlmSummaryDeleteAll(LONG iSession)",
        "iSession": "The handle to a filtered list previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryDeleteAll.html"
    },
    "almsummarydisable": {
      "name": "AlmSummaryDisable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT EndTime [",
        "STRING Comment]]"
      ],
      "doc": "The AlmSummaryDisable function disables the alarm at the current cursor position in an active data browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "INT AlmSummaryDisable(INT iSession [, INT EndTime [, STRING Comment]] )",
        "EndTime": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
        "Comment": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed."
      },
      "helpPath": "AlmSummaryDisable.html"
    },
    "almsummaryenable": {
      "name": "AlmSummaryEnable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT bAcknowledge]"
      ],
      "doc": "The AlmSummaryEnable function enables the alarm at the current cursor position in an active data browse session.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "0": "(default) enforced acknowledgment will not be applied.",
        "1": "alarm will be acknowledged when enabled.",
        "iSession": "INT AlmSummaryEnable(INT iSession [, INT bAcknowledge])",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlmSummaryEnable.html"
    },
    "almsummaryfirst": {
      "name": "AlmSummaryFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG iSession": "INT AlmSummaryFirst(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryFirst.html"
    },
    "almsummarygetfield": {
      "name": "AlmSummaryGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession",
        "STRING sFieldName"
      ],
      "doc": "The AlmSummaryGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG iSession, STRING sFieldName": "STRING AlmSummaryGetField(LONG iSession, STRING sFieldName)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
        "sFieldName": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "AlmSummaryGetField.html"
    },
    "almsummarylast": {
      "name": "AlmSummaryLast",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryLast function places the data browse cursor at the most recent summary record from the last cluster of the available browsing cluster list.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG iSession": "INT AlmSummaryLast(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryLast.html"
    },
    "almsummarynext": {
      "name": "AlmSummaryNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG iSession": "INT AlmSummaryNext(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryNext.html"
    },
    "almsummarynumrecords": {
      "name": "AlmSummaryNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG iSession"
      ],
      "doc": "The AlmSummaryNumRecords function retrieves the number of records in an alarm summary browse session.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "LONG": "LONG AlmSummaryNumRecords(LONG iSession)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryNumRecords.html"
    },
    "almsummaryopen": {
      "name": "AlmSummaryOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters [",
        "INT RowLimit",
        "[",
        "INT AutoCloseMode]]]"
      ],
      "doc": "The AlmSummaryOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "Returns an integer handle to the browse session. Returns -1 on error.",
      "paramDocs": {
        "STRING Filter, STRING Fields [, STRING Clusters [, INT RowLimit, [,INT AutoCloseMode]]]": "LONG AlmSummaryOpen(STRING Filter, STRING Fields [, STRING Clusters [, INT RowLimit, [,INT AutoCloseMode]]])",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned. Where a fieldname is not specified in the filter, it is assumed to be tagname. For example, the filter \"AAA\" is equivalent to \"TAG=AAA\".",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed.",
        "RowLimit": "The default value of iRowLimit is -1. This will cause the browse session to use the default global maximum row limit (configured by the INI parameter [Alarm]BrowseRowLimit), or the default value of the INI parameter if not specified.",
        "AutoCloseMode": "AutoCloseMode"
      },
      "helpPath": "AlmSummaryOpen.html"
    },
    "almsummaryprev": {
      "name": "AlmSummaryPrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The AlmSummaryPrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT AlmSummaryPrev(LONG Session)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call."
      },
      "helpPath": "AlmSummaryPrev.html"
    },
    "almsummarysetfieldvalue": {
      "name": "AlmSummarySetFieldValue",
      "returnType": "UNKNOWN",
      "params": [
        "iSession",
        "sFieldname",
        "sFieldValue"
      ],
      "doc": "The AlmSummarySetFieldValue function sets a new value for the specified field for the record the data browse cursor is currently referencing. The value is not committed until a call to AlmSummaryCommit is made.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "iSession, sFieldname, sFieldValue": "AlmSummarySetFieldValue(iSession, sFieldname, sFieldValue)",
        "iSession": "The handle to a browse session previously returned by a AlmSummaryOpen call.",
        "sFieldName": "The name of the field whose value is to be updated. Supported fields are:",
        "sFieldValue": "The field value to update."
      },
      "helpPath": "AlmSummarySetFieldValue.html"
    },
    "almtagsack": {
      "name": "AlmTagsAck",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseAck instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsAck(iSession)"
      },
      "helpPath": "AlmTagsAck.html"
    },
    "almtagsclear": {
      "name": "AlmTagsClear",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use the AlmBrowseClear function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsClear(iSession)"
      },
      "helpPath": "AlmTagsClear.html"
    },
    "almtagsclose": {
      "name": "AlmTagsClose",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseClose function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsClose(iSession)"
      },
      "helpPath": "AlmTagsClose.html"
    },
    "almtagsdisable": {
      "name": "AlmTagsDisable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT EndTime [",
        "STRING Comment]]"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseDisable function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsDisable(INT iSession [, INT EndTime [, STRING Comment]] )",
        "EndTime": "A date/time variable that indicates when the alarm will no longer be disabled. If this parameter is omitted or set to 0, the alarm will be disabled indefinitely.",
        "Comment": "An optional comment limited to 200 characters explaining why the alarm is disabled. If the comment exceeds 200 characters, hardware error 274 (\"Invalid argument passed\") will be displayed."
      },
      "helpPath": "AlmTagsDisable.html"
    },
    "almtagsenable": {
      "name": "AlmTagsEnable",
      "returnType": "UNKNOWN",
      "params": [
        "INT iSession [",
        "INT bAcknowledge]"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseEnable function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "0": "(default) enforced acknowledgment will not be applied.",
        "1": "alarm will be acknowledged when enabled.",
        "iSession": "AlmTagsEnable(INT iSession [, INT bAcknowledge])",
        "bAcknowledge": "Forces acknowledgment of an alarm after it is enabled. The accepted values are:"
      },
      "helpPath": "AlmTagsEnable.html"
    },
    "almtagsfirst": {
      "name": "AlmTagsFirst",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseFirst function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsFirst(iSession)"
      },
      "helpPath": "AlmTagsFirst.html"
    },
    "almtagsgetfield": {
      "name": "AlmTagsGetField",
      "returnType": "UNKNOWN",
      "params": [
        "iSession",
        "sFieldName"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseGetField function instead.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "iSession, sFieldName": "AlmTagsGetField(iSession, sFieldName)",
        "iSession": "The handle to a browse session previously returned by a AlmTagsOpen call.",
        "sFieldName": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "AlmTagsGetField.html"
    },
    "almtagsnext": {
      "name": "AlmTagsNext",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseNext function instead.",
      "returns": "0 (zero) if the browse has successfully been moved to the next record, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsNext(iSession)"
      },
      "helpPath": "AlmTagsNext.html"
    },
    "almtagsnumrecords": {
      "name": "AlmTagsNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseNumRecords function instead.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "iSession": "AlmTagsNumRecords(iSession)"
      },
      "helpPath": "AlmTagsNumRecords.html"
    },
    "almtagsopen": {
      "name": "AlmTagsOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sFilter",
        "sFields [",
        "sClusters]"
      ],
      "doc": "This command is now deprecated. Use AlmBrowseOpen function instead.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "sFilter, sFields [, sClusters]": "AlmTagsOpen( sFilter, sFields [, sClusters] )",
        "sFilter": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned. Where a fieldname is not specified in the filter, it is assumed to be tagname. For example, the filter \"AAA\" is equivalent to \"Tag=AAA\".",
        "sFields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "sClusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed."
      },
      "helpPath": "AlmTagsOpen.html"
    },
    "almtagsprev": {
      "name": "AlmTagsPrev",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "This command is now deprecated. Use AlmBrowsePrev function instead.",
      "returns": "0 (zero) if the alarm browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "AlmTagsPrev(iSession)"
      },
      "helpPath": "AlmTagsPrev.html"
    },
    "anbyname": {
      "name": "AnByName",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Retrieves the animation point number of an ActiveX object.",
      "returns": "The animation point number of the object - if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName": "AnByName(sName)"
      },
      "helpPath": "AnByName.html"
    },
    "arccos": {
      "name": "ArcCos",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the arccosine of an angle.",
      "returns": "The arccosine (the angle, in radians) of Number.",
      "paramDocs": {
        "Number": "ArcCos(Number)"
      },
      "helpPath": "ArcCos.html"
    },
    "arcsin": {
      "name": "ArcSin",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the arcsine of an angle.",
      "returns": "The arcsine (the angle, in radians) of Number.",
      "paramDocs": {
        "Number": "ArcSin(Number)"
      },
      "helpPath": "ArcSin.html"
    },
    "arctan": {
      "name": "ArcTan",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the arctangent of an angle.",
      "returns": "The arctangent (the angle, in radians) of Number.",
      "paramDocs": {
        "Number": "ArcTan(Number)"
      },
      "helpPath": "ArcTan.html"
    },
    "areacheck": {
      "name": "AreaCheck",
      "returnType": "UNKNOWN",
      "params": [
        "Area"
      ],
      "doc": "Determines whether the current user has access to a specified area.",
      "returns": "TRUE (1) if the user has access to the Area or FALSE (0) if not.",
      "paramDocs": {
        "Area": "AreaCheck(Area)"
      },
      "helpPath": "AreaCheck.html"
    },
    "arraycopy": {
      "name": "ArrayCopy",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The handle of the created copy. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "hArray": "INT ArrayCopy(INT hArray)"
      },
      "helpPath": "ArrayCopy.html"
    },
    "arraycreate": {
      "name": "ArrayCreate",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sArrayName",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The handle of the array. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "sArrayName": "INT ArrayCreate(STRING sArrayName, INT x [, INT y [, INT z]])",
        "x": "The size of the array's xdimension (from 1 to 32765).",
        "y": "The size of the array's ydimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1.",
        "z": "The size of the array's zdimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1."
      },
      "helpPath": "ArrayCreate.html"
    },
    "arraycreatebyan": {
      "name": "ArrayCreateByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The handle of the array. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTArrayCreateByAn(INT nAN, INT x [, INT y [, INT z]])",
        "hAN": "The AN number to associate with the array.",
        "x": "The size of the array's xdimension (from 1 to 32765).",
        "y": "The size of the array's ydimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1.",
        "z": "The size of the array's zdimension (from 1 to 32765). This value is optional. If not specified, it defaults to 1."
      },
      "helpPath": "ArrayCreateByAn.html"
    },
    "arraydestroy": {
      "name": "ArrayDestroy",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hArray": "INTArrayDestroy(INT hArray)"
      },
      "helpPath": "ArrayDestroy.html"
    },
    "arraydestroybyan": {
      "name": "ArrayDestroyByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "INTArrayDestroyByAn(INT nAN)"
      },
      "helpPath": "ArrayDestroyByAn.html"
    },
    "arrayexists": {
      "name": "ArrayExists",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "TRUE if the array exists. FALSE if the array does not exist.",
      "paramDocs": {
        "hArray": "INT ArrayExists(INT hArray)"
      },
      "helpPath": "ArrayExists.html"
    },
    "arrayexistsbyan": {
      "name": "ArrayExistsByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "TRUE if the array exists. FALSE if the array does not exist.",
      "paramDocs": {
        "nAN": "INT ArrayExistsByAn(INT nAN)"
      },
      "helpPath": "ArrayExistsByAn.html"
    },
    "arrayfillfromalarmdatabyan": {
      "name": "ArrayFillFromAlarmDataByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT hAN"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hAN": "INT ArrayFillFromAlarmDataByAn(INT hAN)"
      },
      "helpPath": "ArrayFillFromAlarmDataByAn.html"
    },
    "arraygetarraybyan": {
      "name": "ArrayGetArrayByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The handle of the array. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INT ArrayGetArrayByAn(INT nAN)"
      },
      "helpPath": "ArrayGetArrayByAn.html"
    },
    "arraygetinfo": {
      "name": "ArrayGetInfo",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "INT nType"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The size of the x, y, or zdimension, if successful. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "hArray": "INT ArrayGetInfo(INT hArray, INT nType)",
        "nType": "0 = the array's xdimension"
      },
      "helpPath": "ArrayGetInfo.html"
    },
    "arraygetint": {
      "name": "ArrayGetInt",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The requested integer, if successful. If unsuccessful, the error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "hArray": "INT ArrayGetInt(INT hArray, INT x [, INT y [, INT z]])",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArrayGetInt.html"
    },
    "arraygetintbyan": {
      "name": "ArrayGetIntByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The requested integer, if successful. If unsuccessful, 1 is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INT ArrayGetIntByAn(INT nAN, INT x [, INT y [, INT z]])",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArrayGetIntByAn.html"
    },
    "arraygetmapname": {
      "name": "ArrayGetMapName",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray"
      ],
      "doc": "Retrieves the name of the map associated with an array.",
      "returns": "If successful, the requested map name as a string. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "hArray": "STRING ArrayGetMapName(INT hArray)"
      },
      "helpPath": "ArrayGetMapName.html"
    },
    "arraygetmapnamebyan": {
      "name": "ArrayGetMapNameByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Retrieves the name of the map for an array associated with a specified AN.",
      "returns": "If successful, the requested map name as a string. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "STRING ArrayGetMapNameByAn(INT nAN)"
      },
      "helpPath": "ArrayGetMapNameByAn.html"
    },
    "arraygetstring": {
      "name": "ArrayGetString",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The requested string, if successful. If unsuccessful, \" \" is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "hArray": "STRING ArrayGetString(INT hArray, INT x [, INT y [, INT z]])",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArrayGetString.html"
    },
    "arraygetstringbyan": {
      "name": "ArrayGetStringByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "The requested string, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "STRING ArrayGetStringByAn(INT nAN, INT x [, INT y [, INT z]])",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArrayGetStringByAn.html"
    },
    "arrayisdirty": {
      "name": "ArrayIsDirty",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "1 if true (is dirty), or 0 if false (is not dirty). An error is not returned by this function.",
      "paramDocs": {
        "hArray": "INT ArrayIsDirty(INT hArray)"
      },
      "helpPath": "ArrayIsDirty.html"
    },
    "arraysetint": {
      "name": "ArraySetInt",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "INT nValue",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
      "paramDocs": {
        "hArray": "INTArraySetInt(INT hArray, INT nValue, INT x [, INT y [, INT z]])",
        "nValue": "The value you would like to set.",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArraySetInt.html"
    },
    "arraysetintbyan": {
      "name": "ArraySetIntByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT nValue",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "INTArraySetIntByAn(INT nAN, INT nValue, INT x [, INT y [, INT z]])",
        "nValue": "The value you would like to set.",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArraySetIntByAn.html"
    },
    "arraysetisdirty": {
      "name": "ArraySetIsDirty",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "INT IsDirty"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
      "paramDocs": {
        "hArray": "ArraySetIsDirty(INT hArray, INT IsDirty)",
        "IsDirty": "0= False"
      },
      "helpPath": "ArraySetIsDirty.html"
    },
    "arraysetstring": {
      "name": "ArraySetString",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray",
        "STRING sValue",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
      "paramDocs": {
        "hArray": "INTArraySetString(INT hArray, STRING sValue, INT x [, INT y [, INT z]])",
        "sValue": "The string value you would like to set.",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArraySetString.html"
    },
    "arraysetstringbyan": {
      "name": "ArraySetStringByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "STRING sValue",
        "INT x [",
        "INT y [",
        "INT z]]"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "INTArraySetStringByAn(INT nAN, STRING sValue, INT x [, INT y [, INT z]])",
        "sValue": "The string value you would like to set.",
        "x": "The index for the xdimension.",
        "y": "The index for the ydimension.",
        "z": "The index for the zdimension."
      },
      "helpPath": "ArraySetStringByAn.html"
    },
    "arrayswap": {
      "name": "ArraySwap",
      "returnType": "UNKNOWN",
      "params": [
        "INT hArray1",
        "INT hArray2"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "If unsuccessful, an error code will be returned by the IsError Cicode function.",
      "paramDocs": {
        "hArray1": "INT ArraySwap(INT hArray1, INT hArray2)",
        "hArray2": "The handle of the array that you would like to swap with hArray1."
      },
      "helpPath": "ArraySwap.html"
    },
    "ass": {
      "name": "Ass",
      "returnType": "UNKNOWN",
      "params": [
        "hWin",
        "nArg",
        "sTag",
        "nMode [",
        "sClusterName]"
      ],
      "doc": "Associates a variable tag or equipment with a Super Genie.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 or 289 may be returned even though the association is successful, and can be ignored.",
      "paramDocs": {
        "hWin": "Ass(hWin, nArg, sTag, nMode [, sClusterName] )",
        "nArg": "The argument number or name (substitution string number or name) of the Super Genie string to be replaced by sTag. For example, to replace ?INT 3? with sTag, set nArg to 3 ,or ?Level? set nArg to Level.",
        "sTag": "Variable tag, or equipment and item name reference of a variable tag (using equipment.item notation) that will replace the Super Genie association. Partial tag names or equipment.item tag references can also be used.",
        "nMode": "The mode of the association. Set to 0.",
        "sClusterName": "Specifies the name of the cluster in which the Variable Tag resides. This is optional if you have one cluster or are resolving the tag via the page's current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "Ass.html"
    },
    "asschain": {
      "name": "AssChain",
      "returnType": "UNKNOWN",
      "params": [
        "hDest",
        "hSource",
        "nMode"
      ],
      "doc": "Chains the associations from the current Super Genie to a new Super Genie. Use this function to display a new Super Genie when you already have one displayed. The new Super Genie will inherit the associations of the first Super Genie.",
      "returns": "Returns the number of associations copied.",
      "paramDocs": {
        "hDest": "AssChain(hDest, hSource, nMode)",
        "hSource": "The number of the window containing the source Super Genie (that is the Super Genie from which the associations will be inherited).",
        "nMode": "The mode of the association. Set to 0."
      },
      "helpPath": "AssChain.html"
    },
    "asschainpage": {
      "name": "AssChainPage",
      "returnType": "UNKNOWN",
      "params": [
        "sPage"
      ],
      "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie (in the current window).",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPage": "AssChainPage(sPage)"
      },
      "helpPath": "AssChainPage.html"
    },
    "asschainpopup": {
      "name": "AssChainPopUp",
      "returnType": "UNKNOWN",
      "params": [
        "sPage"
      ],
      "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie in a new popup window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPage": "AssChainPopUp(sPage)"
      },
      "helpPath": "AssChainPopUp.html"
    },
    "asschainwin": {
      "name": "AssChainWin",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "X",
        "Y",
        "Mode"
      ],
      "doc": "Chains the associations from the current Super Genie to a new Super Genie, and displays the new Super Genie in a new window. The new window will be of the same type as the current window. Use this function to display a new Super Genie in a new window when a Super Genie is already displayed. The new Super Genie will inherit the associations of the first.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal page.",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode helps to prevent this window from being opened more then once.",
        "256": "Display the entire window. This mode helps to ensure that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode helps to prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "sPage": "AssChainWin(sPage, X, Y, Mode)",
        "Mode": "The mode of the window:"
      },
      "helpPath": "AssChainWin.html"
    },
    "asschainwinfree": {
      "name": "AssChainWinFree",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "X",
        "Y",
        "Mode"
      ],
      "doc": "Stores the associations on an existing Super Genie, closes it, then assigns the tags to a new window. This allows a Super Genie popup window to call another popup window, and close the parent popup.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal page.",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode helps to prevent this window from being opened more then once.",
        "256": "Display the entire window. This mode helps to ensure that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode helps to prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "sPage": "AssChainWinFree(sPage, X, Y, Mode)",
        "X": "the x pixel coordinate of the top-left corner of the window.",
        "Y": "the y pixel coordinate of the top-left corner of the window.",
        "Mode": "The mode of the window:"
      },
      "helpPath": "AssChainWinFree.html"
    },
    "assequipparameters": {
      "name": "AssEquipParameters",
      "returnType": "UNKNOWN",
      "params": [
        "hWin",
        "sClusterName",
        "sEquipmentName"
      ],
      "doc": "Associates a set of equipment parameters defined in Plant SCADA Studio's System Model | Equipment | Runtime Parameters with a page. This association is only made for the next page you display (either in the current window or in a new window). You cannot create an association for a page that is already displayed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 or 289 may be returned even though the association is successful, and can be ignored.",
      "paramDocs": {
        "hWin": "AssEquipParameters(hWin, sClusterName, sEquipmentName )",
        "sClusterName": "Specifies the name of the cluster in which the equipment resides. The cluster name is optional if you have one cluster or are resolving the tag via the page's current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AssEquipParameters.htm"
    },
    "assequipreferences": {
      "name": "AssEquipReferences",
      "returnType": "UNKNOWN",
      "params": [
        "INT hwin",
        "STRING sClusterAndEquipment",
        "STRING sCategory"
      ],
      "doc": "Creates Super Genie associations for each equipment referenced by the specified equipment.",
      "paramDocs": {
        "INT hwin, STRING sClusterAndEquipment, STRING sCategory": "AssEquipReferences (INT hwin, STRING sClusterAndEquipment, STRING sCategory)",
        "hWin": "The association will be created for the next Super Genie to display in the window specified here; enter the window number or:",
        "sClusterAndEquipment": "sClusterAndEquipment",
        "sCategory": "sCategory"
      },
      "helpPath": "AssEquipReferences.html"
    },
    "assert": {
      "name": "Assert",
      "returnType": "UNKNOWN",
      "params": [
        "bCondition"
      ],
      "doc": "Verifies that the specified expression is TRUE. If then expression is FALSE, the current task will be halted. This is useful to help prevent the execution of code you do not want to run in the event an error has been detected.",
      "returns": "None. However, if the assertion tests as FALSE, error 347 is generated.",
      "paramDocs": {
        "bCondition": "Assert(bCondition)"
      },
      "helpPath": "Assert.html"
    },
    "assgetproperty": {
      "name": "AssGetProperty",
      "returnType": "STRING",
      "params": [
        "sArg",
        "sProperty [",
        "iCachedMode]"
      ],
      "doc": "This function gets association information about the current Super Genie from the data source (that is, information about a variable tag that has been substituted into the Super Genie).",
      "returns": "String representation of the property of the referenced tag. On detection of an error, an empty string and an error are set.",
      "paramDocs": {
        "TagName": "If a constant value is associated, then only the constant value can be retrieved through the TagName property. The remaining properties are not valid.",
        "sArg, sProperty [, iCachedMode]": "AssGetProperty(sArg, sProperty [, iCachedMode] )",
        "sArg": "The argument number or name (integer or string) of the association from which to get information.",
        "sProperty": "The property to read. Property names are case sensitive. Supported properties are:",
        "Address": "The configured address of the referenced tag (as specified in the Variable Tags properties).",
        "ArraySize": "Array size of the referenced tag. Returns 1 for non-array types.",
        "AssFullName": "Full name of the referenced tag in the form cluster.tagname even if the tag is not resolved.",
        "ClusterName": "Name of the cluster the referenced tag resides on.",
        "DataBitWidth": "Number of bits used to store the value.",
        "Description": "Description of the referenced tag.",
        "EngUnitsHigh": "Maximum scaled value.",
        "EngUnitsLow": "Minimum scaled value.",
        "Equipment": "Name of the equipment.",
        "Format": "Format bit string. The format information is stored in the integer as follows:",
        "ErrorValUsed": "Returns 1 if the defined error value was used for the SuperGenie association. This means that tag name is invalid/unresolved or the substitutions are not complete. This is only relevant for named Super Genies. Returns zero (0) if the association string provided a value, or a default value was not defined.",
        "FormatDecPlaces": "Number of decimal places for default format.",
        "FormatWidth": "Number of characters used in default format.",
        "FullName": "Full name of the referenced tag in the form cluster.tagname If the referenced tag is not resolved, returns an empty string.",
        "Item": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "Literal": "Returns 1 if the substitution is a literal value, returns 0 if the substitution is a tag name.",
        "RangeHigh": "Maximum unscaled value.",
        "RangeLow": "Minimum unscaled value.",
        "Type": "General type of associated tag. Allowed values are:",
        "Units": "Engineering Units for example, %, mm, Volts.",
        "Custom1 ... Custom8": "User-defined strings.",
        "iCachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "AssGetProperty.html"
    },
    "assgetscale": {
      "name": "AssGetScale",
      "returnType": "UNKNOWN",
      "params": [
        "sArg",
        "iPercent",
        "iEngUnits [",
        "iCached]"
      ],
      "doc": "Gets scale information about the tag references for the current Super Genie from the datasource (that is scale information about a variable tag that has been substituted into the Super Genie).",
      "returns": "The scale of the referenced tag (as a string).",
      "paramDocs": {
        "0": "Return the value without engineering units",
        "1": "Return the value with engineering units",
        "sArg, iPercent, iEngUnits [, iCached]": "AssGetScale(sArg, iPercent, iEngUnits [, iCached] )",
        "sArg": "The argument number or name of the association from which to get information.",
        "iPercent": "The percentage of full scale of the returned value.",
        "iEngUnits": "Flag to determine if the value is returned with engineering units:",
        "iCached": "Optional flag to attempt to retrieve the cached value for the property rather than the current value. This makes the function non-blocking. If the property has not yet been cached, an error is set."
      },
      "helpPath": "AssGetScale.html"
    },
    "assinfo": {
      "name": "AssInfo",
      "returnType": "UNKNOWN",
      "params": [
        "sArg",
        "nType [",
        "iCachedMode]"
      ],
      "doc": "Gets association information about the current Super Genie (that is information about a variable tag that has been substituted into the Super Genie).",
      "returns": "The value of the information as a string.",
      "paramDocs": {
        "0": "Tag reference as defined in sArg. If the referenced tag is not resolved, returns an empty string.",
        "1": "Engineering units",
        "2": "Raw zero scale",
        "3": "Raw full scale",
        "4": "Engineering zero scale",
        "5": "Engineering full scale",
        "6": "Width of the format",
        "7": "Number of decimal places of format",
        "8": "The Tag format as a long integer. The format information is stored in the integer as follows:",
        "9": "Logical Unit Number - I/O device number (for internal use)",
        "10": "Raw Type - Protocol's raw data type number for this tag. Type numbers are:",
        "11": "Bit Width - Tag's size in bits. For example, an INT is 16 bits",
        "12": "Unit Type - Protocol's unit type number for this tag",
        "13": "Unit Address - Tag's address after the protocol DBF's template is applied.",
        "14": "Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.",
        "15": "Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.",
        "16": "Comment - As defined in the variable tags list.",
        "17": "ClusterName of the tag. If the referenced tag is not resolved, returns an empty string.",
        "18": "Full name (cluster.tagname) of the referenced tag. If the tag is not resolved, returns an empty string.",
        "19": "Full name (cluster.tagname) of the referenced tag even if the tag is not resolved.",
        "20": "Configured Address of the tag. If the tag is not resolved, returns an empty string.",
        "21": "Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).",
        "22": "Name of the equipment associated with the Tag. If the referenced tag is not resolved, returns an empty string.",
        "23": "General Type.",
        "24": "Reserved for internal use.",
        "25": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "27": "Custom 2 - a user-defined string.",
        "28": "Custom 3 - a user-defined string.",
        "29": "Custom 4 - a user-defined string.",
        "30": "Custom 5 - a user-defined string.",
        "31": "Custom 6 - a user-defined string.",
        "32": "Custom 7 - a user-defined string.",
        "33": "Custom 8 - a user-defined string.",
        "sArg": "AssInfo(sArg, nType [, iCachedMode])",
        "nType": "The type of information to get:",
        "iCachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "AssInfo.html"
    },
    "assinfoex": {
      "name": "AssInfoEx",
      "returnType": "UNKNOWN",
      "params": [
        "sArg",
        "nType [",
        "iCachedMode]"
      ],
      "doc": "Gets association information about the current Super Genie (that is information about a variable tag that has been substituted into the Super Genie).",
      "returns": "The value of the information as a string. If an error is detected an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "0": "The referenced tag from the variables table. This is the same as sName argument. (Returned to be compatible with the AssInfo() function).",
        "1": "Engineering units",
        "2": "Raw zero scale",
        "3": "Raw full scale",
        "4": "Engineering zero scale",
        "5": "Engineering full scale",
        "6": "Width of the format",
        "7": "Number of decimal places of format",
        "8": "The Tag format as a long integer. The format information is stored in the integer as follows:",
        "9": "Logical Unit Number - I/O device number (for internal use)",
        "10": "Raw Type - Protocol's raw data type number for this tag. Type numbers are:",
        "11": "Bit Width - Tag's size in bits. For example, an INT is 16 bits",
        "12": "Unit Type - Protocol's unit type number for this tag",
        "13": "Unit Address - Tag's address after the protocol DBF's template is applied.",
        "14": "Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.",
        "15": "Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.",
        "16": "Comment - As defined in the variable tags list.",
        "17": "ClusterName of the tag.",
        "18": "Full name (cluster.tagname) of the tag.",
        "19": "Full name (cluster.tagname) of the referenced tag even if the tag is not resolved.",
        "20": "Configured Address of the tag. If the tag is not resolved, returns an empty string.",
        "21": "Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).",
        "22": "Name of the equipment associated with the Tag. If the association tag is not resolved, returns an empty string.",
        "23": "General Type.",
        "24": "Reserved for internal use.",
        "25": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "26": "Custom 1 - a user-defined string.",
        "27": "Custom 2 - a user-defined string.",
        "28": "Custom 3 - a user-defined string.",
        "29": "Custom 4 - a user-defined string.",
        "30": "Custom 5 - a user-defined string.",
        "31": "Custom 6 - a user-defined string.",
        "32": "Custom 7 - a user-defined string.",
        "33": "Custom 8 - a user-defined string.",
        "sArg": "AssInfoEx(sArg, nType [, iCachedMode] )",
        "nType": "The type of information to get:",
        "iCachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "AssInfoEx.html"
    },
    "assmetadata": {
      "name": "AssMetadata",
      "returnType": "UNKNOWN",
      "params": [
        "hWin [",
        "nAn]"
      ],
      "doc": "This non-blocking function performs Super Genie associations using the \"Name\" and \"Value\" fields defined on the Object Properties - Metadata tab, and matches it to the 'Name' field in the page associations table.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274 may be returned even though the association is successful, and can be ignored.",
      "paramDocs": {
        "hWin": "AssMetadata(hWin [, nAn])",
        "nAN": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value.When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations."
      },
      "helpPath": "AssMetadata.html"
    },
    "assmetadatapage": {
      "name": "AssMetadataPage",
      "returnType": "UNKNOWN",
      "params": [
        "sPage [",
        "nAN]"
      ],
      "doc": "Uses the metadata information from the current object for the page associations for a new Super Genie page, and displays the new Super Genie (in the current page).",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPage": "AssMetadataPage(sPage [,nAN])",
        "nAN": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value. When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations."
      },
      "helpPath": "AssMetadataPage.html"
    },
    "assmetadatapopup": {
      "name": "AssMetadataPopUp",
      "returnType": "UNKNOWN",
      "params": [
        "sPage [",
        "nAN]"
      ],
      "doc": "Uses the metadata information from the current animation point for the associations for a new Super Genie page, and displays the new Super Genie in a pop up window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPage": "AssMetadataPopUp(sPage [,nAN])",
        "nAN": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations.This parameter is optional with -2 being the default value. When -2 is specified, it is equivalent to DspGetAnCur() which returns the animation number of the current active command cursor, please refer DspGetAnCur() for usage and limitations."
      },
      "helpPath": "AssMetadataPopUp.html"
    },
    "assmetadatawin": {
      "name": "AssMetadataWin",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "INT x",
        "INT y",
        "INT mode [",
        "nAN]"
      ],
      "doc": "Uses the metadata information from the current animation-point for the associations for a new Super Genie page, and displays the new Super Genie in a new window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal page (default value).",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode stops this window from being opened more then once.",
        "256": "Display the entire window. This mode commands that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode stops a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "4096": "Allows the window to be resized without maintaining the current aspect ratio. The aspect ratio defines the relationship between the width and the height of the window, which means this setting allows you to stretch or compress the window to any proportions. This option overrides the setting of the [Page]MaintainAspectRatio parameter.",
        "8192": "Text on a page will be resized in proportion with the maximum scale change for a resized window. For example, consider a page that is resized to three times the original width, and half the original height. If this mode is set, the font size of the text on the page will be tripled (in proportion with the maximum scale). This option overrides the setting of the [Page] ScaleTextToMax parameter.",
        "16384": "Hide the horizontal scroll bar.",
        "32768": "Hide the vertical scroll bar.",
        "65536": "Disable horizontal scrolling.",
        "131072": "Disable vertical scrolling.",
        "sPage, INT x, INT y, INT mode": "AssMetadataWin(sPage, INT x, INT y, INT mode [,nAN])",
        "sPage": "The name of the Super Genie page to open.",
        "X": "The x pixel coordinate of the top left corner of the window. Default value is 0.",
        "Y": "The y pixel coordinate of the top left corner of the window. Default value is 0.",
        "Mode": "The mode of the window:"
      },
      "helpPath": "AssMetadataWin.html"
    },
    "asspage": {
      "name": "AssPage",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sTag1",
        "[sTag2..8]"
      ],
      "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in the current window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTag1": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in the current window. Partial tag names and equipment.item tag references can also be used. The first variable tag (sTag1) replaces Super Genie substitution string 1. The second variable tag (sTag2) replaces substitution string 2, and so on.",
        "sPage": "AssPage(sPage, sTag1, [sTag2..8] )",
        "sTag1..sTag8": "The first eight physical tags to be associated with the Super Genie. For any given Super Genie, the variable tags will replace the Super Genie substitution strings as follows:"
      },
      "helpPath": "AssPage.html"
    },
    "asspopup": {
      "name": "AssPopUp",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sTag1",
        "[sTag2..8]"
      ],
      "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in a popup window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTag1": "Associates up to eight variable tags or equipment.item tag references with a Super Genie and displays the Super Genie in a popup window. Partial tag names or equipment.item tag references can also be used. The first variable tag (sTag1) replaces Super Genie substitution string 1. The second variable tag (sTag2) replaces substitution string 2, and so on.",
        "sPage": "AssPopUp(sPage, sTag1, [sTag2..8] )",
        "sTag1..sTag8": "The first 8 physical tags to be associated with the Super Genie. For any given Super Genie, the variable tags will replace the Super Genie substitution strings as follows:"
      },
      "helpPath": "AssPopUp.html"
    },
    "assscalestr": {
      "name": "AssScaleStr",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Arg",
        "INT Percent",
        "INT EngUnits[",
        "INT CachedMode]"
      ],
      "doc": "Gets scale information about the associations of the current Super Genie (that is scale information about a variable tag that has been substituted into the Super Genie).",
      "returns": "The scale of the referenced tag(as a string).",
      "paramDocs": {
        "0": "Do not return the value with engineering units",
        "1": "Return the value with engineering units",
        "STRING Arg": "STRING AssScaleStr(STRING Arg, INT Percent, INT EngUnits[,INT CachedMode])",
        "sArg": "When you associate variable tags with Super Genies, the Super Genie substitution strings are replaced by variable tags. The nArg argument allows you to get scale information about a particular variable tag. You need to know which substitution string the tag replaced when the association was performed.",
        "Percent": "The percentage of full scale of the returned value.",
        "EngUnits": "Determines if the value is returned with engineering units:"
      },
      "helpPath": "AssScaleStr.html"
    },
    "asstag": {
      "name": "AssTag",
      "returnType": "UNKNOWN",
      "params": [
        "nArg",
        "sTag [",
        "sClusterName]"
      ],
      "doc": "Associates a variable tag or equipment.item tag reference with a Super Genie.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.When using partial associations, an error 274, or 289 may be returned even though the association is successful, and can be ignored.",
      "paramDocs": {
        "nArg": "AssTag(nArg, sTag [, sClusterName] )",
        "sTag": "The variable tag or equipment.item tag reference that will replace the Super Genie substitution string.Partial tag names or equipment.item tag references can also be used.",
        "sClusterName": "Specifies the name of the cluster in which the Variable Tag resides. This is optional if you have one cluster or are resolving the tag via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "AssTag.html"
    },
    "asstitle": {
      "name": "AssTitle",
      "returnType": "UNKNOWN",
      "params": [
        "[Mask] [",
        "Prefix] [",
        "Suffix]"
      ],
      "doc": "Sets the runtime window title to the tag name of the first variable substituted into the Super Genie.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "[Mask]": "AssTitle( [Mask] [, Prefix] [, Suffix])",
        "Mask": "The number of characters to mask (hide) from the right of the title string (optional).",
        "Prefix": "A string to add to the beginning of the title string (optional).",
        "Suffix": "A string to add to the end of the title string (optional)."
      },
      "helpPath": "AssTitle.html"
    },
    "assvartags": {
      "name": "AssVarTags",
      "returnType": "UNKNOWN",
      "params": [
        "hWin",
        "nOffset",
        "sTag1",
        "[sTag2..8]"
      ],
      "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie.",
      "returns": "No value is returned.",
      "paramDocs": {
        "hWin": "AssVarTags(hWin, nOffset, sTag1, [sTag2..8] )",
        "-3": "for the current window when the page is changed. The page can be changed by using the Page Cicode functions like PageDisplay, PageGoto, etc.",
        "-2": "for the next new window or page displayed.",
        "nOffset": "By default, the first variable tag (sTag1) will replace substitution string 1, and sTag2 will replace substitution string 2, and so on. Enter an offset to change this so that sTag1 replaces a substitution string other than the first. For example, an offset of 8 means that sTag1 replaces string 9 instead of the default string 1 (8+1=9), and sTag2 replaces string 10 instead of string 2 (8+2=10) etc. This means that you can use this function repeatedly to associate more than eight variables.",
        "sTag1..8": "The physical variable tags (up to eight) to be associated with the Super Genie. For any given Super Genie, the variable tags will replace the Super Genie substitution strings as follows:"
      },
      "helpPath": "AssVarTags.html"
    },
    "asswin": {
      "name": "AssWin",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "X",
        "Y",
        "Mode",
        "sTag1",
        "[sTag2..8]"
      ],
      "doc": "Associates up to eight variable tags or equipment.item tag references with a Super Genie, and displays the Super Genie in a new window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal page.",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode stops this window from being opened more then once.",
        "256": "Display the entire window. This mode commands that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode stops a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "sPage": "AssWin(sPage, X, Y, Mode, sTag1, [sTag2..8] )",
        "X": "The x pixel coordinate of the top left corner of the window.",
        "Y": "The y pixel coordinate of the top left corner of the window.",
        "Mode": "The mode of the window:",
        "sTag1..8": "The first eight physical tags to be associated with the Super Genie. For any given Super Genie, the variable tags will replace the Super Genie substitution strings as follows:"
      },
      "helpPath": "AssWin.html"
    },
    "asswinreplace": {
      "name": "AssWinReplace",
      "returnType": "UNKNOWN",
      "params": [
        "nTargetWindow"
      ],
      "doc": "Sets the runtime window title to the tag name of the first variable substituted into the Super Genie.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nTargetWindow": "AssWinReplace(nTargetWindow)"
      },
      "helpPath": "AssWinReplace.html"
    },
    "beep": {
      "name": "Beep",
      "returnType": "UNKNOWN",
      "params": [
        "nSound"
      ],
      "doc": "Beeps the internal speaker or sound card (installed in the computer).",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Default beep waveform",
        "1": "Critical stop waveform",
        "2": "Question waveform",
        "3": "Exclamation waveform",
        "4": "Asterisk waveform",
        "nSound": "Beep(nSound)",
        "-1": "Standard beep"
      },
      "helpPath": "Beep.html"
    },
    "callevent": {
      "name": "CallEvent",
      "returnType": "UNKNOWN",
      "params": [
        "Window",
        "nType"
      ],
      "doc": "Simulates an event, triggering any OnEvent() function that has the same Type argument specified.",
      "returns": "0 (zero) if successful, otherwise an error is set. To view the error, use the IsError() function.",
      "paramDocs": {
        "0": "The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.",
        "1": "A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.",
        "2": "Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.",
        "3": "Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.",
        "4": "Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.",
        "5": "Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.",
        "6": "Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.",
        "7": "Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.",
        "8": "Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.",
        "9": "Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.",
        "10": "Page always. This event is called while a page is active. Reserved for use by Plant SCADA.",
        "18": "Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.",
        "19": "Device history. A device history has just completed. The return value must be 0.",
        "20": "Login. A user has just logged in.",
        "21": "Logout. A user has just logged out.",
        "22": "Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)",
        "23": "Hardware error has been detected.",
        "24": "Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().",
        "25": "Network shutdown. A Shutdown network command has been issued.",
        "26": "Runtime system shutdown and restart. (Required because of configuration changes.)",
        "27": "Event. An event has occurred.",
        "28": "Accumulator. An accumulator has logged a value.",
        "29": "Slider. A slider has been selected.",
        "30": "Slider. A slider has moved.",
        "31": "Slider. A slider has been released (that is stopped moving).",
        "32": "Shutdown. Plant SCADA is being shutdown.",
        "33": "Reserved for Plant SCADA internal use.",
        "34": "Plant SCADA Event: Child Window Close Confirmation.",
        "35": "Plant SCADA Event: Main Window Close Confirmation.",
        "36": "Plant SCADA Event: Maximize Window Confirmation.",
        "37": "Plant SCADA Event: Minimize Window Confirmation.",
        "38": "Plant SCADA Event: Restore Window Confirmation.",
        "39": "Plant SCADA Event: Move Window Confirmation.",
        "40": "Plant SCADA Event: Size Window Confirmation.",
        "41": "Plant SCADA Event: Shutdown Confirmation Confirmation.",
        "42": "Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "43": "Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.",
        "44": "Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "45": "Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.",
        "46": "Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "47": "Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.",
        "48": "Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.",
        "49": "Shutdown Confirmation, when shutdown() function is called.",
        "Window": "CallEvent(Window, nType)",
        "Type": "The type of event:",
        "11..17": "Undefined.",
        "34 - 41": "Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler.",
        "42 to 49": "User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.",
        "50 - 127": "Reserved for future Plant SCADA use.",
        "128 - 256": "User-defined events. These events are for your own use."
      },
      "helpPath": "CallEvent.html"
    },
    "chainevent": {
      "name": "ChainEvent",
      "returnType": "UNKNOWN",
      "params": [
        "hFn"
      ],
      "doc": "Calls an event function using the function handle. This creates a chain of event handlers from a single event.",
      "returns": "The return value of the called event function.",
      "paramDocs": {
        "hFn": "ChainEvent(hFn)"
      },
      "helpPath": "ChainEvent.html"
    },
    "chartostr": {
      "name": "CharToStr",
      "returnType": "UNKNOWN",
      "params": [
        "ASCIICode"
      ],
      "doc": "Converts an ASCII code into a string.",
      "returns": "A string containing the converted ASCII code.",
      "paramDocs": {
        "ASCIICode": "CharToStr(ASCIICode)"
      },
      "helpPath": "CharToStr.html"
    },
    "citectinfo": {
      "name": "CitectInfo",
      "returnType": "UNKNOWN",
      "params": [
        "sGroup",
        "sName",
        "sType"
      ],
      "doc": "Gets information about a Plant SCADA variable. This function returns internal statistics and other information about the runtime system.",
      "returns": "The type of information (as an integer).",
      "paramDocs": {
        "0": "= bytes",
        "1": "Plant SCADA Kernel cycles per second",
        "2": "Plant SCADA Kernel tasks per second",
        "3": "= C:",
        "4": "= D: and so on.",
        "5": "Plant SCADA startup time",
        "6": "Plant SCADA running time in seconds",
        "7": "Not supported in v7.10 or later",
        "8": "Total read requests",
        "9": "Total read requests per second",
        "10": "Total write requests",
        "11": "Total write requests per second",
        "12": "Total Physical read requests",
        "13": "Total Physical read requests per second",
        "14": "Total Physical write requests",
        "15": "Total Physical write requests per second",
        "16": "Total Blocked read requests",
        "17": "Total Blocked write requests",
        "18": "Total Digital read requests",
        "19": "Total Register read requests",
        "20": "Total Digital read requests per second",
        "21": "Total Register read requests per second",
        "22": "Total Cache reads count",
        "23": "Total Cache reads %",
        "24": "Overall Average response time (ms)",
        "25": "Overall Minimum response time (ms)",
        "26": "Overall Maximum response time (ms)",
        "27": "Request sample for response times",
        "28": "Static point count is no longer supported. Calling the function with parameter 28 returns a value of 0 and a hardware alarm is raised.",
        "29": "Dynamic point count currently in use",
        "30": "Number of pending read requests from the device",
        "31": "Number of pending write requests to the device",
        "32": "Determines if Plant SCADA Kernel window is open",
        "33": "Percentage of the CPU used by the current Plant SCADA process",
        "34": "Total CPU time spent by the current Plant SCADA process in milliseconds",
        "35": "Total number of handles opened by the current Plant SCADA process",
        "36": "Total number of threads owned by the current Plant SCADA process",
        "sGroup": "CitectInfo(sGroup, sName, sType)",
        "sName": "The name of the variable. This name depends on sGroup:",
        "\"Alarm Proc\"": "Alarm Processing (includes Digital, Analog, Advanced and High Resolution alarms).",
        "\"Citect n\"": "The Plant SCADA window where n is the window number (returned from the WinNumber() function)",
        "\"Code n\"": "The user Cicode task (thread) where n is the task handle (returned from the TaskHnd() function)",
        "\"Reset\"": "Reset the Plant SCADA statistics.",
        "\"ElapsedTimeMS\"": "The elapsed time since statistics have been reset. Returns -1 if more than 20 days has elapsed.",
        "KB": "= kilobytes",
        "MB": "= megabytes",
        "GB": "= gigabytes",
        "sType": "The type of information to get, depending on sGroup:",
        "100 - 119": "Driver specific counter values. Plant SCADA drivers can maintain up to 20 unique counters that can be accessed via this function. They are zero based, indexed from 100 to 119. If a value is not defined or maintained by the driver, 0 is returned for the value of the counter."
      },
      "helpPath": "CitectInfo.html"
    },
    "clipcopy": {
      "name": "ClipCopy",
      "returnType": "UNKNOWN",
      "params": [
        "sText"
      ],
      "doc": "Copies a string to the Windows clipboard. When the string is in the clipboard, you can paste it to any Windows program.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sText": "ClipCopy(sText)"
      },
      "helpPath": "ClipCopy.html"
    },
    "clippaste": {
      "name": "ClipPaste",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Pastes a string from the Windows clipboard.",
      "returns": "The contents of the clipboard (as a string). If the clipboard is empty, an empty string is returned.",
      "paramDocs": {},
      "helpPath": "ClipPaste.html"
    },
    "clipreadln": {
      "name": "ClipReadLn",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Reads a single line of text from the Windows clipboard. With this function, you can read a block of text from the clipboard - line by line.",
      "returns": "One line of text from the clipboard (as a string). If the clipboard is empty, an empty string is returned.",
      "paramDocs": {},
      "helpPath": "ClipReadLn.html"
    },
    "clipsetmode": {
      "name": "ClipSetMode",
      "returnType": "UNKNOWN",
      "params": [
        "nMode"
      ],
      "doc": "Sets the format of data sent to the Windows clipboard.",
      "returns": "The value of the previous mode.",
      "paramDocs": {
        "1": "ASCII Text",
        "2": "CSV (Comma separated values) format",
        "nMode": "ClipSetMode(nMode)"
      },
      "helpPath": "ClipSetMode.html"
    },
    "clipwriteln": {
      "name": "ClipWriteLn",
      "returnType": "UNKNOWN",
      "params": [
        "sText"
      ],
      "doc": "Writes a line of text to the Windows clipboard. With this function, you can write any amount of text to the clipboard.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sText": "ClipWriteLn(sText)"
      },
      "helpPath": "ClipWriteLn.html"
    },
    "clusteractivate": {
      "name": "ClusterActivate",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName"
      ],
      "doc": "This function allows the user to activate an inactive cluster.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "ClusterName": "ClusterActivate(ClusterName)",
        "sClusterName": "The name of the cluster to activate enclosed in quotation marks \"\"."
      },
      "helpPath": "ClusterActivate.html"
    },
    "clusterdeactivate": {
      "name": "ClusterDeactivate",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName"
      ],
      "doc": "This function allows the user to deactivate an active cluster.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "ClusterName": "ClusterDeactivate(ClusterName)",
        "sClusterName": "The name of the cluster to deactivate enclosed in quotation marks \"\"."
      },
      "helpPath": "ClusterDeactivate.html"
    },
    "clusterfirst": {
      "name": "ClusterFirst",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "This function allows the user to retrieve the first configured cluster in the project.",
      "returns": "The name of the first configured cluster.",
      "paramDocs": {},
      "helpPath": "ClusterFirst.html"
    },
    "clustergetname": {
      "name": "ClusterGetName",
      "returnType": "UNKNOWN",
      "params": [
        "sPrimary",
        "sStandby",
        "nMode"
      ],
      "doc": "ClusterGetName is deprecated in this version of Plant SCADA.",
      "returns": "The status of the get name.",
      "paramDocs": {
        "sPrimary": "ClusterGetName(sPrimary, sStandby, nMode)",
        "sStandby": "The name of the cluster's standby server (that is that which was set as sStandby using the ClusterSetName() function). Must be a String type variable.",
        "nMode": "The mode is for future expansion of the function - set to 0 (zero)."
      },
      "helpPath": "ClusterGetName.html"
    },
    "clusterisactive": {
      "name": "ClusterIsActive",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName"
      ],
      "doc": "This function allows the user to determine if a cluster is active.",
      "returns": "TRUE if active, FALSE otherwise. If the cluster name was invalid, this function will return FALSE and a hardware alarm will be generated.",
      "paramDocs": {
        "ClusterName": "ClusterIsActive(ClusterName)",
        "sClusterName": "The name of the cluster to query enclosed in quotation marks \"\"."
      },
      "helpPath": "ClusterIsActive.html"
    },
    "clusternext": {
      "name": "ClusterNext",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName"
      ],
      "doc": "This function allows the user to retrieve the next configured cluster in the project.",
      "returns": "The name of the next configured cluster or an empty string if there is no more clusters.",
      "paramDocs": {
        "ClusterName)": "ClusterNext(ClusterName)",
        "sClusterName": "Any configured cluster name enclosed in quotation marks \"\", this will usually be the name of the previous cluster as returned from ClusterFirst, or a previous call to ClusterNext."
      },
      "helpPath": "ClusterNext.html"
    },
    "clusterservertypes": {
      "name": "ClusterServerTypes",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName"
      ],
      "doc": "This function allows the user to determine which servers are defined for a given cluster.",
      "returns": "Logical OR of the following server flags:",
      "paramDocs": {
        "ClusterName)": "ClusterServerTypes(ClusterName)",
        "sClusterName": "The name of the cluster to query enclosed in quotation marks \"\"."
      },
      "helpPath": "ClusterServerTypes.html"
    },
    "clustersetname": {
      "name": "ClusterSetName",
      "returnType": "UNKNOWN",
      "params": [
        "sPrimary",
        "sStandby",
        "nMode"
      ],
      "doc": "ClusterSetName is deprecated.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "If you select this mode, Plant SCADA will renew the last connection. If it was connected to the sPrimary server, when this function was last used, it will attempt to connect to it again. If it was last connected to the sStandby server, it will attempt to connect to it again.",
        "1": "Plant SCADA will attempt to connect to the sPrimary server first, each time this function is used. If the sPrimary server is unavailable, Plant SCADA will try the sStandby server.",
        "sPrimary": "ClusterSetName(sPrimary, sStandby, nMode)",
        "sStandby": "The name of the cluster's standby server (Reports Server, Alarms Server etc.), as defined using the Computer Setup Wizard. If the sPrimary server is unavailable when the ClusterSetName() function is used, Plant SCADA will attempt to connect to this server.",
        "nMode": "The mode of the connection:"
      },
      "helpPath": "ClusterSetName.html"
    },
    "clusterstatus": {
      "name": "ClusterStatus",
      "returnType": "UNKNOWN",
      "params": [
        "clusterName",
        "serverType"
      ],
      "doc": "This function allows the user to determine the connection status from the client to a server on a cluster.",
      "returns": "One of the following values:",
      "paramDocs": {
        "clusterName, serverType)": "ClusterStatus(clusterName, serverType)",
        "clusterName": "The name of the cluster to query enclosed in quotation marks \"\".",
        "servernType": "The type of server (not a bit mask):"
      },
      "helpPath": "ClusterStatus.html"
    },
    "clusterswapactive": {
      "name": "ClusterSwapActive",
      "returnType": "UNKNOWN",
      "params": [
        "clusterNameA",
        "clusterNameB"
      ],
      "doc": "This function allows the user to deactivate an active cluster at the same time as activating an inactive cluster.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "clusterNameA, clusterNameB": "ClusterSwapActive(clusterNameA, clusterNameB)",
        "clusterNameA": "The name of the cluster to activate or deactivate enclosed in quotation marks \"\".",
        "clusterNameB": "The name of the cluster to activate or deactivate enclosed in quotation marks \"\"."
      },
      "helpPath": "ClusterSwapActive.html"
    },
    "codesetmode": {
      "name": "CodeSetMode",
      "returnType": "UNKNOWN",
      "params": [
        "nType",
        "Value"
      ],
      "doc": "Sets various execution modes for Cicode tasks in the current thread.",
      "returns": "-1 if there is an error, otherwise the last value of the mode.",
      "paramDocs": {
        "0": "Write to a local image of an I/O device. If you set Value to 1, this mode is enabled, and Cicode writes its local memory image of the I/O device whenever you write to the I/O device. (Cicode assumes that most writes to the I/O device will be done immediately).",
        "1": "Check if a variable is within range before writing it to the I/O device. If you set Value to 1, this mode is enabled. When a variable tag is modified, Cicode checks the new value of the variable against the Scales specified in the Variable Tags database. If the value of the variable is out of scale, Cicode generates a hardware error, and does not write to the I/O device.",
        "2": "Echo error messages to the operator. If you set Value to 1, this mode is enabled. When a simple user error occurs (for example, if the PageDisplay() function is passed a bad page name), Cicode displays an error message at the Error AN, and returns an error code from the function.",
        "3": "Ignore the case of string data in the current thread of Cicode. If you set Value to 1, this mode is enabled, and Plant SCADA will ignore case in string data. For example, Plant SCADA will equate \"Hello\" to \"HELLO\".",
        "4": "Calls the Cicode Profiler. If you set Value to 1, the Profiler is enabled. This will only enable\\disable the Profiler for the current Cicode task.",
        "nType": "CodeSetMode(nType, Value)",
        "Value": "The value of the mode:"
      },
      "helpPath": "CodeSetMode.html"
    },
    "codetrace": {
      "name": "CodeTrace",
      "returnType": "UNKNOWN",
      "params": [
        "hTask",
        "nMode"
      ],
      "doc": "Traces Cicode into the Kernel and the SYSLOG.DAT file. Use this function for finding bugs in your Cicode.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Foreground Cicode.",
        "1": "Trace user Cicode functions calls",
        "2": "Trace built-in function calls",
        "4": "Trace errors",
        "8": "Trace writes to the I/O devices",
        "16": "Trace task state changes",
        "hTask": "CodeTrace(hTask, nMode)",
        "-2": "The next created task.",
        "-3": "New created tasks.",
        "-4": "All tasks.",
        "nMode": "The mode of the trace:",
        "-1": "All modes (except 0)"
      },
      "helpPath": "CodeTrace.html"
    },
    "comclose": {
      "name": "ComClose",
      "returnType": "UNKNOWN",
      "params": [
        "hPort"
      ],
      "doc": "Closes a communication port.",
      "returns": "0 if the port is successfully closed, or an error if the port is already closed or if the port number is invalid.",
      "paramDocs": {
        "hPort": "ComClose(hPort)"
      },
      "helpPath": "ComClose.html"
    },
    "comopen": {
      "name": "ComOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sPort",
        "nMode"
      ],
      "doc": "Opens a communication port for access.",
      "returns": "A communication port handle if the communication system is opened successfully, otherwise -1 is returned. The handle identifies the table where all data on the associated port is stored. You can use the handle in the other communication functions, to send and receive characters from the port.",
      "paramDocs": {
        "0": "Take control of the port from Plant SCADA. In this non-shared mode, you have complete access to the port - Plant SCADA cannot use the port. Communication will be restored when the port is closed.",
        "1": "Share the port with Plant SCADA. In this mode, you can write to the port, and Plant SCADA can also use it. Please be aware that ComRead will be unreliable if the communication port is opened as shared.",
        "sPort": "ComOpen(sPort, nMode)",
        "nMode": "The mode of the open:"
      },
      "helpPath": "ComOpen.html"
    },
    "comread": {
      "name": "ComRead",
      "returnType": "UNKNOWN",
      "params": [
        "hPort",
        "sBuffer",
        "iLength",
        "iTimeOut"
      ],
      "doc": "Reads characters from a communication port.",
      "returns": "0 (zero) if the read is successful, otherwise an error code is returned.",
      "paramDocs": {
        "hPort": "ComRead(hPort, sBuffer, iLength, iTimeOut)",
        "sBuffer": "The buffer into which to put the characters. The actual number of characters read is returned in iLength. Must be a String type variable.",
        "iLength": "The number of characters to read into the buffer. The maximum length you may read in one call is 128 characters. When the function returns, this variable is set to the actual number of characters read. Must be a Long type variable.",
        "iTimeOut": "The timeout for the read to complete:"
      },
      "helpPath": "ComRead.html"
    },
    "comreset": {
      "name": "ComReset",
      "returnType": "UNKNOWN",
      "params": [
        "hPort"
      ],
      "doc": "Resets the communication port. This function can only be called from an I/O Server.",
      "returns": "0 (zero) if the write is successful, otherwise an error code is returned.",
      "paramDocs": {
        "hPort": "ComReset(hPort)"
      },
      "helpPath": "ComReset.html"
    },
    "comwrite": {
      "name": "ComWrite",
      "returnType": "UNKNOWN",
      "params": [
        "hPort",
        "sBuffer",
        "iLength",
        "iTimeOut"
      ],
      "doc": "Writes characters to a communication port.",
      "returns": "0 (zero) if the write is successful, otherwise an error code is returned.",
      "paramDocs": {
        "hPort": "ComWrite(hPort, sBuffer, iLength, iTimeOut)",
        "sBuffer": "The buffer from which to write the characters. Must be a String type variable.",
        "iLength": "The number of characters to write from the buffer. The maximum number of characters you can write is 128. Must be a Long type variable.",
        "iTimeOut": "The timeout for the write to complete."
      },
      "helpPath": "ComWrite.html"
    },
    "cos": {
      "name": "Cos",
      "returnType": "UNKNOWN",
      "params": [
        "Angle"
      ],
      "doc": "Calculates the trigonometric cosine of an angle.",
      "returns": "The cosine of Angle.",
      "paramDocs": {
        "Angle": "Cos(Angle)"
      },
      "helpPath": "Cos.html"
    },
    "createcontrolobject": {
      "name": "CreateControlObject",
      "returnType": "UNKNOWN",
      "params": [
        "sClass",
        "sName",
        "x1",
        "y1",
        "x2",
        "y2",
        "sEventClass"
      ],
      "doc": "Creates a new instance of an ActiveX object.",
      "returns": "The newly created object, if successful, otherwise an error is generated.",
      "paramDocs": {
        "sClass": "CreateControlObject(sClass, sName, x1, y1, x2, y2, sEventClass)",
        "sName": "The name for the object in the form of \"AN\" followed by its AN number, for example, \"AN35\". This name is used to access the object.",
        "x1": "The x coordinate of the object's top left hand corner as it will appear in your Plant SCADA window.",
        "y1": "The y coordinate of the object's top left hand corner as it will appear in your Plant SCADA window.",
        "x2": "The x coordinate of the object's bottom right hand corner as it will appear in your Plant SCADA window.",
        "y2": "The y coordinate of the object's bottom right hand corner as it will appear in your Plant SCADA window.",
        "sEventClass": "The string you would like to use as the event class for the object."
      },
      "helpPath": "CreateControlObject.html"
    },
    "createobject": {
      "name": "CreateObject",
      "returnType": "UNKNOWN",
      "params": [
        "sClass"
      ],
      "doc": "Creates a new instance of an ActiveX object. If you use this function to create an ActiveX object, it will have no visual component (only the automation component will be created).",
      "returns": "The newly created object, if successful, otherwise an error is generated.",
      "paramDocs": {
        "provided the CreateObject() call is not made within a loop.": "If you assign an object created with the CreateObject() function to a module or global scope variable, then that object will remain in existence until the variable either has another object assigned or is set to NullObject, provided the CreateObject() call is not made within a loop.",
        "sClass": "CreateObject(sClass)"
      },
      "helpPath": "CreateObject.html"
    },
    "dateadd": {
      "name": "DateAdd",
      "returnType": "UNKNOWN",
      "params": [
        "Time",
        "AddTime"
      ],
      "doc": "Adds time (in seconds) to a time/date value.",
      "returns": "The date as a time/date variable.",
      "paramDocs": {
        "Time": "DateAdd(Time, AddTime)",
        "AddTime": "The time to add, in seconds."
      },
      "helpPath": "DateAdd.html"
    },
    "dateday": {
      "name": "DateDay",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the day of the month from a time/date variable.",
      "returns": "The day of the month as an integer.",
      "paramDocs": {
        "Time": "DateDay(Time)"
      },
      "helpPath": "DateDay.html"
    },
    "dateinfo": {
      "name": "DateInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nInfo",
        "nExtra"
      ],
      "doc": "Returns the date format currently used on the Plant SCADA Server.",
      "returns": "A string containing one of the following:",
      "paramDocs": {
        "1": "The current date order:",
        "2": "The current date delimiter.",
        "3": "The current short date format.",
        "4": "The current long date format.",
        "5": "The current extended date format.",
        "6": "The short weekday string. The particular weekday returned is determined by the nExtra argument.",
        "7": "The long weekday string. The particular weekday returned is determined by the nExtra argument.",
        "8": "The short month string. The particular month returned is determined by the nExtra argument.",
        "9": "The long month string. The particular month returned is determined by the nExtra argument.",
        "nInfo": "DateInfo(nInfo, nExtra)",
        "nExtra": "When an nInfo argument of 6 or 7 is specified, the nExtra argument determines which weekday (1-7) is returned by the DateInfo() function."
      },
      "helpPath": "DateInfo.html"
    },
    "datemonth": {
      "name": "DateMonth",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the month from a time/date variable.",
      "returns": "The month of the year as an integer.",
      "paramDocs": {
        "Time": "DateMonth(Time)"
      },
      "helpPath": "DateMonth.html"
    },
    "datesub": {
      "name": "DateSub",
      "returnType": "UNKNOWN",
      "params": [
        "Time",
        "SubTime"
      ],
      "doc": "Subtracts time (in seconds) from a time/date value.",
      "returns": "The time difference (in seconds) as an integer.",
      "paramDocs": {
        "Time": "DateSub(Time, SubTime)",
        "SubTime": "The time to subtract, in seconds."
      },
      "helpPath": "DateSub.html"
    },
    "dateweekday": {
      "name": "DateWeekDay",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the day of the week from a time/date variable.",
      "returns": "An integer representing the day of the week as follows:",
      "paramDocs": {
        "Time": "DateWeekDay(Time)"
      },
      "helpPath": "DateWeekDay.html"
    },
    "dateyear": {
      "name": "DateYear",
      "returnType": "UNKNOWN",
      "params": [
        "Time [",
        "Mode]"
      ],
      "doc": "Gets the year from a time/date variable.",
      "returns": "The year as an integer.",
      "paramDocs": {
        "0": "Short year, yy. If you use this mode during the year 2000, 0 (zero) will be returned.",
        "1": "Long year, yyyy",
        "Time [, Mode]": "DateYear(Time [, Mode] )",
        "Time": "The time/date variable.",
        "Mode": "The format required:"
      },
      "helpPath": "DateYear.html"
    },
    "date": {
      "name": "Date",
      "returnType": "UNKNOWN",
      "params": [
        "[Format]"
      ],
      "doc": "Gets the current date in string format.",
      "returns": "The current date (in string format).",
      "paramDocs": {
        "0": "Short time format, hh:mm AM/PM.",
        "1": "Long time format, hh:mm:ss AM/PM.",
        "2": "Short date format, dd/mm/yy.",
        "3": "Long date format, day month year.",
        "4": "Time and date, weekday month day year hh:mm:ss AM/PM.",
        "5": "Long time period, hh:mm:ss. Time needs to be in seconds.",
        "6": "Millisecond time period, hh:mm:ss.xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.",
        "7": "Short time period, hh:mm. Time needs to be in seconds.",
        "8": "Long time period, \"xxxxx Days hh Hours mm min ss sec where xxxxx = number of days since 1/1/1970\". Time needs to be in seconds.",
        "9": "Extended date format, dd/mm/yyyy.",
        "10": "Local TimeDate format, yyyy-mm-dd hh:mm:ss",
        "11": "Time of Day, hh:mm:ss tt format with no date",
        "[Format]": "Date( [Format] )",
        "Format": "The format required:",
        "UTC": "Coordinated Universal Time (optional)"
      },
      "helpPath": "Date_CIREF.html"
    },
    "ddeexec": {
      "name": "DDEExec",
      "returnType": "UNKNOWN",
      "params": [
        "sApplication",
        "sCommand"
      ],
      "doc": "Executes a command in an external Windows application running on the same computer. With this function, you can control other applications that support DDE.",
      "returns": "1 (one) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sDocument": "You cannot use DDEExec() to call macros on a remote computer or to call Access SQLs. For these calls, Network DDE needs to pass the sDocument argument, so you need to use the DDEh... functions, passing sDocument in the DDEhInitiate() function.",
        "sApplication": "DDEExec(sApplication, sCommand)",
        "sCommand": "The command that the application will execute."
      },
      "helpPath": "DDEExec.html"
    },
    "ddehexecute": {
      "name": "DDEhExecute",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sCommand"
      ],
      "doc": "Executes a command in an external Windows application. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Handle": "DDEhExecute(Handle, sCommand)",
        "sCommand": "The command that the application will execute."
      },
      "helpPath": "DDEhExecute.html"
    },
    "ddehgetlasterror": {
      "name": "DDEhGetLastError",
      "returnType": "UNKNOWN",
      "params": [
        "Handle"
      ],
      "doc": "Gets the latest error code issued from Windows for the conversation identified by the handle.",
      "returns": "The error code last issued from Windows DDEML (for that conversation):",
      "paramDocs": {
        "Handle": "DDEhGetLastError(Handle)"
      },
      "helpPath": "DDEhGetLastError.html"
    },
    "ddehinitiate": {
      "name": "DDEhInitiate",
      "returnType": "UNKNOWN",
      "params": [
        "sApplication",
        "sDocument"
      ],
      "doc": "Starts a conversation with an external Windows application. When the data exchange is complete, you should terminate the conversation to free system resources.",
      "returns": "An integer handle for the conversation between Plant SCADA and the other application, or -1 if the conversation is not started successfully. The handle is used by the other DDEh... functions, to identify the conversation.",
      "paramDocs": {
        "sApplication": "DDEhInitiate(sApplication, sDocument)",
        "sDocument": "The document, topic, or file name.",
        "DDEh...": "An integer handle for the conversation between Plant SCADA and the other application, or -1 if the conversation is not started successfully. The handle is used by the other DDEh... functions, to identify the conversation."
      },
      "helpPath": "DDEhInitiate.html"
    },
    "ddehpoke": {
      "name": "DDEhPoke",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sItem",
        "sValue"
      ],
      "doc": "Writes a value to an external Windows application, for example, an Excel spreadsheet. The value is written once to the application. (To write the value dynamically, you need to call this function at the rate at which the data needs to be updated.)",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Handle": "DDEhPoke(Handle, sItem, sValue)",
        "sItem": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
        "sValue": "The value of the item."
      },
      "helpPath": "DDEhPoke.html"
    },
    "ddehreadln": {
      "name": "DDEhReadLn",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sTopic"
      ],
      "doc": "Reads a line of text from a DDE Conversion, for example, from an Excel spreadsheet. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.",
      "returns": "A line of data, or an empty string when all data has been read.",
      "paramDocs": {
        "Handle": "DDEhReadLn(Handle, sTopic)",
        "sTopic": "A unique topic name for the item; for example, the variable name, field name, or spreadsheet cell position."
      },
      "helpPath": "DDEhReadLn.html"
    },
    "ddehrequest": {
      "name": "DDEhRequest",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sItem"
      ],
      "doc": "Reads a value from an external Windows application, for example, from an Excel spreadsheet. You need to first start a conversation with the DDEhInitiate function, and use the handle returned by that function to identify the conversation.",
      "returns": "A string of data, or an empty string if the function cannot read the value.",
      "paramDocs": {
        "Handle": "DDEhRequest(Handle, sItem)",
        "sItem": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position."
      },
      "helpPath": "DDEhRequest.html"
    },
    "ddehsetmode": {
      "name": "DDEhSetMode",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sMode"
      ],
      "doc": "Set the mode of the DDE conversation. The default mode of a DDE conversation is to use TEXT data format - a simple string of data.",
      "returns": "The error code.",
      "paramDocs": {
        "1": "Text (default)",
        "2": "CSV",
        "Handle": "DDEhSetMode(Handle, sMode)",
        "sMode": "The mode of the DDE conversation:"
      },
      "helpPath": "DDEhSetMode.html"
    },
    "ddehterminate": {
      "name": "DDEhTerminate",
      "returnType": "UNKNOWN",
      "params": [
        "Handle"
      ],
      "doc": "Closes the conversation identified by the handle, and frees the resources associated with that conversation. After you call this function, the handle is no longer valid.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Handle": "DDEhTerminate(Handle)"
      },
      "helpPath": "DDEhTerminate.html"
    },
    "ddehwriteln": {
      "name": "DDEhWriteLn",
      "returnType": "UNKNOWN",
      "params": [
        "Handle",
        "sTopic",
        "sData"
      ],
      "doc": "Writes a line of text to the DDE conversation. With this function, you can write any amount of text to the DDE conversation.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Handle": "DDEhWriteLn(Handle, sTopic, sData)",
        "sTopic": "A unique name for the topic the data will be written to; for example, the spreadsheet cell position. The topic is only used when you complete the write by passing an empty string for data.",
        "sData": "The line of data to write. To terminate the data and make Plant SCADA send the data, set the data to an empty string."
      },
      "helpPath": "DDEhWriteLn.html"
    },
    "ddepost": {
      "name": "DDEPost",
      "returnType": "UNKNOWN",
      "params": [
        "sItem",
        "sValue"
      ],
      "doc": "Makes a Plant SCADA variable value available for DDE linking (that is posts a DDE link so that it can be read by other DDE compliant applications running on the same computer).",
      "returns": "The value that is posted, or empty string if the function does not succeed in posting the link.",
      "paramDocs": {
        "sItem": "DDEPost(sItem, sValue)",
        "sValue": "The value of the item."
      },
      "helpPath": "DDEPost.html"
    },
    "dderead": {
      "name": "DDERead",
      "returnType": "UNKNOWN",
      "params": [
        "sApplication",
        "sDocument",
        "sItem [",
        "Mode]"
      ],
      "doc": "Reads values from an external DDE compliant Windows application running on the same computer, (for example, from an Excel spreadsheet cell or a Word document).",
      "returns": "The value (from the external application) as a string, or an empty string if the function cannot read the desired values.",
      "paramDocs": {
        "0": "Do not set up advise loop.",
        "1": "Set up advise loop (default).",
        "sApplication": "DDERead(sApplication, sDocument, sItem [, Mode] )",
        "sDocument": "The document, topic, or file name.",
        "sItem": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
        "Mode": "A flag that tells the application whether or not to set up an advise loop:"
      },
      "helpPath": "DDERead.html"
    },
    "ddewrite": {
      "name": "DDEWrite",
      "returnType": "UNKNOWN",
      "params": [
        "sApplication",
        "sDocument",
        "sItem",
        "sValue"
      ],
      "doc": "Writes a value to an external Windows application, for example, to an Excel spreadsheet.",
      "returns": "The value that is sent to the other application, or an empty string if the function does not successfully write the value.",
      "paramDocs": {
        "sApplication": "DDEWrite(sApplication, sDocument, sItem, sValue)",
        "sDocument": "The document, topic, or file name.",
        "sItem": "A unique name for the item; for example, the variable name, field name, or spreadsheet cell position.",
        "sValue": "The value of the item."
      },
      "helpPath": "DDEWrite.html"
    },
    "debugbreak": {
      "name": "DebugBreak",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Causes a breakpoint exception error to occur (error number 342). This allows programmers to trap invalid states in their Cicode.",
      "returns": "None.",
      "paramDocs": {},
      "helpPath": "DebugBreak.html"
    },
    "debugmsg": {
      "name": "DebugMsg",
      "returnType": "UNKNOWN",
      "params": [
        "sMessage"
      ],
      "doc": "Provides in-line debug messages of user Cicode, to the Kernel, Debugger Debug window, and the SysLog.DAT file. This function can be enabled or disabled with the [Code]DebugMessage parameter or DebugMsgSet() function at runtime.",
      "returns": "None.",
      "paramDocs": {
        "sMessage": "DebugMsg(sMessage)"
      },
      "helpPath": "DebugMsg.html"
    },
    "debugmsgset": {
      "name": "DebugMsgSet",
      "returnType": "UNKNOWN",
      "params": [
        "nMode"
      ],
      "doc": "Enables/disables the DebugMsg() logging functionality. It also controls whether logging is enabled for the Assert() function. This function also sets the [Code]DebugMessage parameter appropriately.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nMode": "DebugMsgSet(nMode)"
      },
      "helpPath": "DebugMsgSet.html"
    },
    "degtorad": {
      "name": "DegToRad",
      "returnType": "UNKNOWN",
      "params": [
        "Angle"
      ],
      "doc": "Converts an angle from degrees to radians.",
      "returns": "The angle in radians.",
      "paramDocs": {
        "Angle": "DegToRad(Angle)"
      },
      "helpPath": "DegToRad.html"
    },
    "delayshutdown": {
      "name": "DelayShutdown",
      "returnType": "UNKNOWN",
      "params": [
        "Delay"
      ],
      "doc": "Terminates 's operation after the specified delay period (in milliseconds). This function is suitable to be called by the CTAPI.",
      "returns": "No return value.",
      "paramDocs": {
        "Delay": "DelayShutdown(Delay)"
      },
      "helpPath": "DelayShutdown.html"
    },
    "devappend": {
      "name": "DevAppend",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Appends a blank record to the end of a device. After the record is appended, you can use the DevSetField() function to add data to fields in the record.",
      "returns": "0 (zero) if the record is successfully appended, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevAppend(hDev)"
      },
      "helpPath": "DevAppend.html"
    },
    "devclose": {
      "name": "DevClose",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "Mode"
      ],
      "doc": "Closes a device. Any data in the buffer is flushed to the device before it is closed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hDev, Mode": "DevClose(hDev, Mode)",
        "hDev": "The device handle, returned from the DevOpen() function. The device handle identifies the table where data on the associated device is stored.",
        "Mode": "The mode of the close:"
      },
      "helpPath": "DevClose.html"
    },
    "devcontrol": {
      "name": "DevControl",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "Type [",
        "sData]"
      ],
      "doc": "Controls a dBASE or SQL device. You can pack a dBASE device to physically remove deleted records, or re-index a dBASE device to regenerate the keys.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Re-index the device based on the key defined in the device record (dBASE devices only).",
        "1": "Pack the database file - all deleted records are removed (dBASE devices only).",
        "2": "Issue a direct SQL query to the device (SQL devices only).",
        "3": "Get error status of the last SQL query (SQL devices only).",
        "hDev": "DevControl(hDev, Type [, sData])",
        "nType": "The type of command:",
        "sData": "The command data, that is the SQL query to be issued. Used only for Type 2 commands."
      },
      "helpPath": "DevControl.html"
    },
    "devcurr": {
      "name": "DevCurr",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the current device handle. You can only call this function in a report, to get the handle of the device where the report is logging. You can then use the other device functions (for example, DevPrint()) to access that logging device.",
      "returns": "The current device handle or group handle. If no device is configured, -1 is returned.",
      "paramDocs": {},
      "helpPath": "DevCurr.html"
    },
    "devdelete": {
      "name": "DevDelete",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Deletes the current record in a dBASE database device. The record is not physically deleted, but is marked for deletion.",
      "returns": "0 (zero) if the record is successfully deleted, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevDelete(hDev)"
      },
      "helpPath": "DevDelete.html"
    },
    "devdisable": {
      "name": "DevDisable",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "State"
      ],
      "doc": "Disables (and re-enables) a device from all access, and discards any data written to the device. When a device is disabled, it cannot be opened, and data cannot be read from the device. Use this function to disable logging to a database or printer.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Enable the device.",
        "1": "Disable the device.",
        "State": "The State argument is a toggle. A State of 1 disables the device(s), but you can then re-enable the device(s) by repeating the function with State = 0.",
        "sName": "DevDisable(sName, State)"
      },
      "helpPath": "DevDisable.html"
    },
    "deveof": {
      "name": "DevEOF",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Gets the status of the end of file (EOF) flag for a device. When you use the DevPrev(), DevNext(), or DevSeek() function, the start or end of the device will eventually be reached, and the EOF flag will be set. Use this function to test the EOF flag.",
      "returns": "1 if the EOF flag has been set, otherwise 0 (zero).",
      "paramDocs": {
        "hDev": "DevEOF(hDev)"
      },
      "helpPath": "DevEOF.html"
    },
    "devfind": {
      "name": "DevFind",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "sFind",
        "sField"
      ],
      "doc": "Searches a device for a record that contains specified data in a specified field. The search starts at the current record and continues forward until the matched data is found or the end of the database is reached.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevFind(hDev, sFind, sField)",
        "sFind": "The data to find in sField, as a string.",
        "sField": "The field name to match."
      },
      "helpPath": "DevFind.html"
    },
    "devfirst": {
      "name": "DevFirst",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Finds the first record in a device.",
      "returns": "The first indexed record (if the device is an indexed database), otherwise the first record in the device.",
      "paramDocs": {
        "hDev": "DevFirst(hDev)"
      },
      "helpPath": "DevFirst.html"
    },
    "devflush": {
      "name": "DevFlush",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Flushes buffered data to the physical device.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevFlush(hDev)"
      },
      "helpPath": "DevFlush.html"
    },
    "devgetfield": {
      "name": "DevGetField",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "sField"
      ],
      "doc": "Gets field data from the current record in a device.",
      "returns": "The field data (as a string). If the field is not found an empty string is returned.",
      "paramDocs": {
        "hDev": "DevGetField(hDev, sField )",
        "sField": "The field name, as a string of up to 10 characters. (The dBASE file format limits all field names to a maximum of 10 characters.)"
      },
      "helpPath": "DevGetField.html"
    },
    "devhistory": {
      "name": "DevHistory",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Renames a device file and any subsequent history files. The current device is closed and renamed as the first history file.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevHistory(hDev)"
      },
      "helpPath": "DevHistory.html"
    },
    "devinfo": {
      "name": "DevInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "nType"
      ],
      "doc": "Gets information on a device.",
      "returns": "The device information as a string if successful, otherwise an empty string is returned.",
      "paramDocs": {
        "hDev": "DevInfo(hDev, nType)",
        "nType": "Type of information:"
      },
      "helpPath": "DevInfo.html"
    },
    "devmodify": {
      "name": "DevModify",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "Format",
        "Header",
        "FileName",
        "nType"
      ],
      "doc": "Modifies the attributes of a device. The device needs to be closed before you can modify a device.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName": "DevModify(sName, Format, Header, FileName, nType)",
        "Name": "The name of the device.",
        "Format": "A new format for the device or \"*\" to use the existing format.See Format Templates for more information.",
        "Header": "A new header for the device or \"*\" to use the existing header.",
        "FileName": "A new file name for the device or \"*\" (asterisk) to use the existing filename.",
        "nType": "A new device type."
      },
      "helpPath": "DevModify.html"
    },
    "devnext": {
      "name": "DevNext",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Gets the next record in a device.",
      "returns": "0 if the next record is read, or an error if the end of the database is reached.",
      "paramDocs": {
        "hDev": "DevNext(hDev)"
      },
      "helpPath": "DevNext.html"
    },
    "devopen": {
      "name": "DevOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sName [",
        "nMode]"
      ],
      "doc": "Opens a device and returns the device handle.",
      "returns": "The device handle. If the device cannot be opened, -1 is returned. The device handle identifies the table where all data on the associated device is stored.",
      "paramDocs": {
        "0": "Open the device in shared mode - the default mode when opening a device if none is specified.",
        "1": "Open the device in exclusive mode. In this mode only one user can have the device open. The open will return an error if another user has the device open in shared or exclusive mode.",
        "2": "Open the device in indexed mode. In this mode the device will be accessed in index order. This mode is only valid if the device is a database device and has an index configured in the Header field at the Devices form. Please be aware that specifying mode 2 when opening an ASCII device is ignored internally.",
        "4": "Open the device in 'SQL not select' mode. If opened in this mode, you need to not attempt to read from an SQL device.",
        "8": "Open the device in logging mode. In this mode the history files will be created automatically.",
        "16": "Open the device in read only mode. In this mode data can be viewed, but not written. This mode is supported only by DBF and ASCII files - it is ignored by printers and SQL/ODBC databases.",
        "sName": "DevOpen(sName [, nMode] )",
        "Name": "The name of the device.",
        "nMode": "The mode of the open:"
      },
      "helpPath": "DevOpen.html"
    },
    "devprev": {
      "name": "DevPrev",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Gets the previous record in a device.",
      "returns": "0 if the record is read successfully, or an error code if the start of the database is reached.",
      "paramDocs": {
        "hDev": "DevPrev(hDev)"
      },
      "helpPath": "DevPrev.html"
    },
    "devprint": {
      "name": "DevPrint",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "sData",
        "NewLine"
      ],
      "doc": "Prints free-format data to groups of devices.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Do not insert a newline character.",
        "1": "Insert a newline character.",
        "hGrp": "DevPrint(hGrp, sData, NewLine)",
        "sData": "The data to print to the group of devices.",
        "NewLine": "The newline flag:"
      },
      "helpPath": "DevPrint.html"
    },
    "devread": {
      "name": "DevRead",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "Length"
      ],
      "doc": "Reads characters from a device.",
      "returns": "The data (in string format). If the end of the device is found, an empty string is returned.",
      "paramDocs": {
        "hDev": "DevRead(hDev, Length)",
        "Length": "The number of characters to read."
      },
      "helpPath": "DevRead.html"
    },
    "devreadln": {
      "name": "DevReadLn",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Reads data from the current record of a device until the end of the line, or end of the record. If the device is record-based, the record number is incremented.",
      "returns": "The data (in string format). If the end of the device is found, an empty string is returned and the EOF flag is set.",
      "paramDocs": {
        "hDev": "DevReadLn(hDev)"
      },
      "helpPath": "DevReadLn.html"
    },
    "devrecno": {
      "name": "DevRecNo",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Gets the current record number of a device.",
      "returns": "The record number. If an error is detected while getting the record number, -1 is returned.",
      "paramDocs": {
        "hDev": "DevRecNo(hDev)"
      },
      "helpPath": "DevRecNo.html"
    },
    "devseek": {
      "name": "DevSeek",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "Offset"
      ],
      "doc": "Moves the device pointer to a specified position in the device.",
      "returns": "0 (zero) if the seek was successful, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevSeek(hDev, Offset)",
        "Offset": "The offset in the device. If the device is a database device, the offset is the record number. If the device is a binary device, the offset is in bytes (from 0 to the maximum file size -1)."
      },
      "helpPath": "DevSeek.html"
    },
    "devsetfield": {
      "name": "DevSetField",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "sField",
        "sData"
      ],
      "doc": "Sets new field data in the current record in a device.",
      "returns": "0 (zero) if the data is successfully set, otherwise an error code is returned.",
      "paramDocs": {
        "hDev": "DevSetField(hDev, sField , sData)",
        "sField": "The field name, as a string of up to 10 characters. (The dBASE file format limits all field names to a maximum of 10 characters.)",
        "sData": "New field data, in string format. Plant SCADA converts any other data type into a string before setting the data."
      },
      "helpPath": "DevSetField.html"
    },
    "devsize": {
      "name": "DevSize",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Gets the size of a physical device.",
      "returns": "If the device is a database device, the number of records is returned. If the device is a binary device, the number of bytes in the file is returned. If an error is detected, -1 is returned.",
      "paramDocs": {
        "hDev": "DevSize(hDev)"
      },
      "helpPath": "DevSize.html"
    },
    "devwrite": {
      "name": "DevWrite",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "sData"
      ],
      "doc": "Writes a string to a device. If the device is free-format, the data is written to the device as specified.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hDev": "DevWrite(hDev, sData)",
        "sData": "The data to write, as a string."
      },
      "helpPath": "DevWrite.html"
    },
    "devwriteln": {
      "name": "DevWriteLn",
      "returnType": "UNKNOWN",
      "params": [
        "hDev",
        "sData"
      ],
      "doc": "Writes a string to a device. If the device is free-format, the data is written to the device, followed by a newline character.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hDev": "DevWriteLn(hDev, sData)",
        "sData": "The data to write, as a string."
      },
      "helpPath": "DevWriteLn.html"
    },
    "devzap": {
      "name": "DevZap",
      "returnType": "UNKNOWN",
      "params": [
        "hDev"
      ],
      "doc": "Zaps a device. If a database device is zapped, all records are deleted. If an ASCII file is zapped, the file is truncated to 0 (zero) length.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hDev": "DevZap(hDev)"
      },
      "helpPath": "DevZap.html"
    },
    "displayruntimemanager": {
      "name": "DisplayRuntimeManager",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "This function will start Runtime Manager if it is not already running, otherwise it will just bring the Runtime Manager to the foreground.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "DisplayRuntimeManager.html"
    },
    "dllcall": {
      "name": "DLLCall",
      "returnType": "UNKNOWN",
      "params": [
        "hFunction",
        "sArgs"
      ],
      "doc": "Calls a DLL function, and passes a string of arguments to that function.",
      "returns": "The result of the function, as a string.",
      "paramDocs": {
        "hFunction": "DLLCall(hFunction, sArgs)",
        "sArgs": "The string of arguments to pass to the DLL function. The argument string contains all the arguments for the function, separated by commas (,). Enclose string arguments in quote marks \"\", and use the string escape character (^) to put a string delimiter within a string. This syntax is the same as the syntax for the TaskNew() function"
      },
      "helpPath": "DLLCall.html"
    },
    "dllcallex": {
      "name": "DLLCallEx",
      "returnType": "UNKNOWN",
      "params": [
        "hFunction",
        "vParameters"
      ],
      "doc": "Calls a DLL function, and passes the specified arguments to that function.",
      "returns": "The result of the function. If the DLL function returns a string then your Cicode return variable should be of type STRING. All other types will be INT.",
      "paramDocs": {
        "hFunction": "DLLCallEx(hFunction,vParameters)",
        "vParameters": "A variable length parameter list of method arguments. The parameters will be passed to the function in the order that you enter them. Specifying too few or too many parameters will generate an Invalid Argument hardware error. An Invalid Argument hardware error will also be generated if you specify a parameter to the DLL function with the wrong type."
      },
      "helpPath": "DLLCallEx.html"
    },
    "dllclasscallmethod": {
      "name": "DllClassCallMethod",
      "returnType": "UNKNOWN",
      "params": [
        "OBJECT object",
        "STRING sMethod",
        "VARARGS args"
      ],
      "doc": "Use this function to call a method of a .Net object, passing in the method name and any arguments required for the matching prototype of the method.",
      "returns": "Var if successful, otherwise an error code is returned.",
      "paramDocs": {
        "OBJECT object": "VAR DllClassCallMethod(OBJECT object, STRING sMethod, VARARGS args)",
        "object": ".Net object.",
        "args": "args"
      },
      "helpPath": "DllClassCallMethod.html"
    },
    "dllclasscreate": {
      "name": "DllClassCreate",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sPath",
        "STRING sClass [",
        "vParameters Args]"
      ],
      "doc": "Use this function to instantiate a new .Net object by specifying the path, class and arguments required for the matching constructor of the class.",
      "returns": ".Net object if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(STRING sPath, STRING sClass [, vParameters Args])": "OBJECT DllClassCreate(STRING sPath, STRING sClass [, vParameters Args])",
        "sPath": "The full path string.",
        "sClass": "The class of the object.",
        "Args": "Args for the constructor."
      },
      "helpPath": "DllClassCreate.html"
    },
    "dllclassdispose": {
      "name": "DllClassDispose",
      "returnType": "UNKNOWN",
      "params": [
        "OBJECT object"
      ],
      "doc": "Use this function to clean up resources used by the .Net object and any other objects created via the use of the object.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "OBJECT object": "INT DllClassDispose(OBJECT object)",
        "object": ".Net object."
      },
      "helpPath": "DllClassDispose.html"
    },
    "dllclassgetproperty": {
      "name": "DllClassGetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "OBJECT object",
        "STRING sProperty"
      ],
      "doc": "Use this function to get a property of the .Net object.",
      "returns": "Var if successful, otherwise an error code is returned.",
      "paramDocs": {
        "OBJECT object": "VAR DllClassGetProperty(OBJECT object, STRING sProperty)",
        "object": ".Net object.",
        "sProperty": "The property to read."
      },
      "helpPath": "DllClassGetProperty.html"
    },
    "dllclassisvalid": {
      "name": "DllClassIsValid",
      "returnType": "UNKNOWN",
      "params": [
        "OBJECT"
      ],
      "doc": "Use this function to validate the handle for the class returned from DllClassCreate.",
      "returns": "1 if handle is valid or 0",
      "paramDocs": {
        "OBJECT": "INT DllClassIsValid(OBJECT)"
      },
      "helpPath": "DllClassIsValid.html"
    },
    "dllclasssetproperty": {
      "name": "DllClassSetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "OBJECT object",
        "STRING sProperty",
        "VARIANT Value"
      ],
      "doc": "Use this function to set a property of the .Net object. The property may be of any type or an object itself.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "OBJECT object": "INT DllClassSetProperty(OBJECT object, STRING sProperty, VARIANT Value)",
        "object": ".Net object.",
        "sProperty": "sProperty",
        "Value": "Value"
      },
      "helpPath": "DllClassSetProperty.html"
    },
    "dllclose": {
      "name": "DLLClose",
      "returnType": "UNKNOWN",
      "params": [
        "hFunction"
      ],
      "doc": "Closes the link to a DLL function, and frees the memory allocated for that function link.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFunction": "DLLClose(hFunction)"
      },
      "helpPath": "DLLClose.html"
    },
    "dllopen": {
      "name": "DLLOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sLib",
        "sName",
        "sArgs"
      ],
      "doc": "Opens a link to a DLL function, by loading the specified DLL library into memory and attaching it to the named function.",
      "returns": "The DLL function handle, or -1 if the library or function could not be found or loaded.",
      "paramDocs": {
        "sLib": "DLLOpen(sLib, sName, sArgs)",
        "sName": "The function name. An underscore (_) is required in the function name for a 'C' function, but not for a Pascal function. When you call a DLL from a Cicode function, sName needs to be the same as the name defined in the .DEF file used to link the DLL. The file extension is not required.",
        "sArgs": "The string specifying the function arguments. The first character in the string is the return value of the function.",
        "A": "Logical.",
        "B": "IEEE 8 byte floating point number.",
        "C": "Null terminated string. Maximum string length 255 characters.",
        "D": "Byte counted string. First byte contains the length of the string, maximum string length 255 characters.",
        "H": "Unsigned 2 byte integer.",
        "I": "Signed 2 byte integer.",
        "J": "Signed 4 byte integer."
      },
      "helpPath": "DLLOpen.html"
    },
    "driverinfo": {
      "name": "DriverInfo",
      "returnType": "UNKNOWN",
      "params": [
        "IODevice",
        "nType [",
        "sClusterName] [",
        "ServerName]"
      ],
      "doc": "Provides information about the driver for a specified I/O device.",
      "returns": "The driver information as a string. In the case of an error the return value is an empty string.",
      "paramDocs": {
        "0": "Driver Name",
        "1": "Driver Title",
        "2": "Block constant",
        "3": "Max Retrys",
        "4": "Transmit Delay",
        "5": "Receive Timeout",
        "6": "Polltime",
        "7": "Watchtime (milliseconds",
        "IODevice": "DriverInfo(IODevice, nType [, sClusterName] [, ServerName] )",
        "nType": "The type of information returned about the driver. Specify one of the following:",
        "sClusterName": "Specifies the name of the cluster in which the I/O Server resides. This is optional if you have one cluster or are resolving the I/O server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "DriverInfo.html"
    },
    "dspancreatecontrolobject": {
      "name": "DspAnCreateControlObject",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sClass",
        "Width",
        "Height [",
        "sEventClass]"
      ],
      "doc": "Creates a new instance of an ActiveX object.",
      "returns": "The newly created object, if successful, otherwise an error is generated.",
      "paramDocs": {
        "nAN": "DspAnCreateControlObject(nAN, sClass, Width, Height [, sEventClass] )",
        "sClass": "The class of the object. You can use the object's human readable name, its program ID, or its GUID. If the class does not exist, the function will return an error.",
        "Width": "The width of the ActiveX object.",
        "Height": "The height of the ActiveX object.",
        "sEventClass": "The string you would like to use as the event class for the object."
      },
      "helpPath": "DspAnCreateControlObject.html"
    },
    "dspanfree": {
      "name": "DspAnFree",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Frees (removes) an AN from the current page. If an animation exists at the animation number, it is deleted before the AN is freed. Use this function to free existing ANs or ANs created with the DspAnNew() function.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspAnFree(nAN)"
      },
      "helpPath": "DspAnFree.html"
    },
    "dspangetarea": {
      "name": "DspAnGetArea",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the area configured for an object at a specific AN (animation-point number). The area is returned as an integer.",
      "returns": "The area if successful, otherwise an error is returned. If the object is configured with 'Same area as page' checked, the area of the page will be returned. AN area of 0 (zero) means no areas are configured for the object.",
      "paramDocs": {
        "nAN": "DspAnGetArea(nAN)"
      },
      "helpPath": "DspAnGetArea.html"
    },
    "dspangetmetadata": {
      "name": "DspAnGetMetadata",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sMetaName"
      ],
      "doc": "Retrieves the field value of the specified metadata entry.",
      "returns": "Value for the specified metadata. Returns empty string if a matching metadata entry is not defined and error code if unsuccessful.",
      "paramDocs": {
        "nAN, sMetaName": "DspAnGetMetadata(nAN, sMetaName)",
        "nAN": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.)",
        "sMetaName": "The name of the metadata entry for which to search."
      },
      "helpPath": "DspAnGetMetadata.html"
    },
    "dspangetmetadataat": {
      "name": "DspAnGetMetadataAt",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nIndex",
        "sField"
      ],
      "doc": "Retrieves metadata information at the specified index.",
      "returns": "The field value string. If there is an error, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN,nIndex,sField": "DspAnGetMetadataAt(nAN,nIndex,sField)",
        "nAn": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.)",
        "nIndex": "The index of the metadata in the animation point. The index is 0-based; i.e. the first metadata entry has an index of 0, the next 1, and so on.",
        "sField": "The name of the field from which to retrieve the information for the metadata. Supported fields are:"
      },
      "helpPath": "DspAnGetMetadataAt.html"
    },
    "dspangetpos": {
      "name": "DspAnGetPos",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "X",
        "Y [",
        "nMode]"
      ],
      "doc": "Gets the x and y coordinates of an AN, in pixels, relative to the top-left corner of the window.",
      "returns": "0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the AN's position if successful, or to -1 if an error has been detected.",
      "paramDocs": {
        "nAN": "DspAnGetPos(nAN, X, Y [, nMode])",
        "X, Y": "Variables used to store the x and y pixel coordinates of the AN, returned from this function.",
        "X": "0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the AN's position if successful, or to -1 if an error has been detected."
      },
      "helpPath": "DspAnGetPos.html"
    },
    "dspangetprivilege": {
      "name": "DspAnGetPrivilege",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the privileges configured for an object at a specific AN (animation-point number).",
      "returns": "The privilege if successful, otherwise an error is returned. A privilege of 0 (zero) means no privileges are configured for the object.",
      "paramDocs": {
        "nAN": "DspAnGetPrivilege(nAN)"
      },
      "helpPath": "DspAnGetPrivilege.html"
    },
    "dspaninfo": {
      "name": "DspAnInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nType"
      ],
      "doc": "Gets information on an AN - the type or state of the animation that is currently displayed.",
      "returns": "The animation information, which depends on the type passed argument, as described above, as a string.",
      "paramDocs": {
        "0": "No animation is displayed.",
        "1": "Color is displayed.",
        "2": "A bar graph is displayed.",
        "3": "Text is displayed.",
        "4": "A symbol is displayed.",
        "5": "AN animation symbol is displayed.",
        "6": "A trend is displayed.",
        "7": "A button is displayed.",
        "8": "A slider is displayed.",
        "9": "A plot is displayed.",
        "10": "Rich Edit",
        "11": "Bitmap",
        "12": "Straight Line",
        "13": "Free hand Line",
        "14": "Rectangle",
        "15": "Ellipse",
        "16": "Spark",
        "17": "Group",
        "18": "Windows Meta File",
        "19": "Poly Line",
        "20": "Dynamic object",
        "21": "Pipe",
        "22": "Symbol Set",
        "23": "OCX",
        "24": "Basic AN",
        "25": "Number",
        "26": "Advanced AN",
        "27": "Keyboard AN",
        "28": "Sizemove AN",
        "29": "Touch AN",
        "nAN": "DspAnInfo(nAN, nType)",
        "nType": "The type of information:"
      },
      "helpPath": "DspAnInfo.html"
    },
    "dspaninrgn": {
      "name": "DspAnInRgn",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "One",
        "Two"
      ],
      "doc": "Checks if an AN is within a region bounded by two ANs.",
      "returns": "1 if the AN is within the region, or 0 (zero) if it is not.",
      "paramDocs": {
        "nAN": "pAnInRgn(nAN, One, Two)",
        "One, Two": "One - the AN at a corner of the region; two - the AN at the opposite corner of the region."
      },
      "helpPath": "DspAnInRgn.html"
    },
    "dspanmove": {
      "name": "DspAnMove",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "X",
        "Y"
      ],
      "doc": "Moves an AN to a new position. Any animation at this AN is also moved.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspAnMove(nAN, X, Y)",
        "X": "The x pixel coordinates of the new position.",
        "Y": "The y pixel coordinates of the new position."
      },
      "helpPath": "DspAnMove.html"
    },
    "dspanmoverel": {
      "name": "DspAnMoveRel",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "X",
        "Y"
      ],
      "doc": "Moves an AN relative to its current position. Any animation at this AN is also moved.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspAnMoveRel(nAN, X, Y)",
        "X": "The number of pixels to move the AN in the x plane.",
        "Y": "The number of pixels to move the AN in the y plane."
      },
      "helpPath": "DspAnMoveRel.html"
    },
    "dspannew": {
      "name": "DspAnNew",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y"
      ],
      "doc": "Creates an AN at the specified x and y coordinates.",
      "returns": "If successful, the new AN is returned. If the AN cannot be created, -1 is returned. If an AN already exists at this location, that AN is returned.",
      "paramDocs": {
        "X": "DspAnNew(X, Y)",
        "Y": "The y pixel coordinate where the new AN is created."
      },
      "helpPath": "DspAnNew.html"
    },
    "dspannewrel": {
      "name": "DspAnNewRel",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "X",
        "Y"
      ],
      "doc": "This function is only used for V3.xx and V4.xx animations, and was superseded by future releases.",
      "returns": "If successful, the new AN is returned. If the AN cannot be created, -1 is returned. If an AN already exists at this location, that AN is returned.",
      "paramDocs": {
        "nAN": "DspAnNewRel(nAN, X, Y)",
        "X": "The distance in the x plane (in pixels) from the reference AN to the new AN.",
        "Y": "The distance in the y plane (in pixels) from the reference AN to the new AN."
      },
      "helpPath": "DspAnNewRel.html"
    },
    "dspansetmetadata": {
      "name": "DspAnSetMetadata",
      "returnType": "UNKNOWN",
      "params": [
        "nAn",
        "sMetaName",
        "sValue"
      ],
      "doc": "Non-blocking function that sets the value of the specified metadata entry.",
      "returns": "0 if successful, error code if unsuccessful",
      "paramDocs": {
        "nAn, sMetaName, sValue": "DspAnSetMetadata(nAn, sMetaName, sValue)",
        "nAn": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.)",
        "sMetaName": "The name of metadata entry for which to search.",
        "sValue": "The value for the metadata to be set."
      },
      "helpPath": "DspAnSetMetadata.html"
    },
    "dspansetmetadataat": {
      "name": "DspAnSetMetadataAt",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nIndex",
        "sField",
        "sFieldValue"
      ],
      "doc": "Non-blocking function, that sets the value of a metadata entry.",
      "returns": "0 if successful, error code if unsuccessful",
      "paramDocs": {
        "nAN, nIndex, sField, sFieldValue": "DspAnSetMetadataAt(nAN, nIndex, sField, sFieldValue)",
        "nAn": "An animation number that uniquely identifies an object. This object contains the list of metadata definitions that will be used to perform the association operations. When -2 is specified, it is equivalent to using DspGetAnCur(). (See DspGetAnCur for usage and limitations.)",
        "nIndex": "The index of the metadata in the animation point.",
        "sField": "The name of the field in which to set the information for the metadata. Supported fields are:",
        "sFieldValue": "The value to set in the specified field of the metadata entry."
      },
      "helpPath": "DspAnSetMetadataAt.html"
    },
    "dspansetname": {
      "name": "DspAnSetName",
      "returnType": "UNKNOWN",
      "params": [
        "hAN",
        "sName"
      ],
      "doc": "Using a valid AN set the name of an animation object.",
      "returns": "Returns an error if given name is already in use.",
      "paramDocs": {
        "hAN": "DspAnSetName(hAN, sName)",
        "sName": "sName"
      },
      "helpPath": "DspAnSetName.html"
    },
    "dsparraybyan": {
      "name": "DspArrayByAn",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Calculates the absolute (positive) value of a number.",
      "returns": "0 (zero). If there is an error, the error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "nAN": "INTDspArrayByAn(INT nAN)"
      },
      "helpPath": "DspArrayByAn.html"
    },
    "dspbar": {
      "name": "DspBar",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Bar",
        "Value"
      ],
      "doc": "Displays a bar graph (on a graphics page) at a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspBar(nAN, Bar, Value)",
        "Bar": "The name of the bar graph to display in the format <[LibName.]BarName>. If you do not specify the library name, a bar graph from the Global library displays (if it exists). To display a Version 1.xx bar graph, specify the bar definition (1 to 255). For example, if you specify bar 1, Plant SCADA displays the bar graph Global.Bar001.",
        "Value": "The value to display on the bar graph. The value needs to be from 0 to 32000 to give 0 to full-scale range on the bar."
      },
      "helpPath": "DspBar.html"
    },
    "dspbmp": {
      "name": "DspBmp",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sFile",
        "Mode"
      ],
      "doc": "Displays a bitmap at a specified AN. This function allows you to display any bitmap file at run time.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Erase the existing bitmap and display this bitmap.",
        "1": "Do not erase the existing bitmap, just draw the new bitmap. (This mode provides smoother animation than Mode 0, but the bitmaps needs to be the same size).",
        "2": "Do not erase the existing bitmap, just draw the new bitmap. This mode is similar to mode 1, but it displays the bitmap about 3 times faster. However, the bitmap should not contain any transparent color, or it will display as a random color. Use this mode for fast, smooth animation.",
        "nAN": "DspBmp(nAN, sFile, Mode)",
        "sFile": "The name of the bitmap (.BMP) file. The file needs to be in the user project path. (Only .bmp files are supported. Other image formats like .png or .jpg are not supported.)",
        "Mode": "The mode of bitmap display:"
      },
      "helpPath": "DspBmp.html"
    },
    "dspbutton": {
      "name": "DspButton",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "UpKey",
        "Name [",
        "hFont] [",
        "Width] [",
        "Height] [",
        "DownKey] [",
        "RepeatKey] [",
        "Style]"
      ],
      "doc": "Displays a button at a specified AN. When the button is selected, the key definition is put into the key command line.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sName": "Displays a button at a specified AN. When the button is selected, the key definition is put into the key command line. The font, width, height, and down and repeat keys of the button are optional. If you do not specify a width and height, the button adjusts to the size of the button sName.",
        "nAN": "DspButton(nAN, UpKey, Name [, hFont] [, Width] [, Height] [, DownKey] [, RepeatKey] [, Style])",
        "UpKey": "The key generated when the command button is selected (when the mouse button is released after being clicked down). This is the default operation for commands activated by a button.",
        "Name": "The name to display on the button.",
        "hFont": "The handle of the font used to display the button name. Use the DspFont() function to create a new font and return the font handle. Use the DspFontHnd() function to return the font handle of an existing font. The Windows button font is used if the font is omitted or is not defined in the database.",
        "Width": "The width of the button in pixels.",
        "Height": "The height of the button in pixels.",
        "DownKey": "The key generated when the mouse button is clicked down (over the command button). Normally this parameter is not used, because most buttons are configured to activate a command when the mouse button is released (returning to the `up' position).",
        "RepeatKey": "The key generated repetitively, while the mouse button is being held down (over the command button).",
        "Style": "A number indicating the visibility style of the button:"
      },
      "helpPath": "DspButton.html"
    },
    "dspbuttonfn": {
      "name": "DspButtonFn",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "UpFunction",
        "Name [",
        "hFont] [",
        "Width] [",
        "Height] [",
        "DownFunction] [",
        "RepeatFunction]"
      ],
      "doc": "Displays a button at a specified AN. When the button is selected, a user function is called. If the width and height are 0 (zero), then the button adjusts to the size of the button sName.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sName": "Displays a button at a specified AN. When the button is selected, a user function is called. If the width and height are 0 (zero), then the button adjusts to the size of the button sName.",
        "nAN, UpFunction, Name [, hFont] [, Width] [, Height] [, DownFunction] [, RepeatFunction]": "DspButtonFn(nAN, UpFunction, Name [, hFont] [, Width] [, Height] [, DownFunction] [, RepeatFunction] )",
        "nAN": "The animation-point number.",
        "UpFunction": "The user function called when the command button is selected (when the mouse button is released after being clicked down). This is the default operation for commands activated by a button. This callback function can have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument.",
        "Name": "The name to display on the button.",
        "hFont": "The handle of the font used to display the button name. Use the DspFont() function to create a new font and return the font handle. Use the DspFontHnd() function to return the font handle of an existing font. The Windows button font is used if the font is omitted or is not defined in the database.",
        "Width": "The width of the button in pixels.",
        "Height": "The height of the buton in pixels.",
        "DownFunction": "The user function called when the mouse button is clicked down (over the command button). Normally this parameter is not used, because most buttons are configured to activate when the mouse button is released (returning to the `up' position). The callback function needs to have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument.",
        "RepeatFunction": "The user function called repetitively, while the mouse button is being held down (over the command button) The callback function needs to have no arguments, so specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function for this argument."
      },
      "helpPath": "DspButtonFn.html"
    },
    "dspchart": {
      "name": "DspChart",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Chart",
        "Value1 [",
        "Value2 ... Value8]"
      ],
      "doc": "Displays a chart at an AN. Charts are trend lines with markers on them.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Value1": "Displays a chart at an AN. Charts are trend lines with markers on them. Values are plotted on the chart pens. You need to specify Value1, but Value2 to Value8 are optional.",
        "nAN, Chart, Value1 [, Value2 ... Value8]": "DspChart(nAN, Chart, Value1 [, Value2 ... Value8] )",
        "nAN": "The AN where the chart will be displayed.",
        "Chart": "The chart to display.",
        "Value2 ... 8": "The values to display on Pen 2...Pen 8 of the chart. These values are optional."
      },
      "helpPath": "DspChart.html"
    },
    "dspclearclip": {
      "name": "DspClearClip",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN"
      ],
      "doc": "Sets tool tip text associated with an AN. Any existing text associated with the AN will be replaced with the new text.",
      "returns": "If ANn is invalid will return 0",
      "paramDocs": {
        "nAN": "DspClearClip(INT nAN)",
        "nAn": "The animation-point number of the object or groups within the clipping rectangle."
      },
      "helpPath": "DspClearClip.html"
    },
    "dspcol": {
      "name": "DspCol",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Color"
      ],
      "doc": "DspCol is deprecated in this version of Plant SCADA",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, Color": "DspCol(nAN, Color)",
        "nAN": "The animation-point number.",
        "Color": "The color to display at the AN."
      },
      "helpPath": "DspCol.html"
    },
    "dspdel": {
      "name": "DspDel",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Deletes all objects from a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspDel(nAN)"
      },
      "helpPath": "DspDel.html"
    },
    "dspdelayrenderbegin": {
      "name": "DspDelayRenderBegin",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Delays screen updating until DspDelayRenderEnd is called. This function should be used with DspDelayRenderEnd() to \"sandwich\" Cicode that will modify the appearance of a page.",
      "paramDocs": {},
      "helpPath": "DspDelayRenderBegin.html"
    },
    "dspdelayrenderend": {
      "name": "DspDelayRenderEnd",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Ends the screen update delay set by DspDelayRenderBegin. This function should be used with DspDelayRenderBegin() to \"sandwich\" Cicode that will modify the appearance of a page.",
      "returns": "No value is returned.",
      "paramDocs": {},
      "helpPath": "DspDelayRenderEnd.html"
    },
    "dspdirty": {
      "name": "DspDirty",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Forces Plant SCADA to update an AN. Normally, Plant SCADA updates the animation on the AN only if the data has changed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "DspDirty(nAN)"
      },
      "helpPath": "DspDirty.html"
    },
    "dsperror": {
      "name": "DspError",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Displays an error message at the prompt AN on the operator's computer.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "String": "DspError(String)"
      },
      "helpPath": "DspError.html"
    },
    "dspfile": {
      "name": "DspFile",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "hFont",
        "Height",
        "Width"
      ],
      "doc": "Defines the screen attributes for displaying a text file. This function defines a \"window\" where the file will be displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, hFont, Height, Width": "DspFile(nAN, hFont, Height, Width)",
        "nAN": "The AN where the file display window will be positioned. When this is set to -2, the window will be created in the Runtime Kernel. However, the hFont argument is ignored.",
        "hFont": "The handle for the font that is used to display the file, returned from the DspFont() or DspFontHnd() function. The font handle identifies the table where data on the associated font is stored.",
        "Height": "The maximum number of lines to display on one page of the file display window.",
        "Width": "The width of the file display window, in characters."
      },
      "helpPath": "DspFile.html"
    },
    "dspfilegetinfo": {
      "name": "DspFileGetInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Type"
      ],
      "doc": "Gets the attributes of a file-to-screen display (used for displaying text files).",
      "returns": "The attributes of the \"window\" as an integer. If an incorrect AN is specified, an error is returned.",
      "paramDocs": {
        "0": "The width of the file display window, in characters.",
        "1": "The maximum number of lines that can display in one page of the file display window.",
        "2": "The file-to-screen row offset number.",
        "3": "The file-to-screen column offset number.",
        "4": "The number of lines in the displayed file.",
        "nAN, Type": "DspFileGetInfo(nAN, Type)",
        "nAN": "The AN where the file display window will be located. This AN needs to be the same as the AN specified with the DspFile() function.",
        "nType": "The type of data required:"
      },
      "helpPath": "DspFileGetInfo.html"
    },
    "dspfilegetname": {
      "name": "DspFileGetName",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the name of the file being displayed in the display \"window\".",
      "returns": "The name of the file (as a string). If an incorrect AN is specified, an error is returned.",
      "paramDocs": {
        "nAN": "DspFileGetName(nAN)"
      },
      "helpPath": "DspFileGetName.html"
    },
    "dspfilescroll": {
      "name": "DspFileScroll",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Direction",
        "Characters"
      ],
      "doc": "Scrolls a file (displayed in the display \"window\") by a number of characters.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "1": "Left",
        "2": "Right",
        "3": "Up",
        "4": "Down",
        "nAN, Direction, Characters": "DspFileScroll(nAN, Direction, Characters)",
        "nAN": "The animation-point number.",
        "Direction": "The direction in which to scroll:",
        "Characters": "The number of characters to scroll. To page up or page down through the file, scroll by the height of the file-to-screen window (returned by DspFileGetInfo(AN, 1))."
      },
      "helpPath": "DspFileScroll.html"
    },
    "dspfilesetname": {
      "name": "DspFileSetName",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sName"
      ],
      "doc": "Sets the name of the file to display in the display \"window\".",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, sName": "DspFileSetName(nAN, sName)",
        "nAN": "The animation-point number.",
        "sName": "The name of the file to display."
      },
      "helpPath": "DspFileSetName.html"
    },
    "dspfont": {
      "name": "DspFont",
      "returnType": "UNKNOWN",
      "params": [
        "FontType",
        "PixelSize",
        "ForeOnColor",
        "BackOnColor [",
        "ForeOffColor] [",
        "BackOffColor]"
      ],
      "doc": "Creates a font and returns a font handle.",
      "returns": "The font handle as an integer. If the font cannot be created, -1 is returned. The font handle identifies the table where all data on the associated font is stored.",
      "paramDocs": {
        "FontType, PixelSize, ForeOnColor, BackOnColor [, ForeOffColor] [, BackOffColor]": "DspFont(FontType, PixelSize, ForeOnColor, BackOnColor [, ForeOffColor] [, BackOffColor] )",
        "FontType": "The font type, for example, \"Helv\".",
        "PixelSize": "The font size, as a positive number for pixels, or a negative number for points.",
        "ForeOnColor": "The foreground color used for the text. If implementing flashing color, this is the initial color that will be used. Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "BackOnColor": "The color used for the background of text. If implementing flashing color, this is the initial color that will be used. Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "ForeOffColor": "An optional argument only required if implementing flashing color for the font foreground. It represents the secondary color used. Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "BackOffColor": "An optional argument only required if implementing flashing color for the font background. It represents the secondary color used. Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour."
      },
      "helpPath": "DspFont.html"
    },
    "dspfonthnd": {
      "name": "DspFontHnd",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Gets the font handle of a font that is defined in the Fonts database.",
      "returns": "The font handle as an integer. If the font cannot be found, -1 is returned. The font handle identifies the table where the data on the associated font is stored.",
      "paramDocs": {
        "sName": "DspFontHnd(sName)",
        "Name": "The font name in the fonts database."
      },
      "helpPath": "DspFontHnd.html"
    },
    "dspfullscreen": {
      "name": "DspFullScreen",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "Disables or enables the fullscreen mode of the currently active window.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Disable fullscreen mode.",
        "1": "Enable fullscreen mode without title bar",
        "2": "Enable fullscreen mode with title bar.",
        "Mode": "DspFullScreen(Mode)"
      },
      "helpPath": "DspFullScreen.html"
    },
    "dspgetanbottom": {
      "name": "DspGetAnBottom",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the bottom extent of the object at the specified AN.",
      "returns": "The y coordinate of the bottom extent of the object at the AN. If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnBottom(nAN)"
      },
      "helpPath": "DspGetAnBottom.html"
    },
    "dspgetancur": {
      "name": "DspGetAnCur",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the AN of the current graphics object.",
      "returns": "The AN associated with the current graphics object. If this function is called outside the page animation system or from an input/command field, -1 will be returned.",
      "paramDocs": {},
      "helpPath": "DspGetAnCur.html"
    },
    "dspgetanextent": {
      "name": "DspGetAnExtent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Top",
        "Left",
        "Bottom",
        "Right"
      ],
      "doc": "Gets the extent of the object (the enclosing boundary) at the specified AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned. The Top, Left, Bottom, and Right arguments contain the extents of the object, in pixels.",
      "paramDocs": {
        "nAN, Top, Left, Bottom, Right": "DspGetAnExtent(nAN, Top, Left, Bottom, Right)",
        "nAN": "The AN at which the object is positioned.",
        "Top": "A buffer that contains the top-most extent of the object.",
        "Left": "A buffer that contains the left-most extent of the object.",
        "Bottom": "A buffer that contains the bottom-most extent of the object.",
        "Right": "A buffer that contains the right-most extent of the object."
      },
      "helpPath": "DspGetAnExtent.html"
    },
    "dspgetanfirst": {
      "name": "DspGetAnFirst",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the first AN on the current page, based on the order in which the ANs were stored by Graphics Builder.",
      "returns": "The value for the first AN, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "DspGetAnFirst.html"
    },
    "dspgetanfromname": {
      "name": "DspGetAnFromName",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Name used to retrieve the AN of an object on the page.",
      "returns": "AN of object or -1 if not found.",
      "paramDocs": {
        "sName": "DspGetAnFromName(sName)"
      },
      "helpPath": "DspGetAnFromName.html"
    },
    "dspgetanfromnamerelative": {
      "name": "DspGetAnFromNameRelative",
      "returnType": "UNKNOWN",
      "params": [
        "hAN",
        "sName"
      ],
      "doc": "Name used to retrieve the AN of an object on the page.",
      "returns": "AN of object or -1 if not found.",
      "paramDocs": {
        "hAN": "DspGetAnFromNameRelative(hAN, sName)"
      },
      "helpPath": "DspGetAnFromNameRelative.html"
    },
    "dspgetanfrompoint": {
      "name": "DspGetAnFromPoint",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y [",
        "PrevAN]"
      ],
      "doc": "Gets the AN of the object at a specified set of screen coordinates.",
      "returns": "The AN or 0 (zero) if no object exists at the point.",
      "paramDocs": {
        "X, Y [, PrevAN]": "DspGetAnFromPoint(X, Y [, PrevAN] )",
        "X": "The x coordinate of the screen point.",
        "Y": "The y coordinate of the screen point.",
        "PrevnAN": "Retrieves the previous AN (in z-order) in situations where a number of objects overlap at the specified point. The default of 0 (zero) specifies no previous AN. A non-zero value should only ever be passed if it is the result of a previous call to DspGetAnFromPoint."
      },
      "helpPath": "DspGetAnFromPoint.html"
    },
    "dspgetanheight": {
      "name": "DspGetAnHeight",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the height of the object at a specified AN.",
      "returns": "The height of the object (in pixels). If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnHeight(nAN)"
      },
      "helpPath": "DspGetAnHeight.html"
    },
    "dspgetanleft": {
      "name": "DspGetAnLeft",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the left extent of the object at the specified AN.",
      "returns": "The x coordinate of the left extent of the object at the AN. If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnLeft(nAN)"
      },
      "helpPath": "DspGetAnLeft.html"
    },
    "dspgetannext": {
      "name": "DspGetAnNext",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Returns the AN that follows the specified AN, based on the order in which the ANs were stored on a page by Graphics Builder.",
      "returns": "The value for the next AN. If -1 is returned, it means the specified AN is invalid or it is the last AN on the page.",
      "paramDocs": {
        "nAN": "DspGetAnNext(nAN)"
      },
      "helpPath": "DspGetAnNext.html"
    },
    "dspgetanrawextent": {
      "name": "DspGetAnRawExtent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Top",
        "Left",
        "Bottom",
        "Right"
      ],
      "doc": "Gets the extent of the object from the graphics page at the specified AN. The extent represents the page co-ordinates at which the object was originally inserted.",
      "returns": "0 (zero) if successful, otherwise an error is returned. The Top, Left, Bottom, and Right arguments contain the extents of the object, in pixels.",
      "paramDocs": {
        "nAN, Top, Left, Bottom, Right": "DspGetAnRawExtent(nAN, Top, Left, Bottom, Right)",
        "nAN": "The AN at which the object is positioned.",
        "Top": "A buffer that contains the top-most extent of the object.",
        "Left": "A buffer that contains the left-most extent of the object.",
        "Bottom": "A buffer that contains the bottom-most extent of the object.",
        "Right": "A buffer that contains the right-most extent of the object."
      },
      "helpPath": "DspGetAnRawExtent.htm"
    },
    "dspgetanright": {
      "name": "DspGetAnRight",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the right extent of the object at the specified AN.",
      "returns": "The x coordinate of the right extent of the object at the AN. If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnRight(nAN)"
      },
      "helpPath": "DspGetAnRight.html"
    },
    "dspgetantop": {
      "name": "DspGetAnTop",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the top extent of the object at the specified AN.",
      "returns": "The y coordinate of the top extent of the object at the AN. If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnTop(nAN)"
      },
      "helpPath": "DspGetAnTop.html"
    },
    "dspgetanwidth": {
      "name": "DspGetAnWidth",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the width of the object at a specified AN.",
      "returns": "The width of the object (in pixels). If no object exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetAnWidth(nAN)"
      },
      "helpPath": "DspGetAnWidth.html"
    },
    "dspgetenv": {
      "name": "DspGetEnv",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Gets a page environment variable.",
      "returns": "The value of the variable (as a string).",
      "paramDocs": {
        "sName": "DspGetEnv(sName)"
      },
      "helpPath": "DspGetEnv.html"
    },
    "dspgetmetadatafromname": {
      "name": "DspGetMetadataFromName",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sMetaName"
      ],
      "doc": "Name used to retrieve the metadata of an object on the page.",
      "returns": "The value of the metadata or blank.",
      "paramDocs": {
        "sName": "DspGetMetadataFromName(sName, sMetaName)"
      },
      "helpPath": "DspGetMetadataFromName.html"
    },
    "dspgetmetadatafromnamerelative": {
      "name": "DspGetMetadataFromNameRelative",
      "returnType": "UNKNOWN",
      "params": [
        "hAN",
        "sName",
        "sMetaName"
      ],
      "doc": "Name used to retrieve the metadata of an object on the page relative to a given AN.",
      "returns": "The value of the metadata or blank.",
      "paramDocs": {
        "hAN": "DspGetMetadataFromNameRelative(hAN, sName, sMetaName)"
      },
      "helpPath": "DspGetMetadataFromNameRelative.html"
    },
    "dspgetmouse": {
      "name": "DspGetMouse",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y"
      ],
      "doc": "Gets the x and y coordinates of the mouse position, relative to the top left corner of the window.",
      "returns": "0 (zero) if successful, otherwise an error is returned. The X and Y variables are set to the mouse position.",
      "paramDocs": {
        "X, Y": "DspGetMouse(X, Y)",
        "X": "A locally declared variable used to store the x pixel coordinate of the mouse position, returned from this function.",
        "Y": "A locally declared variable used to store the y pixel coordinate of the mouse position, returned from this function."
      },
      "helpPath": "DspGetMouse.html"
    },
    "dspgetmouseover": {
      "name": "DspGetMouseOver",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Determines if the mouse is within the boundaries of a given AN.",
      "returns": "1 if within the specified AN, 0 if not.",
      "paramDocs": {
        "nAN": "DspGetMouseOver(nAN)"
      },
      "helpPath": "DspGetMouseOver.html"
    },
    "dspgetnamefroman": {
      "name": "DspGetNameFromAn",
      "returnType": "UNKNOWN",
      "params": [
        "hAN"
      ],
      "doc": "Using a valid AN the animation name of the object is returned.",
      "returns": "The animation name of the object, or blank",
      "paramDocs": {
        "hAN": "DspGetNameFromAn(hAN)"
      },
      "helpPath": "DspGetNameFromAn.html"
    },
    "dspgetnearestan": {
      "name": "DspGetNearestAn",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y"
      ],
      "doc": "Gets the AN nearest to a specified x,y pixel location.",
      "returns": "The animation point number (AN). A value of -1 is returned if no AN is found.",
      "paramDocs": {
        "X, Y": "DspGetNearestAn(X, Y)",
        "X": "The x coordinate (in pixels).",
        "Y": "The y coordinate (in pixels)."
      },
      "helpPath": "DspGetNearestAn.html"
    },
    "dspgetparentan": {
      "name": "DspGetParentAn",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the parent animation number (if any), for the specified animation number. AN animation point will have a parent animation point if it corresponds to an object in a group.",
      "returns": "The parent animation point number (AN). If no parent animation exists or an invalid animation number is passed, 0 (zero) is returned.",
      "paramDocs": {
        "nAN": "DspGetParentAn(nAN)",
        "AN": "The animation-point number."
      },
      "helpPath": "DspGetParentAn.html"
    },
    "dspgetslider": {
      "name": "DspGetSlider",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the current position (value) of a slider at an AN. You can call this function in the slider event to find the new position of the slider.",
      "returns": "The value of the slider from 0 to 32000. If no animation exists at the AN, -1 is returned.",
      "paramDocs": {
        "nAN": "DspGetSlider(nAN)"
      },
      "helpPath": "DspGetSlider.html"
    },
    "dspgettip": {
      "name": "DspGetTip",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Mode"
      ],
      "doc": "Gets the tool tip text associated with an AN.",
      "returns": "The tool tip text (as a string). If no user tip is available, an empty string is returned.",
      "paramDocs": {
        "nAN": "DspGetTip(nAN, Mode)",
        "Mode": "0 - Tool tips from all animation records configured at the AN. Tips are concatenated with a newline character between each string. (This mode is only used for V3.xx and V4.xx animations, and has been subsequently superseded.)"
      },
      "helpPath": "DspGetTip.html"
    },
    "dspgraybutton": {
      "name": "DspGrayButton",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nMode"
      ],
      "doc": "Grays and disables a button. If the button is a symbol, the symbol is overwritten with a gray mask.",
      "returns": "0 (zero) if successful, otherwise, -1 (if no AN is found).",
      "paramDocs": {
        "0": "Ungray the button.",
        "1": "(GRAY_SUNK) Recess the text or symbol (the text or symbol on the button is recessed and shadowed).",
        "2": "(GRAY_PART) This mode is now obsolete - it now has the same effect as GRAY_ALL.",
        "3": "(GRAY_ALL) - Mask the entire button (a gray mask displays over the face of the button).",
        "nAN, nMode": "DspGrayButton(nAN, nMode)",
        "nAN": "The AN where the button is located.",
        "nMode": "The mode of the operation:"
      },
      "helpPath": "DspGrayButton.html"
    },
    "dspinfo": {
      "name": "DspInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hInfo",
        "Type",
        "Index"
      ],
      "doc": "Extracts individual pieces of object information from an AN.",
      "returns": "The object information (as a string). A blank string is returned if you specify a non-existent expression or variable.",
      "paramDocs": {
        "0": "Object title (the name of the object type)",
        "1": "Object expression text",
        "2": "Object expression result text",
        "3": "The variable tag name",
        "4": "Not supported.",
        "5": "The engineering value associated with the variable",
        "6": "The Cicode context. Calling DspInfo with this Type will return a string describing the context in which the Cicode expression is contained. For example, if it appears on the horizontal movement tab it would return \"Move X\".",
        "7": "The number of Cicode expressions. Calling DspInfo with this Type will return the number of Cicode expressions associated with this animation point.",
        "8": "The number of tags in the expression. Calling DspInfo with this Type will return the number of tags that appear in the given Cicode expression.",
        "9": "Name of the cluster in which the variable tag resides.",
        "10": "Full name of the variable tag in the form cluster.tagname.",
        "hInfo, Type, Index": "DspInfo(hInfo, Type, Index)",
        "hInfo": "The object information block handle, as returned by DspInfoNew(). This handle identifies the table (or block) where all object data is stored.",
        "nType": "The type of data to extract:",
        "Index": "An index to the variable within the information block. The required index changes according to the Type as follows:"
      },
      "helpPath": "DspInfo.html"
    },
    "dspinfodestroy": {
      "name": "DspInfoDestroy",
      "returnType": "UNKNOWN",
      "params": [
        "hInfo"
      ],
      "doc": "Destroys an object information block created by DspInfoNew(). You should destroy an object information block when you no longer need it.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hInfo": "DspInfoDestroy(hInfo)"
      },
      "helpPath": "DspInfoDestroy.html"
    },
    "dspinfofield": {
      "name": "DspInfoField",
      "returnType": "UNKNOWN",
      "params": [
        "hInfo",
        "sTag",
        "sField [",
        "sClusterName]"
      ],
      "doc": "Obtains static and real-time data from a variable tag. You get static data from the Variable Tags database.",
      "returns": "The data (as a string).",
      "paramDocs": {
        "hInfo": "Obtains static and real-time data from a variable tag. You get static data from the Variable Tags database. The additional field \"Eng_Value\", returns dynamic real-time data for the variable tag. To get this real-time data, you need to first call the DspInfoNew() function to get the information block handle hInfo.",
        "sScaleMode": "Getting the raw value of a variable tag using DspInfoField is no longer supported. To get the raw value of a tag, use the TagSubscribe function, specifying a value of \"Raw\" for the sScaleMode parameter. When using TagSubscribe, you can either call SubscriptionGetAttribute to obtain the value whenever required or register callback cicode function to run when the value changes. See TagSubscribe for more details.",
        "hInfo, sTag, sField [, sClusterName]": "DspInfoField(hInfo, sTag, sField [, sClusterName] )",
        "sTag": "The name of the variable tag. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\". This argument does not support arrays. If array syntax is used, the information will be retrieved for only the tag name.",
        "sField": "The name of the field from which to extract the data:",
        "Cluster": "Name of the cluster in which the Tag resides",
        "Comment -": "Variable tag comment",
        "Eng_Full -": "Engineering Full Scale",
        "Eng_Zero -": "Engineering Zero Scale",
        "Eng_Units -": "Engineering Units",
        "Eng_Value -": "Scaled engineering value - Dynamic",
        "Field -": "Description",
        "FullName": "Full name of the tag in the form cluster.tagname.",
        "Name -": "Variable Tag Name",
        "Type -": "Data Type",
        "Unit -": "I/O Device Name",
        "sClusterName": "Specifies the name of the cluster in which the Tag resides. This is optional if you have one cluster or are resolving the tag via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "DspInfoField.html"
    },
    "dspinfonew": {
      "name": "DspInfoNew",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Creates an object information block. Use this function with the associated low-level animation information functions to get and process object information on an AN.",
      "returns": "The object information block handle. If no object data is available, then -1 is returned.",
      "paramDocs": {
        "nAN": "DspInfoNew(nAN)"
      },
      "helpPath": "DspInfoNew.html"
    },
    "dspinfovalid": {
      "name": "DspInfoValid",
      "returnType": "UNKNOWN",
      "params": [
        "hInfo"
      ],
      "doc": "Checks if an object information block handle is valid. An object information block handle becomes invalid after it is destroyed, or if the user closes the page it is associated with.",
      "returns": "1 if the information block handle is valid, otherwise 0 (zero).",
      "paramDocs": {
        "hInfo": "DspInfoValid(hInfo)"
      },
      "helpPath": "DspInfoValid.html"
    },
    "dspisbuttongray": {
      "name": "DspIsButtonGray",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the current status of a button.",
      "returns": "The current mode of the button:",
      "paramDocs": {
        "nAN": "DspIsButtonGray(nAN)"
      },
      "helpPath": "DspIsButtonGray.html"
    },
    "dspkernel": {
      "name": "DspKernel",
      "returnType": "UNKNOWN",
      "params": [
        "nMode"
      ],
      "doc": "Displays the Kernel window and prompts the user to login as the 'kernel' user.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Hide the Kernel",
        "1": "Display the Kernel. If the Kernel is already displayed and nMode=1, the keyboard focus is changed to the Kernel.",
        "nMode": "DspKernel(nMode)"
      },
      "helpPath": "DspKernel.html"
    },
    "dspmarkermove": {
      "name": "DspMarkerMove",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "hMarker",
        "Offset"
      ],
      "doc": "Moves a trend or chart marker to a specified position.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, hMarker, Offset": "DspMarkerMove(nAN, hMarker, Offset)",
        "nAN": "The AN where the trend or chart is positioned.",
        "hMarker": "The marker handle, as returned from the DspMarkerNew() function. The marker handle identifies the table where all data on the associated marker is stored.",
        "Offset": "The offset by which to move the marker. Vertical markers have an offset from 0 (zero) to the maximum number of samples in the trend. Horizontal markers have a offset of 0 (zero) to 32000."
      },
      "helpPath": "DspMarkerMove.html"
    },
    "dspmarkernew": {
      "name": "DspMarkerNew",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Mode",
        "Color"
      ],
      "doc": "Creates a new trend marker. A trend marker is used to show cursor values or limits on a trend. You can use up to 10 markers on a single trend or chart.",
      "returns": "The marker handle, or -1 if the function is unsuccessful. The marker handle identifies the table where data on the associated marker is stored.",
      "paramDocs": {
        "0": "A vertical marker",
        "1": "A horizontal marker",
        "Window": "If you add markers to a trend or chart that Plant SCADA is animating, you need to repaint them using the trend paint event (OnEvent(Window,22)). (Otherwise Plant SCADA will delete any markers displayed when the trend is updated.)",
        "nAN, Mode, Color": "DspMarkerNew(nAN, Mode, Color)",
        "nAN": "The animation-point number.",
        "Mode": "The mode of the marker:",
        "Color": "The color of the marker (flashing color not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB color using the function MakeCitectColour."
      },
      "helpPath": "DspMarkerNew.html"
    },
    "dspmci": {
      "name": "DspMCI",
      "returnType": "UNKNOWN",
      "params": [
        "sCommand"
      ],
      "doc": "Controls a multimedia device using MCI. The Media Control Interface (MCI) is a high-level command interface to multimedia devices and resource files.",
      "returns": "A string message with the status of the MCI command.",
      "paramDocs": {
        "Multimedia Programmer's Guide": "Using this function, you can control multimedia devices by using simple commands like open, play, and close. MCI commands are a generic interface to multimedia devices. You can control any supported multimedia device, including audio playback and recording. For a full overview of MCI, see the Windows Multimedia Programmer's Guide.",
        "sCommand": "DspMCI(sCommand)"
      },
      "helpPath": "DspMCI.html"
    },
    "dspplaysound": {
      "name": "DspPlaySound",
      "returnType": "UNKNOWN",
      "params": [
        "sSoundname",
        "nMode"
      ],
      "doc": "Plays a waveform (sound).",
      "returns": "TRUE if successful, otherwise FALSE (if an error is detected).",
      "paramDocs": {
        "sSoundname": "When the sSoundname is a sound file path and Mode is 0, this function loads the .wav file from the specified path (Sound Files) and plays the associated waveform. If the specified sound file is not available in the mentioned path, an error message will be returned and a hardware alarm will be reported. Use of a system sound in this mode is not supported and will result in an error message and a hardware alarm.",
        "sSoundname, nMode": "DspPlaySound(sSoundname, nMode)",
        "nMode": "Mode 0: For use when the sSoundname is a sound file path."
      },
      "helpPath": "DspPlaySound.html"
    },
    "dsppopupconfigmenu": {
      "name": "DspPopupConfigMenu",
      "returnType": "UNKNOWN",
      "params": [
        "hParent",
        "[",
        "bNonRecursive [",
        "XPos [",
        "YPos]]]"
      ],
      "doc": "Displays the contents of a menu node as a pop-up (context) menu, and run the command associated with the selected menu item.",
      "returns": "0 if the selected meun command is run or error code if menu command cannot run.",
      "paramDocs": {
        "(hParent, [, bNonRecursive [, XPos [, YPos]]])": "DspPopupConfigMenu(hParent, [, bNonRecursive [, XPos [, YPos]]])",
        "hParent": "hParent",
        "bNonRecursive": "bNonRecursive",
        "XPos": "XPos",
        "YPos": "YPos"
      },
      "helpPath": "DspPopupConfigMenu.html"
    },
    "dsppopupmenu": {
      "name": "DspPopupMenu",
      "returnType": "UNKNOWN",
      "params": [
        "iMenuNumber",
        "sMenuItems [",
        "XPos] [",
        "YPos]"
      ],
      "doc": "Creates a popup menu consisting of a number of menu items.",
      "returns": "The selected menu item as an integer. This comprises the menu number (return value div 100), and the position of the item in the menu (return value mod 100). For example, a return value of 201 indicates that the first item in Menu 2 was selected, and a return value of 3 indicates that the third item in Menu 0 was selected.",
      "paramDocs": {
        "iMenuNumber, sMenuItems [, XPos] [, YPos]": "DspPopupMenu(iMenuNumber, sMenuItems [, XPos] [, YPos] )",
        "iMenuNumber": "An integer representing the menu you are adding items to. The first menu created is Menu 0. If left unspecified, this parameter defaults to -1, causing the menu to be displayed on the screen.",
        "sMenuItems": "A comma-separated string defining the items in each menu. The default value for this parameter is an empty string, which will get passed to the function in the call to display the menu.",
        "XPos": "The x-coordinate (relative to the page) at which the menu will be displayed. This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position.",
        "YPos": "The y-coordinate (relative to the page) at which the menu will be displayed. This parameter is optional. If it is left unspecified, the menu will display at the cursor's current position."
      },
      "helpPath": "DspPopupMenu.html"
    },
    "dsprichtext": {
      "name": "DspRichText",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "iHeight",
        "iWidth",
        "nMode"
      ],
      "doc": "Creates a Rich Text object of the given dimensions at the animation point nAN.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Creates a Rich Text object of the given dimensions at the animation point nAN. This object can then be used to display an RTF file (like an RTF report) called using the DspRichTextLoad function.",
        "nAN, iHeight, iWidth, nMode": "DspRichText(nAN, iHeight, iWidth, nMode)",
        "iHeight": "The height of the rich text object in pixels. The height is established by measuring down from the animation point.",
        "iWidth": "The width of the rich text object in pixels. The width is established by measuring across to the right from the animation point.",
        "nMode": "The display mode for the rich text object. The mode can be any combination of:"
      },
      "helpPath": "DspRichText.html"
    },
    "dsprichtextedit": {
      "name": "DspRichTextEdit",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "bEdit"
      ],
      "doc": "Enables editing of the contents of the rich text object at nAN if nEdit = TRUE, and disables editing if nEdit = FALSE.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Enables editing of the contents of the rich text object at nAN if nEdit = TRUE, and disables editing if nEdit = FALSE.",
        "nAN, bEdit": "DspRichTextEdit(nAN, bEdit)",
        "bEdit": "The value of this argument determines whether you will be able to edit the contents of the rich text object at AN. Enter TRUE to enable editing, or enter FALSE to make the contents read-only."
      },
      "helpPath": "DspRichTextEdit.html"
    },
    "dsprichtextenable": {
      "name": "DspRichTextEnable",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "bEnable"
      ],
      "doc": "Enables the rich text object at nAN if nEnable = TRUE, and disables the object if nEnable = FALSE. When the object is disabled, its contents cannot be selected or copied etc.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Enables the rich text object at nAN if nEnable = TRUE, and disables the object if nEnable = FALSE. When the object is disabled, its contents cannot be selected or copied etc.",
        "nAN, bEnable": "DspRichTextEnable(nAN, bEnable)",
        "bEnable": "The value of this argument determines whether the rich text object at AN will be enabled or disabled. Enter TRUE to enable the object (that is you can select and copy the contents of the RTF object, but you can't make changes). Enter FALSE to disable the object (that is make it display only)."
      },
      "helpPath": "DspRichTextEnable.html"
    },
    "dsprichtextgetinfo": {
      "name": "DspRichTextGetInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "iType"
      ],
      "doc": "Retrieves size information about the rich text object at animation point nAN.",
      "returns": "The requested information as a string (units = pixels).",
      "paramDocs": {
        "0": "Height",
        "1": "Width",
        "nAN": "Retrieves size information about the rich text object at animation point nAN.",
        "nAN, iType": "DspRichTextGetInfo(nAN, iType)",
        "iType": "The following size information (in pixels) can be returned about the specified rich text object:"
      },
      "helpPath": "DspRichTextGetInfo.html"
    },
    "dsprichtextload": {
      "name": "DspRichTextLoad",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sFilename"
      ],
      "doc": "Loads a copy of the file Filename into the rich text object) at animation point nAN.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "Filename": "Loads a copy of the file Filename into the rich text object) at animation point nAN. (The rich text object may have been created using either the DspRichTextLoad function or the PageRichTextFile function.)",
        "nAN, sFilename": "DspRichTextLoad(nAN, sFilename)",
        "nAN": "The animation point at which a copy of the rich text file (for example, an RTF report) will display. This AN needs to match that of a rich text object (created using either the DspRichText function, or the PageRichTextFile function), or the copy of the file will not be loaded into anything, and will not display.",
        "sFilename": "The name of the file to be copied and loaded into the rich text object at the specified animation point. The filename needs to be entered in quotation marks \"\"."
      },
      "helpPath": "DspRichTextLoad.html"
    },
    "dsprichtextpgscroll": {
      "name": "DspRichTextPgScroll",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "iDirection"
      ],
      "doc": "Scrolls the contents of the rich text object displayed at nAN, by one page length in the direction given in direction.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "1": "Left",
        "2": "Right",
        "3": "Up",
        "4": "Down",
        "8": "Scroll to top",
        "16": "Scroll to bottom",
        "nAN": "Scrolls the contents of the rich text object displayed at nAN, by one page length in the direction given in direction.",
        "nAN, iDirection": "DspRichTextPgScroll(nAN, iDirection)",
        "iDirection": "The direction in which you want to scroll each time this function is run. You can choose from the following:"
      },
      "helpPath": "DspRichTextPgScroll.html"
    },
    "dsprichtextprint": {
      "name": "DspRichTextPrint",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sPortName"
      ],
      "doc": "Prints the contents of the rich text object at animation point nAN, to the port PortName.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Prints the contents of the rich text object at animation point nAN, to the port PortName.",
        "nAN, sPortName": "DspRichTextPrint(nAN, sPortName)",
        "sPortName": "The name of the printer port to which the contents of the rich text object will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer."
      },
      "helpPath": "DspRichTextPrint.html"
    },
    "dsprichtextsave": {
      "name": "DspRichTextSave",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sFilename"
      ],
      "doc": "Saves the contents of the rich text object at animation point nAN, to the file Filename.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Saves the contents of the rich text object at animation point nAN, to the file Filename.",
        "nAN, sFilename": "DspRichTextSave(nAN, sFilename)",
        "sFilename": "The name under which the contents of the rich text object will be saved. This name needs to be enclosed within quotation marks \"\", and needs to include the destination path. For example \"[Data]\\saved.rtf\"."
      },
      "helpPath": "DspRichTextSave.html"
    },
    "dsprichtextscroll": {
      "name": "DspRichTextScroll",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "iDirection",
        "iAmount"
      ],
      "doc": "Scrolls the contents of the rich text object displayed at nAN.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN": "Scrolls the contents of the rich text object displayed at nAN, in the direction given in direction, by the number of lines/units given in amount. Remember that the height of a line varies according to the font used, therefore if you need to scroll absolute distances, it might be advisable to use the DspRichTextPgScroll function.",
        "nAN, iDirection, iAmount": "DspRichTextScroll(nAN, iDirection, iAmount)",
        "iDirection": "The direction in which you want to scroll each time this function is run. You can choose from the following:",
        "iAmount": "The amount by which you would like to scroll each time this function is run. Enter the number of lines (for a vertical direction) or units (for a horizontal direction) by which you would like to scroll."
      },
      "helpPath": "DspRichTextScroll.html"
    },
    "dsprubend": {
      "name": "DspRubEnd",
      "returnType": "UNKNOWN",
      "params": [
        "x",
        "y",
        "cx",
        "cy"
      ],
      "doc": "Ends the rubber band selection, and returns the coordinates of the rubber band selection.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "cx": "Ends the rubber band selection, and returns the coordinates of the rubber band selection. The meaning of the cx and cy values depend on the nMode you specify in the DspRubStart() function.",
        "x, y, cx, cy": "DspRubEnd(x, y, cx, cy)",
        "x,y": "The x and y coordinates of the start position. Must be a Long type variable.",
        "cx,cy": "The x and y coordinates of the end position. Must be a Long type variable."
      },
      "helpPath": "DspRubEnd.html"
    },
    "dsprubmove": {
      "name": "DspRubMove",
      "returnType": "UNKNOWN",
      "params": [
        "x",
        "y"
      ],
      "doc": "Moves the rubber band selection to the new position. You need to first have defined a rubber band selection using the DspRubStart() and DspRubEnd() functions.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "x, y": "DspRubMove(x, y)",
        "x,y": "The x and y coordinates of the current position."
      },
      "helpPath": "DspRubMove.html"
    },
    "dsprubsetclip": {
      "name": "DspRubSetClip",
      "returnType": "UNKNOWN",
      "params": [
        "x1",
        "y1",
        "x2",
        "y2"
      ],
      "doc": "Sets the clipping region for the rubber band display. If you enable the clipping region, the rubber band will not move outside of the clip region.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "x1, y1, x2, y2": "DspRubSetClip(x1, y1, x2, y2)",
        "x1,y1,x2,y2": "The x and y coordinates of the clipping region."
      },
      "helpPath": "DspRubSetClip.html"
    },
    "dsprubstart": {
      "name": "DspRubStart",
      "returnType": "UNKNOWN",
      "params": [
        "x",
        "y",
        "nMode"
      ],
      "doc": "Starts the rubber band selection. Call this function when the left mouse button is pressed - the rubber band is displayed at the starting position.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "cx,cy as absolute pixel positions",
        "1": "cx,cy in pixels relative to x,y",
        "2": "(x,y) the distance from top left to (cx,cy)",
        "4": "enable the rubber band selection using the clipping region defined by DspRubSetClip().",
        "x, y, nMode": "DspRubStart(x, y, nMode)",
        "x,y": "The x and y coordinates of the current position.",
        "nMode": "The mode of the rubber banding operation:"
      },
      "helpPath": "DspRubStart.html"
    },
    "dspsetclip": {
      "name": "DspSetClip",
      "returnType": "UNKNOWN",
      "params": [
        "INT nAN",
        "INT nLeft",
        "INT nTop",
        "INT nRight",
        "INT nBottom"
      ],
      "doc": "Sets the clip rectangle for an AN, defined by the top, left, right and bottom.",
      "returns": "It returns an error if nAN is invalid, or the specified rectangle is invalid i.e. nLeft >= nRight or nTop >= nBottom.",
      "paramDocs": {
        "INT nAN, INT nLeft, INT nTop, INT nRight, INT nBottom": "DspSetClip(INT nAN, INT nLeft, INT nTop, INT nRight, INT nBottom)",
        "nAN": "The animation-point number of the object or group of objects inside the clipping region.",
        "nLeft": "The x coordinate of the left side of the clipping boundary",
        "nTop": "The x coordinate of the top of the clipping boundary",
        "nRight": "The y co-ordinate of the right side of the clip rectangle.",
        "nBottom": "The y co-ordinate of the bottom of the clip rectangle. ."
      },
      "helpPath": "DspSetClip.html"
    },
    "dspsetcurcolor": {
      "name": "DspSetCurColor",
      "returnType": "UNKNOWN",
      "params": [
        "INT CitectColor"
      ],
      "doc": "Sets tool tip text associated with an AN. Any existing text associated with the AN will be replaced with the new text.",
      "returns": "The previous focus rectangle color as an integer.",
      "paramDocs": {
        "CitectColor": "DspSetCurColor(INT CitectColor)"
      },
      "helpPath": "DspSetCurColor.html"
    },
    "dspsetmetadatafromname": {
      "name": "DspSetMetadataFromName",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sMetaName",
        "sValue"
      ],
      "doc": "Name used to set the metadata of an object on the page.",
      "returns": "The value of the metadata or error code.",
      "paramDocs": {
        "sName": "DspSetMetadataFromName(sName, sMetaName, sValue)"
      },
      "helpPath": "DspSetMetadataFromName.html"
    },
    "dspsetmetadatafromnamerelative": {
      "name": "DspSetMetadataFromNameRelative",
      "returnType": "UNKNOWN",
      "params": [
        "hAN",
        "sName",
        "sMetaName",
        "sValue"
      ],
      "doc": "Name used to set the metadata of an object on the page.",
      "returns": "The value of the metadata or error code",
      "paramDocs": {
        "hAN": "DspSetMetadataFromNameRelative(hAN, sName, sMetaName, sValue)"
      },
      "helpPath": "DspSetMetadataFromNameRelative.html"
    },
    "dspsetpopupmenufont": {
      "name": "DspSetPopupMenuFont",
      "returnType": "UNKNOWN",
      "params": [
        "hFont"
      ],
      "doc": "Allows you to set the font and font size for text that appears in popup menus at runtime. For example, you can use this function to adjust the size of the text that appears in context menus so that they will suit a particular screen resolution.",
      "returns": "No return value.",
      "paramDocs": {
        "hFont": "DspSetPopupMenuFont(hFont)"
      },
      "helpPath": "DspSetPopupMenuFont.htm"
    },
    "dspsetslider": {
      "name": "DspSetSlider",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nPos"
      ],
      "doc": "Sets the current position of a slider at the specified AN. You can use this function to move a slider, and adjust the value of the variable associated with the slider.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, nPos": "DspSetSlider(nAN, nPos)",
        "nAN": "The animation-point number.",
        "nPos": "The position of the slider from 0 to 32000 where 0 is the zero position of the slider and 32000 if full position of the slider."
      },
      "helpPath": "DspSetSlider.html"
    },
    "dspsettip": {
      "name": "DspSetTip",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sText"
      ],
      "doc": "Sets tool tip text associated with an AN. Any existing text associated with the AN will be replaced with the new text.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, sText": "DspSetTip(nAN, sText)",
        "nAN": "The animation-point number.",
        "sText": "The tool tip text to set for the AN."
      },
      "helpPath": "DspSetTip.html"
    },
    "dspsettooltipfont": {
      "name": "DspSetTooltipFont",
      "returnType": "UNKNOWN",
      "params": [
        "sName [",
        "nPointSize] [",
        "sAttribs]"
      ],
      "doc": "Sets the font for tool tip text.",
      "returns": "No return value.",
      "paramDocs": {
        "sName [, nPointSize] [, sAttribs]": "DspSetTooltipFont(sName [, nPointSize] [, sAttribs] )",
        "sName": "The name of the Windows font to be used, enclosed by quotation marks \" \". A value for this parameter is required, however specifying an empty string \"\" will set the tooltip font to the default of MS Sans Serif.",
        "nPointSize": "The size of the font in points. If you do not specify a value, the point size defaults to 12.",
        "sAttribs": "A string specifying the format of the font. Use one or all of the following, enclosed by quotation marks \" \":"
      },
      "helpPath": "DspSetTooltipFont.html"
    },
    "dspstatus": {
      "name": "DspStatus",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nMode"
      ],
      "doc": "Determines whether the object at the specified AN will be grayed (hatch pattern) in the event communication attempts are unsuccessful.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, nMode": "DspStatus(nAN, nMode)",
        "nAN": "The animation-point number.",
        "nMode": "0 - Normal display when communication attempts are unsuccessful"
      },
      "helpPath": "DspStatus.html"
    },
    "dspstr": {
      "name": "DspStr",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sFont",
        "sText [",
        "iLength] [",
        "iAlignMode] [",
        "iLengthMode] [",
        "bTooltip]"
      ],
      "doc": "Displays a string at a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nAN, sFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip]": "DspStr(nAN, sFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip])",
        "nAN": "The AN where the text will be displayed.",
        "sFont": "The name of the font that is used to display the text. The Font Name needs to be defined in the Fonts database. If the font is not found, the default font is used.",
        "sText": "The text to display.",
        "iLength": "Length of the text to display, either in characters or pixels depending on Mode (default -1, no truncation)",
        "iAlignMode": "The alignment of the text string:",
        "iLengthMode": "The length mode of the text string:",
        "bTooltip": "Determines if the original text is provided as tool tip when the displayed text becomes truncated."
      },
      "helpPath": "DspStr.html"
    },
    "dspsym": {
      "name": "DspSym",
      "returnType": "UNKNOWN",
      "params": [
        "iAN",
        "sSymbol [",
        "iMode] [",
        "iType]"
      ],
      "doc": "Displays a symbol or a Genie at a specified AN. This dynamically displayed object will disappear at page navigation.",
      "returns": "0 (zero) if successful, otherwise one of the following errors will be returned. A hardware alarm is also raised against DspSym when there is an error message.",
      "paramDocs": {
        "iAN, sSymbol [, iMode] [, iType]": "DspSym(iAN, sSymbol [, iMode] [, iType] )",
        "iAN": "The AN where the symbol will be displayed.",
        "sSymbol": "The name of the symbol to display in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists).",
        "iMode": "Not used. The mode is always set to 1, which means do not erase the existing symbol, just draw the new symbol.",
        "iType": "Symbol Type:"
      },
      "helpPath": "DspSym.html"
    },
    "dspsymanm": {
      "name": "DspSymAnm",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Sym1 [",
        "Sym2 ... Sym8] [",
        "iDisplayMode] [",
        "sSym9]"
      ],
      "doc": "Animates a series of symbols at an AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Sym1": "Animates a series of symbols at an AN. Sym1 displays first, then Sym2, Sym3 . . . Sym8 and then Sym1 displays again, etc. When the next symbol in the sequence is displayed, the current symbol is not erased, but is overwritten to provide a smoother animation. The symbols should all be the same size.",
        "nAN, Sym1 [, Sym2 ... Sym8] [, iDisplayMode] [, sSym9]": "DspSymAnm(nAN, Sym1 [, Sym2 ... Sym8] [, iDisplayMode] [, sSym9] )",
        "nAN": "The AN where the animation will occur.",
        "Sym2..Sym8": "The names of the symbols to animate in frames 2 to 8 in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists).",
        "iDisplayMode": "Not used. Always set to -1, which means Soft animation. The background screen (a rectangular region beneath the symbol) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored. Use this mode when each animation symbol is a different size."
      },
      "helpPath": "DspSymAnm.html"
    },
    "dspsymanmex": {
      "name": "DspSymAnmEx",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Mode",
        "Sym1 [",
        "Sym2 ... Sym9]"
      ],
      "doc": "Animates a series of symbols at an AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Sym1": "Animates a series of symbols at an AN. Sym1 displays first, then Sym2, Sym3 . . . Sym9 and then Sym1 displays again, etc. When the next symbol in the sequence is displayed, the current symbol is not erased, but is overwritten to provide a smoother animation. The symbols should all be the same size.",
        "Mode.": "You only need to call this function once to keep the animation going. To stop the animation call this function again with a different Mode.",
        "nAN, Mode, Sym1 [, Sym2 ... Sym9]": "DspSymAnmEx(nAN, Mode, Sym1 [, Sym2 ... Sym9] )",
        "nAN": "The AN where the animation will occur.",
        "Sym2..Sym9": "The names of the symbols to animate in frames 2 to 9 in the format <[LibName.]SymName>. If you do not specify the library name, a symbol from the Global library will display (if it exists)."
      },
      "helpPath": "DspSymAnmEx.html"
    },
    "dspsymatsize": {
      "name": "DspSymAtSize",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sSym",
        "PositionX",
        "PositionY",
        "SizeX",
        "SizeY",
        "Mode [",
        "Type])"
      ],
      "doc": "Displays a symbol or a genie at the specified scale and offset from the AN position.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Overlap animation. The background screen (beneath the symbol) is not erased - the next symbol is displayed on top. Transparent color is supported in this mode, allowing for symbol overlap. For this mode to display correctly, each symbol needs to be the same size.",
        "1": "Animate animation. The background screen (beneath the symbol) is not erased - the next symbol is displayed on top. This mode provides the fastest animation. For this mode to display correctly, each symbol needs to be the same size. Transparent color is not supported in this mode.",
        "2": "Priority Genie. sSym is interpreted as a priority which is a numeric key in the alarm priority table and the function selects \"Library Name.Genie Name\" from the table.",
        "3": "Priority Genie Thumbnail. sSym is interpreted as a priority which is a numeric key in the alarm priority table and the function selects \"Library Name.Thumbnail Name\" from the table.",
        "4": "Mode Genie. sSym is interpreted as a mode which is a display name in the alarm mode table. The function selects \"Library Genie Name\" from the table.",
        "5": ".Mode Genie Thumbnail. sSym is interpreted as a mode which is a display name in the alarm mode table. The function selects \"Library Genie Name\" from the table.",
        "8": "Stops animation at last symbol displayed. Use this mode where you want to freeze your animation at the end of the sequence.",
        "16": "Stops animation at current symbol displayed. Use this mode where you want to freeze your animation instantly.",
        "nAN, sSym, PositionX, PositionY, SizeX, SizeY, Mode [,Type])": "DspSymAtSize(nAN, sSym, PositionX, PositionY, SizeX, SizeY, Mode [,Type]))",
        "nAN": "The AN where the symbol will be animated.",
        "sSym": "The name of the symbol to display, move, or size. If sSym is 0 (zero), any existing symbol at the AN is erased.",
        "PositionX": "The horizontal offset position (from the AN) of the symbol (in pixels).",
        "PositionY": "The vertical offset position (from the AN) of the symbol (in pixels).",
        "SizeX, SizeY": "The horizontal and vertical scaling factors for the symbol (0 - 32000). For example, if SizeX and SizeY are both 32000, the symbol is displayed at its normal size. Please be aware that symbols can only be reduced in size.",
        "Mode": "The mode of the display:",
        "-1": "Soft animation. The background screen (a rectangular region beneath the symbol) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored. Use this mode when each animation symbol is a different size.",
        "Type": "Symbol Type:"
      },
      "helpPath": "DspSymAtSize.html"
    },
    "dsptext": {
      "name": "DspText",
      "returnType": "UNKNOWN",
      "params": [
        "hAN",
        "iFont",
        "sText [",
        "iLength] [",
        "iAlignMode] [",
        "iLengthMode] [",
        "bTooltip]"
      ],
      "doc": "Displays text at a specified AN location. This function does the same operation as DspStr(), however it uses a font number rather than a font name.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hAN, iFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip]": "DspText(hAN, iFont, sText [, iLength] [, iAlignMode] [, iLengthMode] [, bTooltip])",
        "hAN": "The AN where the text will be displayed.",
        "iFont": "The font number that is used to display the text. (To use the default font, set to -1.)",
        "sText": "The text to display.",
        "iLength": "Length of the Text to display, either in characters or pixels depending on Mode (default -1, no truncation).",
        "iAlignMode": "The alignment of the text string:",
        "iLengthMode": "The length mode of the text string:",
        "bTooltip": "Determines if the original text is provided as tool tip when the displayed text becomes truncated."
      },
      "helpPath": "DspText.html"
    },
    "dsptipmode": {
      "name": "DspTipMode",
      "returnType": "UNKNOWN",
      "params": [
        "nMode"
      ],
      "doc": "Switches the display of tool tips on or off. This function overrides the setting in the [Page]TipHelp parameter.",
      "returns": "The old mode.",
      "paramDocs": {
        "0": "Off",
        "1": "On",
        "2": "Toggle the tool tip mode",
        "3": "Do not change the mode, just return the current value",
        "nMode": "DspTipMode(nMode)"
      },
      "helpPath": "DspTipMode.html"
    },
    "dsptrend": {
      "name": "DspTrend",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Trend",
        "Value1 [",
        "Value2 ... Value8]"
      ],
      "doc": "Displays a trend at an AN. Values are plotted on the trend pens.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Value1": "Displays a trend at an AN. Values are plotted on the trend pens. You need to specify Value1, but Value2 to Value8 are optional. If more values (than configured pens) are specified, the additional values are ignored. If fewer values (than configured pens) are specified, the pens that have no values are not displayed.",
        "nAN,Trend,Value1 [,Value2 ... Value8]": "DspTrend(nAN,Trend,Value1 [,Value2 ... Value8] )",
        "nAN": "The AN where the trend will be displayed.",
        "Trend": "The name of the trend to display in the format <[LibName.]TrnName>. If you do not specify the library name, a trend from the Global library will display (if it exists).",
        "Value2...8": "The values to display on Pen 2...Pen 8 of the trend (optional)."
      },
      "helpPath": "DspTrend.html"
    },
    "dsptrendinfo": {
      "name": "DspTrendInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hTrend",
        "Type",
        "AN"
      ],
      "doc": "Gets information on a trend definition.",
      "returns": "The trend information (as an integer). If Pen Color (Types 11 - 18) is requested from a bar trend, the return value is -1.",
      "paramDocs": {
        "1": "Number of samples in trend",
        "2": "Height of trend (in pixels)",
        "3": "Width of trend sample (in pixels)",
        "4": "Number of trend pens",
        "11": "Color of pen 1. If the pen uses flashing color, the initial color used. (Use type 19 to determine the secondary flashing color for pen 1.)",
        "12": "Color of pen 2. If the pen uses flashing color, the initial color used. (Use type 20 to determine the secondary flashing color for pen 2.)",
        "13": "Color of pen 3. If the pen uses flashing color, the initial color used. (Use type 21 to determine the secondary flashing color for pen 3.)",
        "14": "Color of pen 4. If the pen uses flashing color, the initial color used. (Use type 22 to determine the secondary flashing color for pen 4.)",
        "15": "Color of pen 5. If the pen uses flashing color, the initial color used. (Use type 23 to determine the secondary flashing color for pen 5.)",
        "16": "Color of pen 6. If the pen uses flashing color, the initial color used. (Use type 24 to determine the secondary flashing color for pen 6.)",
        "17": "Color of pen 7. If the pen uses flashing color, the initial color used. (Use type 25 to determine the secondary flashing color for pen 7.)",
        "18": "Color of pen 8. If the pen uses flashing color, the initial color used. (Use type 26 to determine the secondary flashing color for pen 8.)",
        "19": "The secondary color used for pen 1, if flashing color is used.",
        "20": "The secondary color used for pen 2, if flashing color is used.",
        "21": "The secondary color used for pen 3, if flashing color is used.",
        "22": "The secondary color used for pen 4, if flashing color is used.",
        "23": "The secondary color used for pen 5, if flashing color is used.",
        "24": "The secondary color used for pen 6, if flashing color is used.",
        "25": "The secondary color used for pen 7, if flashing color is used.",
        "26": "The secondary color used for pen 8, if flashing color is used.",
        "hTrend, Type, AN": "DspTrendInfo( hTrend, Type, AN)",
        "hTrend": "The name of the trend in the format <[LibName.]TrnName>. If you do not specify the library name, a trend from the Global library is assumed.",
        "nType": "Type of trend info:",
        "nAN": "The AN where the trend is displayed.",
        "Types": "The trend information (as an integer). If Pen Color (Types 11 - 18) is requested from a bar trend, the return value is -1."
      },
      "helpPath": "DspTrendInfo.html"
    },
    "dumpkernel": {
      "name": "DumpKernel",
      "returnType": "UNKNOWN",
      "params": [
        "iMode",
        "sName"
      ],
      "doc": "Dumps Kernel data to the KERNEL.DAT file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "iMode, sName": "DumpKernel(iMode, sName)",
        "iMode": "The Kernel data to dump:",
        "sName": "The queue or table name (if \"\", returns data for all queues or tables). Only valid if iMode is 0x0020 and 0x0040."
      },
      "helpPath": "DumpKernel.html"
    },
    "engtogeneric": {
      "name": "EngToGeneric",
      "returnType": "UNKNOWN",
      "params": [
        "Value",
        "EngLow",
        "EngHigh"
      ],
      "doc": "Gets a variable in the Plant SCADA generic scale format. Plant SCADA uses this scale to display trends.",
      "returns": "The variable (in the range 0 - 32000).",
      "paramDocs": {
        "Value, EngLow, EngHigh": "EngToGeneric(Value, EngLow, EngHigh)",
        "Value": "The value to convert to the Plant SCADA generic scale format.",
        "EngLow": "The engineering units zero scale.",
        "EngHigh": "The engineering units full scale."
      },
      "helpPath": "EngToGeneric.html"
    },
    "entercriticalsection": {
      "name": "EnterCriticalSection",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Requests permission for the current thread to have access to a critical section (shared critical resource).",
      "returns": "This function does not return a value.",
      "paramDocs": {
        "sName": "EnterCriticalSection(sName)"
      },
      "helpPath": "EnterCriticalSection.html"
    },
    "equipbrowseclose": {
      "name": "EquipBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipBrowseClose(LONG Session)",
        "Session": "Session"
      },
      "helpPath": "EquipBrowseClose.html"
    },
    "equipbrowsefirst": {
      "name": "EquipBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipBrowseFirst(LONG Session)",
        "Session": "The handle to a browse session previously returned by a EquipBrowseOpen call."
      },
      "helpPath": "EquipBrowseFirst.html"
    },
    "equipbrowsegetfield": {
      "name": "EquipBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING FieldName"
      ],
      "doc": "The EquipBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "Session, STRING FieldName": "STRING EquipBrowseGetField(LONG Session, STRING FieldName)",
        "Session": "The handle to a browse session previously returned by a EquipBrowseOpen call.",
        "FieldName": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "EquipBrowseGetField.html"
    },
    "equipbrowsenext": {
      "name": "EquipBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipBrowseNext(LONG Session)",
        "Session": "Session"
      },
      "helpPath": "EquipBrowseNext.html"
    },
    "equipbrowsenumrecords": {
      "name": "EquipBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "Session": "LONG EquipBrowseNumRecords(LONG Session)"
      },
      "helpPath": "EquipBrowseNumRecords.html"
    },
    "equipbrowseopen": {
      "name": "EquipBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters]"
      ],
      "doc": "The EquipBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "Filter": "LONG EquipBrowseOpen(STRING Filter, STRING Fields [, STRING Clusters] )",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that all connected clusters will be browsed."
      },
      "helpPath": "EquipBrowseOpen.html"
    },
    "equipbrowseprev": {
      "name": "EquipBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "Session": "INT EquipBrowsePrev(LONG Session)"
      },
      "helpPath": "EquipBrowsePrev.html"
    },
    "equipcheckupdate": {
      "name": "EquipCheckUpdate",
      "returnType": "UNKNOWN",
      "params": [
        "INT Reload[",
        "STRING sCluster]"
      ],
      "doc": "The EquipCheckUpdate function checks if the equipment database file has been updated, and provides the facility to reload it.",
      "returns": "0 (FALSE) if the equipment database has not changed, or 1 (TRUE) if it has been changed, otherwise an error is returned.",
      "paramDocs": {
        "(INT Reload[, STRING sCluster])": "INT EquipCheckUpdate(INT Reload[, STRING sCluster])",
        "Cluster": "The cluster name to check and/or reload the equipment database for. All clusters will be checked if omitted or an empty string is set."
      },
      "helpPath": "EquipCheckUpdate.html"
    },
    "equipgetparameter": {
      "name": "EquipGetParameter",
      "returnType": "UNKNOWN",
      "params": [
        "ClusterName",
        "EquipmentName",
        "ParameterName"
      ],
      "doc": "Reads a runtime parameter of an equipment database record from the EQPARAM.RDB database file.",
      "returns": "The value of the specified parameter as a string. If the parameter is a tag reference, the value of the tag shall be returned.",
      "paramDocs": {
        "ClusterName": "EquipGetParameter(ClusterName, EquipmentName, ParameterName)",
        "EquipmentName": "EquipmentName",
        "ParameterName": "ParameterName"
      },
      "helpPath": "EquipGetParam.htm"
    },
    "equipgetproperty": {
      "name": "EquipGetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "STRING Field",
        "INT Mode",
        "STRING Cluster"
      ],
      "doc": "This function reads a property of an equipment database record from the EQUIP.RDB database file.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "0": "(Block - values are retrieved from the report server, the value will also be stored in local memory cache)",
        "1": "(Cache  values are first retrieved from local memory cache, if the property is missing from the memory cache, a request will be sent to the report server and the result will then be cached. If the property is missing from the memory cache or if a previous request is in progress, an empty string will be returned.)",
        "2": "(Local - values are retrieved from the local RDB, an error will be returned when trying to get the scheduler engine field in local mode)",
        "3": "(CacheThenLocal  values are first retrieved from local memory cache, if the property is missing from the memory cache, a request will be sent to the report server and the result will then be cached. If the property is missing from the memory cache or if a previous request is in progress, the local RDB will be accessed to retrieve the property value.)",
        "Name, STRING Field, INT Mode, STRING Cluster": "STRING EquipGetProperty(STRING Name, STRING Field, INT Mode, STRING Cluster)",
        "Name": "The name of the equipment from which to get information. The name of the equipment can be prefixed by the name of the cluster that is \"ClusterName.Equipment\".",
        "Field": "The field to read. Supported fields are:",
        "Cluster": "The cluster to which the equipment belongs (16 characters).",
        "Type": "The equipment-specific type of device (254 characters).",
        "Area": "Area number (integer) (16 characters).",
        "Location": "Equipment specific field (254 characters).",
        "IODevice": "I/O Device name(s) (254 characters).",
        "Page": "Page name (254 characters).",
        "Parent": "The name of the parent equipment derived from the name of the equipment (maximum 254 characters).",
        "Help": "Help context (254 characters).",
        "Comment": "User comment (254 characters).",
        "Custom1..8": "User definable fields (254 characters each).",
        "Composite": "The equipment specific composite name (maximum 254 characters).",
        "Defstate": "The default state.",
        "Scheduled": "Specifies if the equipment participates in a schedule.",
        "Alias": "Meaningful name of equipment (254 characters).",
        "Content": "Workspace content associated with equipment instance.",
        "Hidden": "Hide from equipment tree at runtime.",
        "MODE": "(the current mode of the equipment) 0 - automatic; 1- Manual Inherited; 2- Manual.",
        "DRMODE": "(the current DR mode level for the equipment). The value will be a positive integer to represent the current DR level or zero if inactive.",
        "STATE": "(the current state of the equipment. Although you can only set state for equipment in Override mode, it is still possible to get state for equipment in normal and inherited override mode.)",
        "Mode": "0 (Block - values are retrieved from the report server, the value will also be stored in local memory cache)"
      },
      "helpPath": "EquipGetProperty.html"
    },
    "equiprefbrowseclose": {
      "name": "EquipRefBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipRefBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipRefBrowseClose(LONG Session)",
        "Session": "The handle to a browse session previously returned by a EquipBrowseOpen call."
      },
      "helpPath": "EquipRefBrowseClose.html"
    },
    "equiprefbrowsefirst": {
      "name": "EquipRefBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipRefBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipRefBrowseFirst(LONG Session)",
        "Session": "The handle to a browse session previously returned by a EquipRefBrowseOpen call."
      },
      "helpPath": "EquipRefBrowseFirst.html"
    },
    "equiprefbrowsenext": {
      "name": "EquipRefBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipRefBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the equipment reference database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipRefBrowseNext(LONG Session)",
        "Session": "Session"
      },
      "helpPath": "EquipRefBrowseNext.html"
    },
    "equiprefbrowsenumrecords": {
      "name": "EquipRefBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipRefBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "Session": "LONG EquipRefBrowseNumRecords(LONG Session)"
      },
      "helpPath": "EquipRefBrowseNumRecords.html"
    },
    "equiprefbrowseopen": {
      "name": "EquipRefBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Sort]"
      ],
      "doc": "The EquipRefBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent reference browse function calls.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING Filter, STRING Fields [, STRING Sort]": "LONG EquipRefBrowseOpen(STRING Filter, STRING Fields [, STRING Sort] )",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned. Where a fieldname is not specified in the filter, it is assumed to be equipment name. For example, the filter \"AAA\" is equivalent to \"name=AAA\".",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return all available columns. Supported fields are:",
        "Sort": "Comma delimited list of record fields to be returned in order of sorting preferences. For example(GROUP:D, ORDER:A)"
      },
      "helpPath": "EquipRefBrowseOpen.html"
    },
    "equiprefbrowseprev": {
      "name": "EquipRefBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipRefBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the equipment database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "Session": "INT EquipRefBrowsePrev(LONG Session)"
      },
      "helpPath": "EquipRefBrowsePrev.html"
    },
    "equipsetproperty": {
      "name": "EquipSetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "STRING Field",
        "STRING Value",
        "STRING Cluster"
      ],
      "doc": "The EquipSetProperty function sets the property of an item of equipment.",
      "returns": "Returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "Name, STRING Field, STRING Value, STRING Cluster": "INT EquipSetProperty(STRING Name, STRING Field, STRING Value, STRING Cluster)",
        "Name": "The name of the equipment.",
        "field": "Only properties coming from the scheduler engine can be set:",
        "Value": "The value to be set:",
        "cluster": "The name of the cluster (optional)"
      },
      "helpPath": "EquipSetProperty.html"
    },
    "equipstatebrowseclose": {
      "name": "EquipStateBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipStateBrowseClose function terminates a browsing session and cleans up the resources used by the session.",
      "returns": "Returns 0 if the equipment state database browse session has been closed successfully, otherwise an error is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipStateBrowseClose(LONG Session )",
        "Session": "The handle to a browse session previously returned by a EquipStateBrowseOpen call"
      },
      "helpPath": "EquipStateBrowseClose.html"
    },
    "equipstatebrowsefirst": {
      "name": "EquipStateBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipStateBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the equipment state database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "Session": "INT EquipBrowseFirst(LONG Session)"
      },
      "helpPath": "EquipStateBrowseFirst.html"
    },
    "equipstatebrowsegetfield": {
      "name": "EquipStateBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING Field"
      ],
      "doc": "The EquipStateBrowseGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "Session, STRING Field": "STRING EquipStateBrowseGetField(LONG Session, STRING Field)",
        "Session": "The handle to a browse session previously returned by a EquipStateBrowseOpen call.",
        "Field": "The name of the field that references the value to be returned. Available fields are:"
      },
      "helpPath": "EquipStateBrowseGetField.html"
    },
    "equipstatebrowsenext": {
      "name": "EquipStateBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipStateBrowseNext function places the data browse cursor at the next available record.",
      "returns": "0 (zero) if the equipment state database browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "Session": "INT EquipStateBrowseNext(LONG Session)"
      },
      "helpPath": "EquipStateBrowseNext.html"
    },
    "equipstatebrowsenumrecords": {
      "name": "EquipStateBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipStateBrowseNumRecords function returns the number of records that match the current filter criteria.",
      "returns": "Returns the number of records which matches the current filter criteria. 0 means no records were found.",
      "paramDocs": {
        "Session": "LONG EquipStateBrowseNumRecords(LONG Session)"
      },
      "helpPath": "EquipStateBrowseNumRecords.html"
    },
    "equipstatebrowseopen": {
      "name": "EquipStateBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters]"
      ],
      "doc": "The EquipStateBrowseOpen function initiates a new session for browsing the equipment states configured. It returns a handle for the browsing session which can be used for further browsing operations.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING Filter, STRING Fields [, STRING Clusters]": "LONG EquipStateBrowseOpen(STRING Filter, STRING Fields [, STRING Clusters] )",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned. Where a field name is not specified in the filter, it is assumed to be tagname. For example, the filter \"AAA\" is equivalent to \"name=AAA\".",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Available fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that every connected clustes will be browsed."
      },
      "helpPath": "EquipStateBrowseOpen.html"
    },
    "equipstatebrowseprev": {
      "name": "EquipStateBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The EquipStateBrowsePrev function places the data browse cursor at the previous record.",
      "returns": "0 (zero) if the equipment state browse session exists, otherwise an error is returned.",
      "paramDocs": {
        "LONG Session": "INT EquipStateBrowsePrev(LONG Session)",
        "Session": "The handle to a browse session previously returned by a EquipStateBrowseOpen call."
      },
      "helpPath": "EquipStateBrowsePrev.html"
    },
    "errcom": {
      "name": "ErrCom",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the communication status for the current Cicode task.",
      "returns": "0 (zero) if all I/O device data associated with the task is valid, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "ErrCom.html"
    },
    "errdrv": {
      "name": "ErrDrv",
      "returnType": "UNKNOWN",
      "params": [
        "sProtocol",
        "sField",
        "nError"
      ],
      "doc": "Gets a protocol-specific error message and native error code.",
      "returns": "The error message (as a string), or an empty string (\"\") if the error is not found. The error code is returned into the nError variable.",
      "paramDocs": {
        "sProtocol, sField, nError": "ErrDrv(sProtocol, sField, nError)",
        "sProtocol": "The Plant SCADA protocol.",
        "sField": "The field in the PROTERR.DBF database:",
        "nError": "The protocol specific error code. This field needs to be a variable as it also the place where the returned error code is stored."
      },
      "helpPath": "ErrDrv.html"
    },
    "errgethw": {
      "name": "ErrGetHw",
      "returnType": "UNKNOWN",
      "params": [
        "Device",
        "DeviceType"
      ],
      "doc": "Gets the current hardware error status for an I/O device.",
      "returns": "The detected error.",
      "paramDocs": {
        "0": "for I/O devices that are created by Plant SCADA itself (Generic, LAN, Cicode, Animation, etc).",
        "2": "for I/O devices that are created by the system engineer.",
        "Device, DeviceType": "ErrGetHw(Device, DeviceType)",
        "Device": "For I/O devices that are created by the system engineer, select the IODevNo as the argument value.",
        "DeviceType": "Select a value from the following options to indicate the 'Type of Device' used in the Device argument:"
      },
      "helpPath": "ErrGetHw.html"
    },
    "errhelp": {
      "name": "ErrHelp",
      "returnType": "UNKNOWN",
      "params": [
        "Error"
      ],
      "doc": "Displays information about a hardware error.",
      "returns": "0 (zero) if successful, otherwise an error (274) is returned.",
      "paramDocs": {
        "Error": "ErrHelp(Error)"
      },
      "helpPath": "ErrHelp.html"
    },
    "errinfo": {
      "name": "ErrInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nType"
      ],
      "doc": "Gets extended error information on the last error that was detected.",
      "returns": "The error information.",
      "paramDocs": {
        "nType": "ErrInfo(nType)"
      },
      "helpPath": "ErrInfo.html"
    },
    "errlog": {
      "name": "ErrLog",
      "returnType": "UNKNOWN",
      "params": [
        "Message"
      ],
      "doc": "Logs a message to the system log file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Message": "ErrLog(Message)"
      },
      "helpPath": "ErrLog.html"
    },
    "errmsg": {
      "name": "ErrMsg",
      "returnType": "UNKNOWN",
      "params": [
        "nError"
      ],
      "doc": "Gets the error message associated with a detected hardware error.",
      "returns": "The error message (as a string). A null value is returned if nError is not in the range of Cicode errors.",
      "paramDocs": {
        "nError": "ErrMsg(nError)"
      },
      "helpPath": "ErrMsg.html"
    },
    "errset": {
      "name": "ErrSet",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "Sets the error-checking mode.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "default - Plant SCADA will check for errors.",
        "1": "The user needs to check for errors.",
        "Mode": "Sets the error-checking mode. When Mode is set to 0 and an error occurs that causes a component to stop executing, Plant SCADA halts the execution of the Cicode task that caused the error, and generates a hardware error."
      },
      "helpPath": "ErrSet.html"
    },
    "errsethw": {
      "name": "ErrSetHw",
      "returnType": "UNKNOWN",
      "params": [
        "Device",
        "Error",
        "DeviceType"
      ],
      "doc": "Sets the hardware error status for a hardware device.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Generic",
        "1": "LAN",
        "2": "Cicode",
        "3": "Animation",
        "4": "Reports Server",
        "5": "Alarms Server",
        "6": "Trends Server",
        "7": "I/O Server",
        "Device, Error, DeviceType": "ErrSetHw(Device, Error, DeviceType)",
        "Device": "For I/O devices that are created by the system engineer, select the IODevNo as the argument value.",
        "Error": "The error code.",
        "DeviceType": "Select a value from the following options to indicate the 'Type of Device' used in the Device argument:"
      },
      "helpPath": "ErrSetHw.html"
    },
    "errsetlevel": {
      "name": "ErrSetLevel",
      "returnType": "UNKNOWN",
      "params": [
        "Level"
      ],
      "doc": "Sets the nesting error level to enable error checking inside a nested function (when error checking has been disabled).",
      "returns": "Returns the old error level and sets a new error level.",
      "paramDocs": {
        "Level": "ErrSetLevel(Level)"
      },
      "helpPath": "ErrSetLevel.html"
    },
    "errtrap": {
      "name": "ErrTrap",
      "returnType": "UNKNOWN",
      "params": [
        "Error",
        "bHalt"
      ],
      "doc": "Generates an error trap.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Cicode execution is not halted",
        "1": "Cicode execution is halted",
        "bHalt": "Generates an error trap. If Plant SCADA error checking is enabled, this function will generate a hardware error and may halt Cicode execution (see bHalt argument). If user error checking is enabled, the user function specified in OnEvent(2,Fn) is called.",
        "Error": "ErrTrap(Error, bHalt)"
      },
      "helpPath": "ErrTrap.html"
    },
    "exec": {
      "name": "Exec",
      "returnType": "UNKNOWN",
      "params": [
        "Command [",
        "Mode]"
      ],
      "doc": "Executes an application or PIF file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "1": "Normal",
        "3": "Maximized",
        "6": "Minimized",
        "Command [, Mode]": "Exec(Command [, Mode] )",
        "Command": "The operating system command to execute (maximum of 255 characters).",
        "Mode": "The mode of the window:"
      },
      "helpPath": "Exec.html"
    },
    "executedtspkg": {
      "name": "ExecuteDTSPkg",
      "returnType": "UNKNOWN",
      "params": [
        "sFileOrSQLSvrName [",
        "sPkgName] [",
        "sParam1",
        "...",
        "sParam5] [",
        "sPkgPwd] [",
        "sPkgVer] [",
        "sLogFile] [",
        "sSQLSvrUsr] [",
        "sSQLSvrPwd]"
      ],
      "doc": "Loads and executes a DTS (Data Transformation Services) package which initiates data transfer and transformations between OLE DB data sources.",
      "returns": "0 (zero) if the package was executed successfully, otherwise a DTS error number is returned.",
      "paramDocs": {
        "sFileOrSQLSvrName [, sPkgName] [, sParam1, ... , sParam5] [, sPkgPwd] [, sPkgVer] [, sLogFile] [, sSQLSvrUsr] [, sSQLSvrPwd": "ExecuteDTSPkg(sFileOrSQLSvrName [, sPkgName] [, sParam1, ... , sParam5] [, sPkgPwd] [, sPkgVer] [, sLogFile] [, sSQLSvrUsr] [, sSQLSvrPwd])",
        "sFileOrSQLSvrName": "The path and name of the file containing the package (for file-based packages), or the SQL Server name (for SQL Server stored packages).",
        "sPkgName": "The package name.",
        "sParam1, ,sParam5": "Five optional variables which may be used as global variables within the DTS package. The variables need to be named Param1, Param2, Param3, Param4, and Param5.",
        "sPkgPwd": "The package password.",
        "sPkgVer": "The package version. If you don't specify a version, the most recent version is used.",
        "sLogFile": "AN optional path and name for a log file. The log file can track activity such as:",
        "sSQLSvrUsr": "The user name providing access to the SQL Server where the DTS package is stored. A user's account on the SQL Server consists of this user name and, in most cases, a password.",
        "sSQLSvrPwd": "The password providing access to the SQL Server, if the user's account on the server requires a password."
      },
      "helpPath": "ExecuteDTSPkg.html"
    },
    "exp": {
      "name": "Exp",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the exponential of a number (natural logarithm base e).",
      "returns": "The exponential of Number (to the base e).",
      "paramDocs": {
        "Number": "Exp(Number)"
      },
      "helpPath": "Exp.html"
    },
    "fact": {
      "name": "Fact",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the factorial of a number.",
      "returns": "The factorial of Number.",
      "paramDocs": {
        "Number": "Fact(Number)"
      },
      "helpPath": "Fact.html"
    },
    "fileclose": {
      "name": "FileClose",
      "returnType": "UNKNOWN",
      "params": [
        "File"
      ],
      "doc": "Closes a file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "File": "FileClose(File)"
      },
      "helpPath": "FileClose.html"
    },
    "filecopy": {
      "name": "FileCopy",
      "returnType": "UNKNOWN",
      "params": [
        "sSource",
        "sDest",
        "nMode"
      ],
      "doc": "Copies a file.",
      "returns": "0 (zero) if successful, otherwise an error is returned. However, if you copy in asynchronous mode, the return value does not reflect whether the copy operation was successful or not, because the function returns before the actual copy is complete.",
      "paramDocs": {
        "0": "Normal",
        "1": "Copy only if the file time is different.",
        "2": "Copy in asynchronous mode.",
        "sSource, sDest, nMode": "FileCopy(sSource, sDest, nMode)",
        "sSource": "The name of the source file to copy.",
        "sDest": "The name of destination file to copy to. To copy a file to the printer, specify the name as \"LPT1.DOS\".",
        "nMode": "The copy mode:",
        "Mode": "Multiple modes can be selected by adding them together (for example, set Mode to 3 to copy in asynchronous mode if the file time is different)."
      },
      "helpPath": "FileCopy.html"
    },
    "filedelete": {
      "name": "FileDelete",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Deletes a file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sName": "FileDelete(sName)",
        "Name": "The name of the file to delete."
      },
      "helpPath": "FileDelete.html"
    },
    "fileeof": {
      "name": "FileEOF",
      "returnType": "UNKNOWN",
      "params": [
        "File"
      ],
      "doc": "Determines if the end of the file has been reached.",
      "returns": "1 if the end of file has been reached, otherwise 0 (zero).",
      "paramDocs": {
        "File": "FileEOF(File)"
      },
      "helpPath": "FileEOF.html"
    },
    "fileexist": {
      "name": "FileExist",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Checks if a file exists.",
      "returns": "TRUE (1) if the file exists, otherwise FALSE (0).",
      "paramDocs": {
        "sName": "FileExist(sName)",
        "Name": "The name of the file to check."
      },
      "helpPath": "FileExist.html"
    },
    "filefind": {
      "name": "FileFind",
      "returnType": "UNKNOWN",
      "params": [
        "sPath",
        "nMode"
      ],
      "doc": "Finds a file that matches a specified search criteria.",
      "returns": "The full path and filename. If no files are found, an empty string is returned.",
      "paramDocs": {
        "0": "Normal files (includes files with read-only and archived attributes)",
        "1": "Read-only files only",
        "2": "Hidden files only",
        "4": "System files only",
        "16": "Subdirectories only",
        "32": "Archived files only",
        "128": "Files with no attributes only",
        "sPath, nMode": "FileFind(sPath, nMode)",
        "sPath": "The name of the file to check. To search for multiple files, the wildcards * and ? can be used to match multiple entries.",
        "nMode": "The type of file to check:"
      },
      "helpPath": "FileFind.html"
    },
    "filefindclose": {
      "name": "FileFindClose",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Closes a find (started with FileFind) that did not run to completion.",
      "returns": "0 if no error is detected, or a Cicode error code if an error occurred.",
      "paramDocs": {},
      "helpPath": "FileFindClose.html"
    },
    "filegettime": {
      "name": "FileGetTime",
      "returnType": "UNKNOWN",
      "params": [
        "File"
      ],
      "doc": "Gets the time on a file.",
      "returns": "The file time of the file (in the Plant SCADA time/date variable format).",
      "paramDocs": {
        "File": "FileGetTime(File)"
      },
      "helpPath": "FileGetTime.html"
    },
    "filemakepath": {
      "name": "FileMakePath",
      "returnType": "UNKNOWN",
      "params": [
        "sDrive",
        "sDir",
        "sFile",
        "sExt"
      ],
      "doc": "Creates a file path string from individual components.",
      "returns": "The full path as a string.",
      "paramDocs": {
        "sDrive, sDir, sFile, sExt": "FileMakePath(sDrive, sDir, sFile, sExt)",
        "sDrive": "The disk drive.",
        "sDir": "The directory string.",
        "sFile": "The file name (without the extension).",
        "sExt": "The file extension."
      },
      "helpPath": "FileMakePath.html"
    },
    "fileopen": {
      "name": "FileOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "nMode"
      ],
      "doc": "Opens a file and returns a file number that can be used by other file functions.",
      "returns": "The file number. If the file cannot be opened, -1 is returned and the code is halted.",
      "paramDocs": {
        "sName, nMode": "FileOpen(sName, nMode)",
        "sName": "The name of the file to open.",
        "nMode": "The mode of the opened file:",
        "a": "\"a\" - Append mode. Allows you to append to the file without removing the end of file marker. The file cannot be read. If the file does not exist, it will be created.",
        "a+": "\"a+\" - Append and read modes. Allows you to append to the file and read from it. The end of file marker will be removed before writing and restored when writing is complete. If the file does not exist, it will be created.",
        "r": "\"r\" - Read-only mode. Allows you to (only) read from the file. If the file does not exist or cannot be found, the function call will return the value -1.",
        "r+": "\"r+\" - Read/write mode. Allows you to read from, and write to, the file. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the function call will return the value -1.",
        "w": "\"w\" - Write mode. Opens an empty file for writing. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the file will be created.",
        "w+": "\"w+\" - Read/write mode. Opens an empty file for both reading and writing. If the file already exists (before the function is called), its contents will be deleted. If the file does not exist or cannot be found, the file will be created."
      },
      "helpPath": "FileOpen.html"
    },
    "fileprint": {
      "name": "FilePrint",
      "returnType": "UNKNOWN",
      "params": [
        "Devicename",
        "Filename"
      ],
      "doc": "Prints a file on a device.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Devicename, Filename": "FilePrint(Devicename, Filename)",
        "Devicename": "The name of the target device.",
        "Filename": "The name of the file to print on the device."
      },
      "helpPath": "FilePrint.html"
    },
    "fileread": {
      "name": "FileRead",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "Length"
      ],
      "doc": "Reads a number of characters from a file.",
      "returns": "The text from the file (as a string).",
      "paramDocs": {
        "File, Length": "FileRead(File, Length)",
        "File": "The file number.",
        "Length": "The number of characters to read."
      },
      "helpPath": "FileRead.html"
    },
    "filereadblock": {
      "name": "FileReadBlock",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "Buffer",
        "Length"
      ],
      "doc": "Reads a number of characters from a file.",
      "returns": "The number of characters read from the file. When the end of the file is found 0 will be returned. If an error occurs -1 will be returned and IsError() will return the error code.",
      "paramDocs": {
        "File, Buffer, Length": "FileReadBlock(File, Buffer, Length)",
        "File": "The file number.",
        "Buffer": "The buffer to return the binary data. This may be a string or a string packed with binary data. The string terminator is ignored and the length argument specifies the number of characters to write. Must be a string variable.",
        "Length": "The number of characters to read."
      },
      "helpPath": "FileReadBlock.html"
    },
    "filereadln": {
      "name": "FileReadLn",
      "returnType": "UNKNOWN",
      "params": [
        "File"
      ],
      "doc": "Reads a line from a file.",
      "returns": "The text, as a string.",
      "paramDocs": {
        "File": "FileReadLn(File)"
      },
      "helpPath": "FileReadLn.html"
    },
    "filerename": {
      "name": "FileRename",
      "returnType": "UNKNOWN",
      "params": [
        "Oldname",
        "Newname"
      ],
      "doc": "Renames a file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Oldname, Newname": "FileRename(Oldname, Newname)",
        "Oldname": "The original name of the file.",
        "Newname": "The new name of the file."
      },
      "helpPath": "FileRename.html"
    },
    "filerichtextprint": {
      "name": "FileRichTextPrint",
      "returnType": "UNKNOWN",
      "params": [
        "sFilename",
        "sPortName"
      ],
      "doc": "Prints the rich text file sFilename to the printer given by sPortname.",
      "returns": "0 if successful, otherwise an error is returned.",
      "paramDocs": {
        "sFilename": "Prints the rich text file sFilename to the printer given by sPortname.",
        "sFilename, sPortName": "FileRichTextPrint(sFilename, sPortName)",
        "PortName": "The name of the printer port to which the rich text file will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer."
      },
      "helpPath": "FileRichTextPrint.html"
    },
    "fileseek": {
      "name": "FileSeek",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "Offset"
      ],
      "doc": "Moves the file pointer to a specified position in a file.",
      "returns": "The new file position, or -1 if an error is detected.",
      "paramDocs": {
        "File, Offset": "FileSeek(File, Offset)",
        "File": "The file number.",
        "Offset": "The offset in bytes, from 0 to (maximum file size -1). This value needs to be >= 0."
      },
      "helpPath": "FileSeek.html"
    },
    "filesettime": {
      "name": "FileSetTime",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "iTime"
      ],
      "doc": "Sets the time on a file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "File, iTime": "FileSetTime(File, iTime)",
        "File": "The file number.",
        "iTime": "The new file time, in the Plant SCADA time/date variable format."
      },
      "helpPath": "FileSetTime.html"
    },
    "filesize": {
      "name": "FileSize",
      "returnType": "UNKNOWN",
      "params": [
        "File"
      ],
      "doc": "Gets the size of a file.",
      "returns": "The size of the file, in bytes.",
      "paramDocs": {
        "File": "FileSize(File)"
      },
      "helpPath": "FileSize.html"
    },
    "filesplitpath": {
      "name": "FileSplitPath",
      "returnType": "UNKNOWN",
      "params": [
        "sPath",
        "sDrive",
        "sDir",
        "sFile",
        "sExt"
      ],
      "doc": "Splits a file path into individual string components.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sPath": "Splits a file path into individual string components. You enter the full path string as sPath. The individual components of the path name are returned in the arguments sDrive, sDir, sFile, and sExt. Arguments must be declared as Cicode variables. If declared as local variables or tags, an \"Incompatible Types\" error will be returned.",
        "sPath, sDrive, sDir, sFile, sExt": "FileSplitPath(sPath, sDrive, sDir, sFile, sExt)",
        "sDrive": "The disk drive. Must be a String type variable.",
        "sDir": "The directory string. Must be a String type variable.",
        "sFile": "The file name (without the extension). Must be a String type variable.",
        "sExt": "The file extension. Must be a String type variable."
      },
      "helpPath": "FileSplitPath.html"
    },
    "filewrite": {
      "name": "FileWrite",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "String"
      ],
      "doc": "Writes a string to a file. The string is written at the current file position.",
      "returns": "The number of characters written.",
      "paramDocs": {
        "File, String": "FileWrite(File, String)",
        "File": "The file number.",
        "String": "The string to write."
      },
      "helpPath": "FileWrite.html"
    },
    "filewriteblock": {
      "name": "FileWriteBlock",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "Buffer",
        "Length"
      ],
      "doc": "Writes a string or buffer to a file.",
      "returns": "The number of characters written to the file. If an error is detected -1 will be returned and IsError() will return the error code.",
      "paramDocs": {
        "File, Buffer, Length": "FileWriteBlock(File, Buffer, Length)",
        "File": "The file number.",
        "Buffer": "The data to write to the file. This may be a string or a string packed with binary data. The string terminator is ignored and the length argument specifies the number of characters to write. Must be a string variable.",
        "Length": "The number of characters to write. The maximum number of characters you may write in one call is 255. (If you use a string without a terminator in a function that expects a string, or in a Cicode expression, you could get invalid results.) To use the string to build up a buffer, you do not need the terminating 0 (zero)."
      },
      "helpPath": "FileWriteBlock.html"
    },
    "filewriteln": {
      "name": "FileWriteLn",
      "returnType": "UNKNOWN",
      "params": [
        "File",
        "String"
      ],
      "doc": "Writes a string to a file, followed by a newline character.",
      "returns": "The number of characters written (including the carriage return and newline characters).",
      "paramDocs": {
        "File, String": "FileWriteLn(File, String)",
        "File": "The file number.",
        "String": "The string to write."
      },
      "helpPath": "FileWriteLn.html"
    },
    "fmtclose": {
      "name": "FmtClose",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt"
      ],
      "doc": "Closes a format template.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFmt": "FmtClose(hFmt)"
      },
      "helpPath": "FmtClose.html"
    },
    "fmtfieldhnd": {
      "name": "FmtFieldHnd",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "Name"
      ],
      "doc": "Gets the handle of a field in a format template.",
      "returns": "The handle of the format template field, or -1 if the field cannot be found.",
      "paramDocs": {
        "hFmt, Name": "FmtFieldHnd(hFmt, Name)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
        "sName": "The field name."
      },
      "helpPath": "FmtFieldHnd.html"
    },
    "fmtgetfield": {
      "name": "FmtGetField",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "sName"
      ],
      "doc": "Gets field data from a format template.",
      "returns": "The data (as a string). If the field does not contain any data, an empty string will be returned.",
      "paramDocs": {
        "hFmt, sName": "FmtGetField(hFmt, sName)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where data on the associated format template is stored.",
        "sName": "The field name."
      },
      "helpPath": "FmtGetField.html"
    },
    "fmtgetfieldcount": {
      "name": "FmtGetFieldCount",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt"
      ],
      "doc": "Retrieves the number of fields in a format object.",
      "returns": "Number of fields in the specified format.",
      "paramDocs": {
        "hFmt": "FmtGetFieldCount(hFmt)"
      },
      "helpPath": "FmtGetFieldCount.html"
    },
    "fmtgetfieldhnd": {
      "name": "FmtGetFieldHnd",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "hField"
      ],
      "doc": "Gets field data from a format template.",
      "returns": "The data (as a string). If the field does not contain any data, an empty string will be returned.",
      "paramDocs": {
        "hFmt, hField": "FmtGetFieldHnd(hFmt, hField)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
        "hField": "The field handle."
      },
      "helpPath": "FmtGetFieldHnd.html"
    },
    "fmtgetfieldname": {
      "name": "FmtGetFieldName",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "hField"
      ],
      "doc": "Retrieves the name of a particular field in a format object.",
      "returns": "Name of requested field",
      "paramDocs": {
        "hFmt, hField": "FmtGetFieldName(hFmt, hField)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where data on the associated format template is stored.",
        "hField": "The field handle."
      },
      "helpPath": "FmtGetFieldName.html"
    },
    "fmtgetfieldwidth": {
      "name": "FmtGetFieldWidth",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "hField"
      ],
      "doc": "Retrieves the width of a particular field in a format object.",
      "returns": "Width of the requested field.",
      "paramDocs": {
        "hFmt, hField": "FmtGetFieldWidth(hFmt, hField)",
        "hFmt": "The handle to a format object. The handle identifies the table where data on the associated format template is stored.",
        "hField": "The field handle."
      },
      "helpPath": "FmtGetFieldWidth.html"
    },
    "fmtopen": {
      "name": "FmtOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "STRING Format",
        "INT Mode"
      ],
      "doc": "Creates a format template. After you create a template, you can use it for formatting data into strings or extracting data from a string.",
      "returns": "The format template handle, or -1 if the format cannot be created.",
      "paramDocs": {
        "0": "Open the existing format.",
        "1": "Open a new format.",
        "2": "Open Summary Format from Alarm Category specified by Name.",
        "3": "Open Display Format from Alarm Category specified by Name.",
        "4": "Open SOE format from Alarm Category specified by Name.",
        "5": "Reopen a format. If the format name already exists, it will reopen with the specified format template. Otherwise, a new format will open.",
        "name": "CT_ERROR_BUFFER_OVERRUN) will be generated.",
        "Name, STRING Format, INT Mode": "INT FmtOpen(STRING Name, STRING Format, INT Mode)",
        "Name": "The name of the format template or Alarm Category.",
        "Format": "The format of the template, as {<name>[,width[,justification]]}. Not used for alarm format. See Format Templates for more information.",
        "Mode": "The mode of the open:"
      },
      "helpPath": "FmtOpen.html"
    },
    "fmtsetfield": {
      "name": "FmtSetField",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "Name",
        "Data"
      ],
      "doc": "Sets data in a field of a format template.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFmt, Name, Data": "FmtSetField(hFmt, Name, Data)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
        "sName": "The name of the format template.",
        "Data": "Field data."
      },
      "helpPath": "FmtSetField.html"
    },
    "fmtsetfieldhnd": {
      "name": "FmtSetFieldHnd",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "hField",
        "Data"
      ],
      "doc": "The fields you can build the formatted string with the FmtToStr() function.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFmt, hField, Data": "FmtSetFieldHnd(hFmt, hField, Data)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
        "hField": "The field handle.",
        "Data": "Field data."
      },
      "helpPath": "FmtSetFieldHnd.html"
    },
    "fmttostr": {
      "name": "FmtToStr",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt"
      ],
      "doc": "Builds a formatted string from the current field data (in a format template).",
      "returns": "The formatted string as defined in the format description.",
      "paramDocs": {
        "hFmt": "FmtToStr(hFmt)"
      },
      "helpPath": "FmtToStr.html"
    },
    "formactive": {
      "name": "FormActive",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Checks if a form is currently active (displayed on the screen).",
      "returns": "TRUE (1) if the form is active or FALSE (0) if it is not.",
      "paramDocs": {
        "hForm": "FormActive(hForm)"
      },
      "helpPath": "FormActive.html"
    },
    "formaddlist": {
      "name": "FormAddList",
      "returnType": "UNKNOWN",
      "params": [
        "sText"
      ],
      "doc": "Adds a text string to a list box or combo box.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sText": "FormAddList(sText)"
      },
      "helpPath": "FormAddList.html"
    },
    "formbutton": {
      "name": "FormButton",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "sText",
        "Fn",
        "Mode"
      ],
      "doc": "Adds a button to the current form.",
      "returns": "The field handle if the button is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "0": "Normal button. When this button is selected the callback function is called.",
        "1": "OK button. When this button is selected, the form is closed, and all operator-entered data is copied to buffers (specified by the other form functions). FormRead() returns 0 (zero) to indicate a successful read. The callback function specified in Fn is called. Be aware that this mode destroys the form.",
        "2": "Cancel button. When this button is selected, the form is closed and operator-entered data is discarded. FormRead() returns with an error 299. The callback function specified in Fn is called. Be aware that this mode destroys the form.",
        "3": "Disabled button. When this button is drawn, it will be shaded and not available for use.",
        "Fn": "Adds a button to the current form. You can add buttons that run callback functions (specified in Fn) to perform any actions you need, as well as the standard buttons - an [OK] button to save the operator's entries and close the form, and a [Cancel] button to close the form but discard the changes.",
        "Col, Row, sText, Fn, Mode": "FormButton(Col, Row, sText, Fn, Mode)",
        "Col": "The number of the column in which the button will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the button in column 8, enter 7.",
        "Row": "The number of the row in which the button will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the button in row 6, enter 5.",
        "sText": "The text to display on the button.",
        "Mode": "Button mode:"
      },
      "helpPath": "FormButton.html"
    },
    "formcheckbox": {
      "name": "FormCheckBox",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "sText",
        "sBuf"
      ],
      "doc": "Adds a check box to the current form.",
      "returns": "The field handle if the check box is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, sText, sBuf": "FormCheckBox(Col, Row, sText, sBuf)",
        "Col": "The number of the column in which the check box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the check box in column 8, enter 7.",
        "Row": "The number of the row in which the check box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the check box in row 6, enter 5.",
        "sText": "The text associated with the check box.",
        "sBuf": "The string buffer in which to put the state of the check box. You should initialize this buffer to the state of the check box. When the form returns, this buffer will contain either '1' or '0' if the box is checked."
      },
      "helpPath": "FormCheckBox.html"
    },
    "formcombobox": {
      "name": "FormComboBox",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Width",
        "Height",
        "sBuf [",
        "Mode]"
      ],
      "doc": "Adds a combo box to the current form.",
      "returns": "The field handle if the combo box is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "0": "Sort the combo box elements alphabetically.",
        "1": "Place elements in combo box in the order they were added.",
        "Col, Row, Width, Height, sBuf [, Mode]": "FormComboBox(Col, Row, Width, Height, sBuf [, Mode] )",
        "Col": "The number of the column in which the combo box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the combo box in column 8, enter 7.",
        "Row": "The number of the row in which the combo box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the combo box in row 6, enter 5.",
        "Width": "The width of the list box, which should be wide enough to display your widest item. Items wider than the list box are clipped.",
        "Height": "The height of the list box (the number of items that can be seen in the list box without scrolling).",
        "sBuf": "The string buffer in which to store the selected item. The sBuf parameter can also hold the starting selection for the Combo box. For example if you set the sBuf string to \"HELLO\" before calling FormComboBox, HELLO will be displayed in the box upon opening the form. Must be a String type variable.",
        "Mode": "The mode in which to create the combo box:"
      },
      "helpPath": "FormComboBox.html"
    },
    "formcurr": {
      "name": "FormCurr",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField"
      ],
      "doc": "Gets the form and field handles for the current form and field. You should call this function only from within a callback function. You can then use the same callback function for all forms and fields, regardless of how the boxes, buttons, etc. on the forms are used. You should use this function with the FormGetInst() function.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField": "FormCurr(hForm, hField)",
        "hForm": "Variable containing the form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "Variable containing the field handle of the field currently selected."
      },
      "helpPath": "FormCurr.html"
    },
    "formdestroy": {
      "name": "FormDestroy",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Destroys a form that is removes it from the screen.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm": "FormDestroy(hForm)"
      },
      "helpPath": "FormDestroy.html"
    },
    "formedit": {
      "name": "FormEdit",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Text",
        "Width Height",
        "bReadOnly [",
        "maxTextLength]"
      ],
      "doc": "Adds an edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. A user input/edit box is added to the form at the specified column and row position. The operator can enter or edit the text in the edit box. This text is then passed to this function as Text.",
      "returns": "The field handle if the string is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "Text": "Adds an edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. A user input/edit box is added to the form at the specified column and row position. The operator can enter or edit the text in the edit box. This text is then passed to this function as Text.",
        "Col, Row, Text, Width Height, bReadOnly": "FormEdit(Col, Row, Text, Width Height, bReadOnly [, maxTextLength] )",
        "Col": "The number of the column in which the edit field will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the edit field in column 8, enter 7.",
        "Row": "The number of the row in which the edit field will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the edit field in row 6, enter 5.",
        "Width": "The width of the edit field.",
        "Height": "The height of the edit field as measured using average character height. When value specified is less than 1 or not specified, it is default to 1 (single line). When multiple lines are specified, the content of the edit box will be word wrapped.",
        "bReadOnly": "Flag to indicate whether the edit box is read only. Default is FALSE if not specified.",
        "maxTextLength": "This optional parameter specifies the maximum length of input text. The default value is 0 meaning the string can have the maximum length allowed in the system (Cicode allows strings of 255 characters)."
      },
      "helpPath": "FormEdit.html"
    },
    "formfield": {
      "name": "FormField",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Width",
        "Height",
        "Type",
        "Buffer",
        "Label",
        "Fn [",
        "maxTextLength]"
      ],
      "doc": "Adds a field control device (such as a button, check box, or edit field) to the current form.",
      "returns": "The field handle if the field is successfully added, otherwise it will return -1.",
      "paramDocs": {
        "0": "None",
        "1": "Edit",
        "2": "Edit Password",
        "3": "Text",
        "4": "Button",
        "5": "OK button",
        "6": "Cancel button",
        "7": "Group box",
        "8": "Radio button",
        "9": "Check box",
        "Col, Row, Width, Height, Type, Buffer, Label, Fn [, maxTextLength]": "FormField(Col, Row, Width, Height, Type, Buffer, Label, Fn [, maxTextLength] )",
        "Col": "The number of the column in which the control will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the control in column 8, enter 7.",
        "Row": "The number of the row in which the control will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the control in row 6, enter 5.",
        "Width": "The width of the control device.",
        "Height": "The height of the control device.",
        "nType": "The type of control device:",
        "Buffer": "The output buffer for the field string. The default value of the control device is initialized to the value of the buffer. If you specify a Radio button or Check box, you should initialize the buffer to \"0\" or \"1\". The result of the field will also be set to \"0\" or \"1\".",
        "Label": "The display label for a button, or the default label for an edit field",
        "Fn": "The callback function to call when the button is selected. Set to 0 to call no function. Please be aware that the Fn parameter needs to be of type INT, and the callback function cannot contain a blocking function. For types other than 4,5, and 6, set this argument to 0.",
        "maxTextLength": "This optional parameter specifies the maximum length of input text for edit fields (this parameter is ignored for other controls). The default value is 0 meaning the string can have the maximum length allowed in the system (Cicode allows strings of 255 characters)."
      },
      "helpPath": "FormField.html"
    },
    "formgetcurrinst": {
      "name": "FormGetCurrInst",
      "returnType": "UNKNOWN",
      "params": [
        "iData",
        "sData"
      ],
      "doc": "Extracts data associated with a field (set by the FormSetInst() function). You should call this function only from within a field callback function. This function is the same as calling the FormCurr() function and then the FormGetInst() function.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "iData, sData": "FormGetCurrInst(iData, sData)",
        "iData": "Variable containing integer data.",
        "sData": "Variable containing string data."
      },
      "helpPath": "FormGetCurrInst.html"
    },
    "formgetdata": {
      "name": "FormGetData",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Gets all data associated with a form and puts it into the output string buffers.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm": "FormGetData(hForm)"
      },
      "helpPath": "FormGetData.html"
    },
    "formgetinst": {
      "name": "FormGetInst",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "iData",
        "sData"
      ],
      "doc": "Extracts the data associated with a field (set by the FormSetInst() function). You would normally use this function in a field callback function. It allows single callback functions to know that the form and field are associated.",
      "returns": "The data (as a string).",
      "paramDocs": {
        "hForm, hField, iData, sData": "FormGetInst(hForm, hField, iData, sData)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected.",
        "iData": "Integer data.",
        "sData": "Variable containing string data."
      },
      "helpPath": "FormGetInst.html"
    },
    "formgettext": {
      "name": "FormGetText",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField"
      ],
      "doc": "Gets the current text from a form field.",
      "returns": "The field text (as a string).",
      "paramDocs": {
        "hForm, hField": "FormGetText(hForm, hField)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected."
      },
      "helpPath": "FormGetText.html"
    },
    "formgoto": {
      "name": "FormGoto",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Goes to a specified form. The form is displayed on top of all windows and the keyboard focus is set to this form.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm": "FormGoto(hForm)"
      },
      "helpPath": "FormGoto.html"
    },
    "formgroupbox": {
      "name": "FormGroupBox",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Width",
        "Height [",
        "Text]"
      ],
      "doc": "Adds a group box to the current form.",
      "returns": "The field handle if the group box is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, Width, Height [, Text]": "FormGroupBox(Col, Row, Width, Height [, Text] )",
        "Col": "The number of the column in which the group box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the group box in column 8, enter 7.",
        "Row": "The number of the row in which the group box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the group box in row 6, enter 5.",
        "Width": "The width of the group box, which should be wide enough to display your widest item.",
        "Height": "The height of the group box.",
        "Text": "The text to display as the group box label."
      },
      "helpPath": "FormGroupBox.html"
    },
    "forminput": {
      "name": "FormInput",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Prompt",
        "Text",
        "Width [",
        "maxTextLength]"
      ],
      "doc": "Adds a prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will display with the prompt and edit box. The operator's input is passed back as a string (Text).",
      "returns": "The field handle if it is added successfully, otherwise -1 is returned.",
      "paramDocs": {
        "Text": "Adds a prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will display with the prompt and edit box. The operator's input is passed back as a string (Text).",
        "Col,Row,Prompt,Text,Width": "FormInput(Col,Row,Prompt,Text,Width [, maxTextLength] )",
        "Col": "The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
        "Row": "The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
        "Prompt": "The prompt string.",
        "Width": "The width of the edit field.",
        "maxTextLength": "This optional parameter specifies the maximum length of input text. The default value is 0 meaning the string can have the maximum length allowed in the system (Cicode allows strings of 255 characters)."
      },
      "helpPath": "FormInput.html"
    },
    "formlistaddtext": {
      "name": "FormListAddText",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "Text"
      ],
      "doc": "Adds a new text entry to a combo box or a list box while the form is displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField, Text": "FormListAddText(hForm, hField, Text)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected.",
        "Text": "The output text string containing the operator's input."
      },
      "helpPath": "FormListAddText.html"
    },
    "formlistbox": {
      "name": "FormListBox",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Width",
        "Height",
        "sBuf [",
        "Mode]"
      ],
      "doc": "Adds a list box to the current form.",
      "returns": "The field handle if the list box is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, Width, Height, sBuf [, Mode]": "FormListBox(Col, Row, Width, Height, sBuf [, Mode] )",
        "Col": "The number of the column in which the list box will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the list box in column 8, enter 7.",
        "Row": "The number of the row in which the list box will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the list box in row 6, enter 5.",
        "Width": "The width of the list box, in characters. Width should be wide enough to display your widest item. Items wider than the list box are clipped.",
        "Height": "The height of the list box, as the number of items that can be seen in the list box without scrolling.",
        "sBuf": "The string buffer in which to store the selected item. Must be a String type variable.",
        "Mode": "The mode in which to create the list box:"
      },
      "helpPath": "FormListBox.html"
    },
    "formlistdeletetext": {
      "name": "FormListDeleteText",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "Text"
      ],
      "doc": "Deletes an existing text entry from a combo box or a list box while the form is displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField, Text": "FormListDeleteText(hForm, hField, Text)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected.",
        "Text": "The text to delete."
      },
      "helpPath": "FormListDeleteText.html"
    },
    "formlistselecttext": {
      "name": "FormListSelectText",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "Text"
      ],
      "doc": "Selects (highlights) a text entry in a Combo box or a List box while the form is displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField, Text": "FormListSelectText(hForm, hField, Text)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected.",
        "Text": "The text to be selected. If this text is not present in the list, then no item will be selected (and this text will not be added)."
      },
      "helpPath": "FormListSelectText.html"
    },
    "formnew": {
      "name": "FormNew",
      "returnType": "UNKNOWN",
      "params": [
        "Title",
        "Width",
        "Height",
        "Mode"
      ],
      "doc": "Creates a new data entry form and defines its size and mode.",
      "returns": "The form handle if the form is created successfully, otherwise -1 is returned. The form handle identifies the table where all data on the associated form is stored.",
      "paramDocs": {
        "0": "Default font and text spacing",
        "1": "Small font",
        "2": "Fixed pitch font",
        "4": "Static text compression where the vertical spacing is reduced. This can cause formatting errors if buttons are too close, because the vertical spacing will be less than the height of a button.",
        "8": "Keep the form on top of the Plant SCADA window.",
        "16": "The current window cannot be changed or closed until the form is finished or cancelled.",
        "32": "Makes a form with no caption.",
        "128": "The form will not close if the ESC or ENTER key is pressed, unless you specifically define at least one button on the form which acts as an OK or Cancel button. For a form with no buttons, the ENTER key normally closes the form; this mode disables that behavior.",
        "Title, Width, Height, Mode": "FormNew(Title, Width, Height, Mode)",
        "Title": "The title of the form.",
        "Width": "The character width of the form (1 to 131).",
        "Height": "The character height of the form (1 to 131).",
        "Mode": "The mode of the form:"
      },
      "helpPath": "FormNew.html"
    },
    "formnumpad": {
      "name": "FormNumPad",
      "returnType": "UNKNOWN",
      "params": [
        "Title",
        "Input",
        "Mode"
      ],
      "doc": "Provides a keypad form for the operator to add numeric values.",
      "returns": "The string value entered by the operator. The IsError() function returns 0 (zero). If the form was cancelled, the value of Input is returned, and the IsError() function returns error number 299.",
      "paramDocs": {
        "0": "Standard keypad",
        "1": "Password edit field",
        "2": "not used",
        "4": "With +/- button",
        "8": "With / button",
        "16": "With . button",
        "32": "With : button",
        "64": "With AM, PM buttons",
        "128": "with Now button",
        "512": "with 1hr, 2hr and 8hr buttons",
        "Title, Input, Mode": "FormNumPad(Title, Input, Mode)",
        "Title": "The title to display on the number pad form.",
        "Input": "The existing or default value. This value is returned if the form is cancelled or accepted without changes.",
        "Mode": "The buttons to include on the keypad form. The Mode can be a combination of the following:"
      },
      "helpPath": "FormNumPad.html"
    },
    "formopenfile": {
      "name": "FormOpenFile",
      "returnType": "UNKNOWN",
      "params": [
        "sTitle",
        "sFileName",
        "sFilter",
        "[bResetToDefault]"
      ],
      "doc": "Displays a File Open dialog box.",
      "returns": "The name and full path of the selected file (as a string) or an empty string (\"\") if the Cancel button is selected.",
      "paramDocs": {
        "sTitle, sFileName, sFilter, [bResetToDefault]": "FormOpenFile(sTitle, sFileName, sFilter, [bResetToDefault])",
        "sFileName": "The name of the default file to display in the \"File Name\" field.",
        "sTitle": "A title to display at the top of the form.",
        "sFilter": "A file filter list to display in the \"List Files of Type\" field. The file filter list has the following format:",
        "bResetToDefault": "bResetToDefault"
      },
      "helpPath": "FormOpenFile.html"
    },
    "formpassword": {
      "name": "FormPassword",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Prompt",
        "Password",
        "Width"
      ],
      "doc": "Adds both a password prompt and edit field to the current form. You should call this function only after the FormNew() function and before the FormRead() function. When FormRead() is called, the form will also display the password prompt and edit field.",
      "returns": "The field handle if it is added successfully, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, Prompt, Password, Width": "FormPassword(Col, Row, Prompt, Password, Width)",
        "Col": "The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
        "Row": "The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
        "Prompt": "The prompt string.",
        "Password": "Variable containing the password entered by the operator.",
        "Width": "The width of the edit field."
      },
      "helpPath": "FormPassword.html"
    },
    "formposition": {
      "name": "FormPosition",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y",
        "Mode"
      ],
      "doc": "Sets the position of a form on the screen, before it is displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "X, Y, Mode": "FormPosition(X, Y, Mode)",
        "X, Y": "The x and y pixel coordinates of the form.",
        "Mode": "Not used, set it to 0."
      },
      "helpPath": "FormPosition.html"
    },
    "formprompt": {
      "name": "FormPrompt",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Prompt [",
        "Width] [",
        "Height]"
      ],
      "doc": "Adds a prompt field to the current form.",
      "returns": "The field handle if it is added successfully, otherwise -1 is returned.",
      "paramDocs": {
        "Col": "FormPrompt(Col, Row, Prompt [,Width] [,Height])",
        "Row": "The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
        "Prompt": "The prompt string.",
        "Width": "The width of the area that the prompt string will wrap within (measured using average character width). For this setting to be applied, you also need to specify a value for Height.",
        "Height": "The height of the area that the prompt string will display within (measured using average character height). For this setting to be applied, you also need to specify a value for Width."
      },
      "helpPath": "FormPrompt.html"
    },
    "formradiobutton": {
      "name": "FormRadioButton",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "sText",
        "sBuf"
      ],
      "doc": "Adds a radio button to the current form, allowing the operator to make a selection from a multiple choice list.",
      "returns": "The field handle if the radio button is successfully added, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, sText, sBuf": "FormRadioButton(Col, Row, sText, sBuf)",
        "Col": "The number of the column in which the button will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the button in column 8, enter 7.",
        "Row": "The number of the row in which the button will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the button in row 6, enter 5.",
        "sText": "The text associated with the radio button.",
        "sBuf": "The string buffer in which to put the state of the radio button. You should initialize this buffer to the state of the button. When the form returns, this buffer will contain either '1' or '0' if the radio button is checked."
      },
      "helpPath": "FormRadioButton.html"
    },
    "formread": {
      "name": "FormRead",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "Displays the current form (created with the FormNew() function), with all the fields that were added (with the form field functions).",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Wait for the user.",
        "1": "Do not wait for the user.",
        "Mode": "You can display the form and wait for the user to finish entering data by setting the Mode to 0. This mode is the most commonly used, with [OK] and [Cancel] buttons to either save or discard operator entries and to close the form."
      },
      "helpPath": "FormRead.html"
    },
    "formsaveasfile": {
      "name": "FormSaveAsFile",
      "returnType": "UNKNOWN",
      "params": [
        "sTitle",
        "sFileName",
        "sFilter [",
        "sDefExt]"
      ],
      "doc": "Displays a File Save As dialog box.",
      "returns": "The name and full path of the selected file (as a string) or an empty string (\"\") if the Cancel button is selected.",
      "paramDocs": {
        "sTitle, sFileName, sFilter [, sDefExt]": "FormSaveAsFile(sTitle, sFileName, sFilter [, sDefExt] )",
        "sTitle": "A title to display at the top of the form.",
        "sFileName": "The name of the default file to display in the \"File Name\" field.",
        "sFilter": "A file filter list to display in the \"List Files of Type\" field. The file filter list has the following format:",
        "sDefExt": "The file extension that will be used as a default when you use the FormSaveAsFile() function. If you do not specify a default extension, files will be saved without an extension."
      },
      "helpPath": "FormSaveAsFile.html"
    },
    "formsecurepassword": {
      "name": "FormSecurePassword",
      "returnType": "UNKNOWN",
      "params": [
        "Col",
        "Row",
        "Prompt",
        "Password",
        "Width"
      ],
      "doc": "Adds both a password prompt and edit field to the current form.",
      "returns": "The field handle if it is added successfully, otherwise -1 is returned.",
      "paramDocs": {
        "Col, Row, Prompt, Password, Width": "FormSecurePassword(Col, Row, Prompt, Password, Width)",
        "Col": "The number of the column in which the prompt will be placed. Enter a number from 0 (column 1) to the form width - 1. For example, to place the prompt in column 8, enter 7.",
        "Row": "The number of the row in which the prompt will be placed. Enter a number from 0 (row 1) to the form height - 1. For example, to place the prompt in row 6, enter 5.",
        "Prompt": "The prompt string. Must be a String type variable.",
        "Password": "The encrypted password entered by the operator.",
        "Width": "The width of the edit field."
      },
      "helpPath": "FormSecurePassword.html"
    },
    "formselectprinter": {
      "name": "FormSelectPrinter",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the Select Printer dialog box.",
      "returns": "The name of the selected printer (as a string) or an empty string (\"\") if the Cancel button is selected.",
      "paramDocs": {},
      "helpPath": "FormSelectPrinter.html"
    },
    "formsetdata": {
      "name": "FormSetData",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Sets all the edit data from the string buffers into the form.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm": "FormSetData(hForm)"
      },
      "helpPath": "FormSetData.html"
    },
    "formsetinst": {
      "name": "FormSetInst",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "iData",
        "sData"
      ],
      "doc": "Associates an integer and string value with each field on a form.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField, iData, sData": "FormSetInst(hForm, hField, iData, sData)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected.",
        "iData": "Integer data.",
        "sData": "String data."
      },
      "helpPath": "FormSetInst.html"
    },
    "formsettext": {
      "name": "FormSetText",
      "returnType": "UNKNOWN",
      "params": [
        "hForm",
        "hField",
        "Text"
      ],
      "doc": "Sets new field text on a field. This function allows you to change field text while the form is displayed.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hForm, hField, Text": "FormSetText(hForm, hField, Text)",
        "hForm": "The form handle, returned from the FormNew() function. The form handle identifies the table where all data on the associated form is stored.",
        "hField": "The field handle of the field currently selected. If the hField is a handle to the secure edit field created with FormSecurePassword, the text in the secure edit field will not be changed. However, when an empty string is passed to FormSetText(), the contents of the secure edit field will be cleared.",
        "Text": "New field text."
      },
      "helpPath": "FormSetText.html"
    },
    "formwndhnd": {
      "name": "FormWndHnd",
      "returnType": "UNKNOWN",
      "params": [
        "hForm"
      ],
      "doc": "Gets the window handle for the given form.",
      "returns": "The window handle if successful, otherwise a 0 is returned.",
      "paramDocs": {
        "Wnd...": "Gets the window handle for the given form. The window handle may be used by 'C' programs and Plant SCADAWnd... functions. You should call this function only after the FormRead() function.",
        "Win...": "The window handle is not the same as the Plant SCADA window number and cannot be used with functions that expect the Plant SCADA window number (the Win... functions).",
        "hForm": "FormWndHnd(hForm)"
      },
      "helpPath": "FormWndHnd.html"
    },
    "ftpclose": {
      "name": "FTPClose",
      "returnType": "UNKNOWN",
      "params": [
        "hndFTP"
      ],
      "doc": "Closes an FTP session.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hndFTP": "FTPClose(hndFTP)"
      },
      "helpPath": "FTPClose.html"
    },
    "ftpfilecopy": {
      "name": "FTPFileCopy",
      "returnType": "UNKNOWN",
      "params": [
        "hndFTP",
        "sSrcPath",
        "sDestPath"
      ],
      "doc": "Copies a file from the FTP server to the Internet Display Client.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hndFTP, sSrcPath, sDestPath": "FTPFileCopy(hndFTP, sSrcPath, sDestPath)",
        "hndFTP": "The handle of a valid FTP session, as returned by FTPOpen().",
        "sSrcPath": "The file name and path of the file to be copied from the FTP Server to the Internet Display Client. This can be any FTP server.",
        "sDestPath": "The destination of the copied file (including the name of the file)."
      },
      "helpPath": "FTPFileCopy.html"
    },
    "ftpfilefind": {
      "name": "FTPFileFind",
      "returnType": "UNKNOWN",
      "params": [
        "hndFTP",
        "sPath"
      ],
      "doc": "Finds a file on the FTP server that matches a specified search criteria.",
      "returns": "The full path and filename. If no files are found, an empty string is returned.",
      "paramDocs": {
        "0": "Normal files (includes files with read-only and archived attributes)",
        "1": "Read-only files only",
        "2": "Hidden files only",
        "4": "System files only",
        "16": "Subdirectories only",
        "32": "Archived files only",
        "128": "Files with no attributes only",
        "hndFTP, sPath": "FTPFileFind(hndFTP, sPath)",
        "hndFTP": "The handle of a valid FTP session, as returned by FTPOpen().",
        "sPath": "The path you want to search for the desired file. Do not use path substitution here. To search for multiple files, the wildcards * and ? may be used to match multiple entries.",
        "nMode": "The type of file to check:"
      },
      "helpPath": "FTPFileFind.html"
    },
    "ftpfilefindclose": {
      "name": "FTPFileFindClose",
      "returnType": "UNKNOWN",
      "params": [
        "hndFTP"
      ],
      "doc": "Closes a find (started with FTPFileFind) that did not run to completion.",
      "returns": "0 if no error is detected, or a Cicode error code if an error occurred.",
      "paramDocs": {
        "hndFTP": "FTPFileFindClose(hndFTP)"
      },
      "helpPath": "FTPFileFindClose.html"
    },
    "ftpopen": {
      "name": "FTPOpen",
      "returnType": "UNKNOWN",
      "params": [
        "[sIPAddress] [",
        "sUsername] [",
        "sPassword]"
      ],
      "doc": "Connects to an FTP server.",
      "returns": "A handle to the FTP server otherwise -1 if an error occurs (for example, the server cannot be found).",
      "paramDocs": {
        "[sIPAddress] [, sUsername] [, sPassword]": "FTPOpen( [sIPAddress] [, sUsername] [, sPassword] )",
        "sIPAddress": "The TCP/IP address of the FTP server you wish to connect to (for example, 10.5.6.7 or plant.yourdoman.com). If you do not specify an IP address, the Plant SCADA FTP server running on the Internet Server you are connected to will be used.",
        "sUsername": "The FTP login username. If you omit both the username and IP address, the Plant SCADA FTP password will be used. If you omit just the username, an anonymous logon will occur.",
        "sPassword": "The FTP server password. If you wish to log on anonymously or you wish to log on to the Plant SCADA FTP server, do not specify a password, here."
      },
      "helpPath": "FTPOpen.html"
    },
    "fullname": {
      "name": "FullName",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the full name of the user who is currently logged on to the system. The user can be a Plant SCADA or a Windows user.",
      "returns": "The user name (as a string).",
      "paramDocs": {},
      "helpPath": "FullName.html"
    },
    "fuzzyclose": {
      "name": "FuzzyClose",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy"
      ],
      "doc": "Frees all memory and information for the specified instance.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFuzzy": "Frees all memory and information for the specified instance. After the fuzzy instance is closed, the handle given in the hFuzzy parameter is no longer valid."
      },
      "helpPath": "FuzzyClose.html"
    },
    "fuzzygetcodevalue": {
      "name": "FuzzyGetCodeValue",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy",
        "iIOIndex",
        "NoHitFlag"
      ],
      "doc": "Gets a value for the specified input of the specified instance.",
      "returns": "The code value if the function was successful, otherwise -1. Use IsError() to find the error number if the function does not succeed.",
      "paramDocs": {
        "hFuzzy, iIOIndex, NoHitFlag": "FuzzyGetCodeValue(hFuzzy, iIOIndex, NoHitFlag)",
        "hFuzzy": "The fuzzy instance handle (and integer greater than 0).",
        "iIOIndex": "Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
        "NoHitFlag": "Variable to receive the new value of the No-hit-flag. The No- hit-flag is TRUE if no rule was active for the variable specified by iIOIndex, otherwise it is FALSE. Must be an Integer type variable - it cannot be a constant or PLC variable tag."
      },
      "helpPath": "FuzzyGetCodeValue.html"
    },
    "fuzzygetshellvalue": {
      "name": "FuzzyGetShellValue",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy",
        "iIOIndex",
        "NoHitFlag"
      ],
      "doc": "Gets a value for the specified input of the specified instance.",
      "returns": "The shell value if the function was successful. Use IsError() to find the error number if the function does not succeed.",
      "paramDocs": {
        "hFuzzy, iIOIndex, NoHitFlag": "FuzzyGetShellValue(hFuzzy, iIOIndex, NoHitFlag)",
        "hFuzzy": "The fuzzy instance handle (and integer greater than 0).",
        "iIOIndex": "Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
        "NoHitFlag": "Variable to receive the new value of the No-hit-flag. The No- hit-flag is TRUE if no rule was active for the variable specified by iIOIndex, otherwise it is FALSE. Must be an Integer type variable - it cannot be a constant or PLC variable tag."
      },
      "helpPath": "FuzzyGetShellValue.html"
    },
    "fuzzyopen": {
      "name": "FuzzyOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sFile"
      ],
      "doc": "This function loads a *.FTR file, allocates memory and creates a handle for this fuzzy instance.",
      "returns": "The handle to the fuzzy instance, or -1 if the function cannot complete the operation. Use IsError() to find the error number.",
      "paramDocs": {
        "fuzzy": "fuzzyTECH Online Edition, fuzzyTECH Precompiler Edition, or fuzzyTECH for Business PlusC. And you need to only use fuzzyTECH to generate the *.FTR file for FTRUN.",
        "sFile": "FuzzyOpen(sFile)"
      },
      "helpPath": "FuzzyOpen.html"
    },
    "fuzzysetcodevalue": {
      "name": "FuzzySetCodeValue",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy",
        "iIOIndex",
        "iCodeValue"
      ],
      "doc": "Sets a value for the specified input of the specified instance.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFuzzy, iIOIndex, iCodeValue": "FuzzySetCodeValue(hFuzzy, iIOIndex, iCodeValue)",
        "hFuzzy": "The fuzzy instance handle (and integer greater than 0).",
        "iIOIndex": "Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
        "iCodeValue": "The value to be copied to the variable specified by iIOIndex."
      },
      "helpPath": "FuzzySetCodeValue.html"
    },
    "fuzzysetshellvalue": {
      "name": "FuzzySetShellValue",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy",
        "iIOIndex",
        "rShellValue"
      ],
      "doc": "Sets a value for the specified input of the specified instance.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFuzzy, iIOIndex, rShellValue": "FuzzySetShellValue(hFuzzy, iIOIndex, rShellValue)",
        "hFuzzy": "The fuzzy instance handle (and integer greater than 0).",
        "iIOIndex": "Specifies the variable to receive the value. The I/O-Indices start with 0 and increment by 1 for each variable. To find the correct index for a specific variable, the variables need to be sorted in alpha-numerical order, first the inputs and then the outputs.",
        "rShellValue": "The value to be copied to the variable specified by iIOIndex."
      },
      "helpPath": "FuzzySetShellValue.html"
    },
    "fuzzytrace": {
      "name": "FuzzyTrace",
      "returnType": "UNKNOWN",
      "params": [
        "hFuzzy",
        "TraceOn"
      ],
      "doc": "Controls the trace process (starting and stopping) of the specified instance.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hFuzzy, TraceOn": "FuzzyTrace(hFuzzy, TraceOn)",
        "hFuzzy": "The fuzzy instance handle (and integer greater than 0).",
        "TraceOn": "Specifies whether to start or to stop a trace process for the Fuzzy instanse specified by hFuzzy. If this parameter is TRUE (1), the trace process is started. If this parameter is FALSE (0), the trace process is stopped."
      },
      "helpPath": "FuzzyTrace.html"
    },
    "getarea": {
      "name": "GetArea",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the current logged-in areas.",
      "returns": "The login area groups as an integer that represents a group handle. If this group is modified, the actual login areas do not change.",
      "paramDocs": {},
      "helpPath": "GetArea.html"
    },
    "getbluevalue": {
      "name": "GetBlueValue",
      "returnType": "UNKNOWN",
      "params": [
        "nPackedRGB"
      ],
      "doc": "Returns the Blue component of a packed RGB color.",
      "returns": "The red value (0-255) - if successful, otherwise an error is returned.",
      "paramDocs": {
        "nPackedRGB": "GetBlueValue(nPackedRGB)"
      },
      "helpPath": "GetBlueValue.html"
    },
    "getenv": {
      "name": "GetEnv",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Gets a DOS environment variable.",
      "returns": "The DOS environment variable (as a string).The return value returns up to 255 characters and is truncated if exceeds.",
      "paramDocs": {
        "sName": "GetEnv(sName)"
      },
      "helpPath": "GetEnv.html"
    },
    "getevent": {
      "name": "GetEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nType"
      ],
      "doc": "Gets the function handle of the existing callback event handler.",
      "returns": "The function handle of the existing callback event handler, or -1 if there are no event handlers.",
      "paramDocs": {
        "0": "The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.",
        "1": "A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.",
        "2": "Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.",
        "3": "Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.",
        "4": "Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.",
        "5": "Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.",
        "6": "Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.",
        "7": "Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.",
        "8": "Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.",
        "9": "Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.",
        "10": "Page always. This event is called while a page is active. Reserved for use by Plant SCADA.",
        "18": "Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.",
        "19": "Device history. A device history has just completed. The return value must be 0.",
        "20": "Login. A user has just logged in.",
        "21": "Logout. A user has just logged out.",
        "22": "Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)",
        "23": "Hardware error has been detected.",
        "24": "Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().",
        "25": "Network shutdown. A Shutdown network command has been issued.",
        "26": "Runtime system shutdown and restart. (Required because of configuration changes.)",
        "27": "Event. An event has occurred.",
        "28": "Accumulator. An accumulator has logged a value.",
        "29": "Slider. A slider has been selected.",
        "30": "Slider. A slider has moved.",
        "31": "Slider. A slider has been released (that is stopped moving).",
        "32": "Shutdown. Plant SCADA is being shutdown.",
        "33": "Reserved for Plant SCADA internal use.",
        "34": "Plant SCADA Event: Child Window Close Confirmation.",
        "35": "Plant SCADA Event: Main Window Close Confirmation.",
        "36": "Plant SCADA Event: Maximize Window Confirmation.",
        "37": "Plant SCADA Event: Minimize Window Confirmation.",
        "38": "Plant SCADA Event: Restore Window Confirmation.",
        "39": "Plant SCADA Event: Move Window Confirmation.",
        "40": "Plant SCADA Event: Size Window Confirmation.",
        "41": "Plant SCADA Event: Shutdown Confirmation Confirmation.",
        "42": "Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "43": "Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.",
        "44": "Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "45": "Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.",
        "46": "Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "47": "Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.",
        "48": "Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.",
        "49": "Shutdown Confirmation, when shutdown() function is called.",
        "nType": "GetEvent(nType)",
        "Type": "The type of event:",
        "11..17": "Undefined.",
        "34 - 41": "Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler.",
        "42 to 49": "User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.",
        "50 - 127": "Reserved for future Plant SCADA use.",
        "128 - 256": "User-defined events. These events are for your own use."
      },
      "helpPath": "GetEvent.html"
    },
    "getgreenvalue": {
      "name": "GetGreenValue",
      "returnType": "UNKNOWN",
      "params": [
        "nPackedRGB"
      ],
      "doc": "Returns the green component of a packed RGB color.",
      "returns": "The red value (0-255) - if successful, otherwise an error is returned.",
      "paramDocs": {
        "nPackedRGB": "GetGreenValue(nPackedRGB)"
      },
      "helpPath": "GetGreenValue.html"
    },
    "getlanguage": {
      "name": "GetLanguage",
      "returnType": "UNKNOWN",
      "params": [
        "INT iType"
      ],
      "doc": "Gets the language currently used on the display client.",
      "returns": "The specified information describing the language that is currently in use.",
      "paramDocs": {
        "iType": "STRING GetLanguage(INT iType)"
      },
      "helpPath": "GetLanguage.html"
    },
    "getlogging": {
      "name": "GetLogging",
      "returnType": "UNKNOWN",
      "params": [
        "Section",
        "Name"
      ],
      "doc": "Gets the current value for logging parameters.",
      "returns": "If the function succeeds, the value is returned as a string. An empty string is returned if an error occurs. To get extended error information, call IsError().",
      "paramDocs": {
        "Section, Name": "GetLogging(Section, Name)",
        "Section": "The INI section name.",
        "sName": "The system parameter name."
      },
      "helpPath": "GetLogging.html"
    },
    "getpriv": {
      "name": "GetPriv",
      "returnType": "UNKNOWN",
      "params": [
        "Priv",
        "Area"
      ],
      "doc": "Checks if the current user has a privilege for a specified area.",
      "returns": "Returns 1 if the user has the specified privilege in the area, or 0 (zero) if the user does not have the privilege.",
      "paramDocs": {
        "Priv, Area": "GetPriv(Priv, Area)",
        "Priv": "Priv",
        "Area": "Area"
      },
      "helpPath": "GetPriv.html"
    },
    "getredvalue": {
      "name": "GetRedValue",
      "returnType": "UNKNOWN",
      "params": [
        "nPackedRGB"
      ],
      "doc": "Returns the red component of a packed RGB color.",
      "returns": "The red value (0-255) - if successful, otherwise an error is returned.",
      "paramDocs": {
        "nPackedRGB": "GetRedValue(nPackedRGB)"
      },
      "helpPath": "GetRedValue.html"
    },
    "getwintitle": {
      "name": "GetWinTitle",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns the name of the active window as a string.",
      "returns": "The title of the active window as a string if successful; otherwise, an error is returned.",
      "paramDocs": {},
      "helpPath": "GetWinTitle.html"
    },
    "grpclose": {
      "name": "GrpClose",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp"
      ],
      "doc": "Closes a group.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hGrp": "GrpClose(hGrp)"
      },
      "helpPath": "GrpClose.html"
    },
    "grpdelete": {
      "name": "GrpDelete",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "Value"
      ],
      "doc": "Deletes a single element or all elements from a group.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hGrp, Value": "GrpDelete(hGrp, Value)",
        "hGrp": "The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
        "Value": "The element to delete from the group, from 0 to 16375."
      },
      "helpPath": "GrpDelete.html"
    },
    "grpfirst": {
      "name": "GrpFirst",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp"
      ],
      "doc": "Gets the value of the first element in a group.",
      "returns": "The value of the first element in a group or -1 if the group is empty.",
      "paramDocs": {
        "hGrp": "GrpFirst(hGrp)"
      },
      "helpPath": "GrpFirst.html"
    },
    "grpin": {
      "name": "GrpIn",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "Value"
      ],
      "doc": "Determines if an element is in a group.",
      "returns": "1 if the element is in the group, otherwise 0 is returned.",
      "paramDocs": {
        "hGrp, Value": "GrpIn(hGrp, Value)",
        "hGrp": "The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
        "Value": "The element to locate, from 0 to 16375."
      },
      "helpPath": "GrpIn.html"
    },
    "grpinsert": {
      "name": "GrpInsert",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "Value"
      ],
      "doc": "Adds an element (or another group) to a group.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hGrp, Value": "GrpInsert(hGrp, Value)",
        "hGrp": "The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
        "Value": "The element to add to the group, from 0 to 16375."
      },
      "helpPath": "GrpInsert.html"
    },
    "grpmath": {
      "name": "GrpMath",
      "returnType": "UNKNOWN",
      "params": [
        "hResult",
        "hOne",
        "hTwo",
        "Type"
      ],
      "doc": "Performs mathematical operations on two groups, and stores the result in another group.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Add groups one and two.",
        "1": "Subtract group two from group one.",
        "2": "AND groups one and two.",
        "3": "NOT groups one and two.",
        "4": "XOR groups one and two.",
        "hResult, hOne, hTwo, Type": "GrpMath(hResult, hOne, hTwo, Type)",
        "hResult": "The group number where the result is placed.",
        "hOne": "Number of first group used in the mathematical operation.",
        "hTwo": "Number of the second group used in the mathematical operation.",
        "nType": "Type of mathematical operation:"
      },
      "helpPath": "GrpMath.html"
    },
    "grpname": {
      "name": "GrpName",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp"
      ],
      "doc": "Gets the name of a group from a group handle.",
      "returns": "The name of the group (as a string).",
      "paramDocs": {
        "hGrp": "GrpName(hGrp)"
      },
      "helpPath": "GrpName.html"
    },
    "grpnext": {
      "name": "GrpNext",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "Value"
      ],
      "doc": "Gets the value of the next element in a group.",
      "returns": "The value of the next element in a group, or -1 if the end of the group has been found.",
      "paramDocs": {
        "hGrp, Value": "GrpNext(hGrp, Value)",
        "hGrp": "The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
        "Value": "The value returned from GrpFirst() or the latest GrpNext() call."
      },
      "helpPath": "GrpNext.html"
    },
    "grpopen": {
      "name": "GrpOpen",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "nMode"
      ],
      "doc": "Creates a group and returns a group handle, or gets the group handle of an existing group.",
      "returns": "The group handle , or -1 if the group cannot be created or opened. The group handle identifies the table where data on the associated group is stored.",
      "paramDocs": {
        "0": "Open an existing group",
        "1": "Create a new group",
        "2": "Attempts to open an existing group. If the group does not exist, it will create it.",
        "sName, nMode": "GrpOpen(sName, nMode)",
        "sName": "sName",
        "Mode": "Mode"
      },
      "helpPath": "GrpOpen.html"
    },
    "grptostr": {
      "name": "GrpToStr",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp"
      ],
      "doc": "Converts a group into a string of values separated by \" , \" and \" .. \". You can then display the group on the screen or in a report.",
      "returns": "The group (as a string).",
      "paramDocs": {
        "hGrp": "GrpToStr(hGrp)"
      },
      "helpPath": "GrpToStr.html"
    },
    "halt": {
      "name": "Halt",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Stops the execution of the current Cicode task and returns to Plant SCADA.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "Halt.html"
    },
    "hextostr": {
      "name": "HexToStr",
      "returnType": "UNKNOWN",
      "params": [
        "Number",
        "Width"
      ],
      "doc": "Converts a number into a hexadecimal string.",
      "returns": "A string containing the converted number.",
      "paramDocs": {
        "Number, Width": "HexToStr(Number, Width)",
        "Number": "The number to convert.",
        "Width": "The width of the string (0 to 8)."
      },
      "helpPath": "HexToStr.html"
    },
    "highbyte": {
      "name": "HighByte",
      "returnType": "UNKNOWN",
      "params": [
        "TwoByteInteger"
      ],
      "doc": "Gets the high-order byte of a two-byte integer.",
      "returns": "The high-order byte (that is | X | - |)",
      "paramDocs": {
        "TwoByteInteger": "HighByte(TwoByteInteger)"
      },
      "helpPath": "HighByte.html"
    },
    "highword": {
      "name": "HighWord",
      "returnType": "UNKNOWN",
      "params": [
        "FourByteInteger"
      ],
      "doc": "Gets the high-order word of a four-byte integer.",
      "returns": "The high-order word (that is | X | X | - | - |)",
      "paramDocs": {
        "FourByteInteger": "HighWord(FourByteInteger)"
      },
      "helpPath": "HighWord.html"
    },
    "hwalarmque": {
      "name": "HwAlarmQue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns the handle of the hardware alarm queue.",
      "returns": "The handle of the hardware alarm queue, or -1 if the queue cannot be opened.",
      "paramDocs": {},
      "helpPath": "HwAlarmQue.html"
    },
    "infoform": {
      "name": "InfoForm",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "Displays graphics object information for the object under the mouse pointer. If there is no object directly under the mouse pointer, it displays information for the nearest object.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "The Write button on the displayed information form will be available and will function normally.",
        "1": "The Write button will not be shown.",
        "Mode": "InfoForm(Mode)"
      },
      "helpPath": "InfoForm.html"
    },
    "infoforman": {
      "name": "InfoFormAn",
      "returnType": "UNKNOWN",
      "params": [
        "AN [",
        "Mode]"
      ],
      "doc": "Displays graphics object information for a specified AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "The Write button on the displayed information form will be available and will function normally.",
        "1": "The Write button will not be shown.",
        "AN [": "InfoFormAn(AN [, Mode] )",
        "nAN": "The AN of the graphics object for which information is displayed.",
        "Mode": "For security purposes, the Write button on the information form displayed by this function can be disabled."
      },
      "helpPath": "InfoFormAn.html"
    },
    "input": {
      "name": "Input",
      "returnType": "UNKNOWN",
      "params": [
        "Title",
        "Prompt",
        "Default"
      ],
      "doc": "Displays a dialog box in which an operator can input a single value.",
      "returns": "The edit field entry (as a string). If the user presses the Cancel button , an empty string is returned and the IsError() function returns the error code 299.",
      "paramDocs": {
        "Title, Prompt, Default": "Input(Title, Prompt, Default)",
        "Title": "The title of the input box.",
        "Prompt": "The prompt text.",
        "Default": "The default text that the operator can edit or replace."
      },
      "helpPath": "Input.html"
    },
    "inttoreal": {
      "name": "IntToReal",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Converts an integer into a real (floating point) number.",
      "returns": "The real number.",
      "paramDocs": {
        "Number": "IntToReal(Number)"
      },
      "helpPath": "IntToReal.html"
    },
    "inttostr": {
      "name": "IntToStr",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Converts a number into a string.",
      "returns": "A string containing the converted number.",
      "paramDocs": {
        "Number": "IntToStr(Number)"
      },
      "helpPath": "IntToStr.html"
    },
    "iodevicecontrol": {
      "name": "IODeviceControl",
      "returnType": "UNKNOWN",
      "params": [
        "IODevice",
        "nType",
        "Data [",
        "sClusterName] [",
        "ServerName]"
      ],
      "doc": "Provides control of individual I/O devices.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "No longer supported.",
        "1": "Enable/Disable the I/O device on the I/O server. If disabled, attempts to read and write from the I/O device are ignored. (If another I/O device is configured as a standby I/O server, Plant SCADA switches communications to that I/O device.) The I/O server does not attempt to communicate with the I/O device until it is re-enabled. When the I/O device is re-enabled, the I/O server attempts to re-establish communication immediately. Mode 1 can only be called by the I/O Server which is associated with this device.",
        "2": "No longer supported. An invalid argument error is returned if this option is specified.",
        "3": "No longer supported. An invalid argument error is returned if this option is specified.",
        "4": "The data in the associated I/O device cache is flushed. This allows flushing of the data from the I/O device without waiting for the aging time. This is useful when you have long cache time and you want to force a read from the I/O device.",
        "5": "(For scheduled and remote I/O devices). The I/O device is added to the bottom of the list of I/O devices to be contacted. I/O devices already in the list (already waiting to be contacted) are given priority over this I/O device.",
        "6": "(For scheduled and remote I/O devices). The I/O device is added to the top of the list of I/O devices to be contacted; it is given high priority. If there are already I/O devices at the top of the list with high priority, then this I/O device will be added to the list after them (that is it will be contacted after them). For dial-up remote I/O devices, if the modem is already in use - connected to another I/O device - this I/O device will not be dialled until that connection has been terminated.",
        "7": "(For scheduled and remote I/O devices). The I/O device is added to the top of the list of I/O devices to be contacted, and it is given top priority. For dial-up remote I/O devices, if the modem is currently connected to another I/O device, the connection will be cancelled, and the top priority I/O device will be dialled. It will also stay connected until manually disconnected with another call to IODeviceControl().",
        "8": "(For scheduled and remote I/O devices). Disconnect an I/O device. Current requests will be completed before the I/O device is disconnected.",
        "9": "(For scheduled I/O devices). The communication schedule for the I/O device is disabled. This is to minimize the likelihood that the I/O device will be contacted when its scheduled dial-time occurs.",
        "10": "(For scheduled I/O devices). Puts the I/O device into Write On Request mode. That is, as soon as a write request is made, the I/O device will be added to the list of I/O devices to be contacted. It is given priority over existing read requests, but not over existing write requests.",
        "11": "Change the I/O device cache timeout. If the I/O Server is restarted, the cache timeout will return to its original value. (For scheduled I/O devices, this value can be checked using the Kernel Page Unit command. For all other I/O devices, this value is configured in the Cache Time field at the I/O Devices Properties form.)",
        "12": "The time of day at which to add the I/O device to the list of I/O devices to be contacted. Set the time in Data in seconds from midnight (for example, specify 6 p.m. as 18 * 60 * 60). Use Type 12 to specify a one-timecommunication.",
        "13": "The communication period (the time between successive communication attempts). The value you specify represents different periods, depending on what type of schedule you are using (that is daily, weekly, monthly, or yearly. This is set using Type 15.). You can choose to specify the communication period either in seconds from midnight, day of week (0 to 6, Sunday = 0), month (1 to 12), or year. Enter the value in Data. For example, if your schedule is weekly, and you set Data = 3, you are specifying each Wednesday. If your schedule is monthly, Data = 3 indicates March. For daily communication, set the period in Data in seconds from midnight; for example, set Data to 6 * 60 * 60 to contact the I/O device every 6 hours.",
        "14": "The time at which the I/O Server will first attempt to communicate with the I/O device. Set the time in Data in seconds from midnight, for example, to synchronize at 10a.m., set Data to 10 * 60 * 60.",
        "15": "Type of schedule. Set Data to one of the following:",
        "16": "(For remote I/O devices) Read all tags from the I/O device. Data is unused - set it to 0 (zero).",
        "18": "Set Control Inhibit (Control Mode) for all tags of the I/O device.",
        "IODevice, nType, Data [, sClusterName] [, ServerName]": "IODeviceControl(IODevice, nType, Data [, sClusterName] [, ServerName] )",
        "IODevice": "The number or name of the I/O device. If you call this function from an I/O server, you can use the I/O device name. If you call this function from a client, you may use either the I/O device number or name. To specify all I/O devices, use \"*\" (asterisk) or -1.",
        "nType": "The type of control action:",
        "Data": "Data for the control operation*:",
        "sClusterName": "Specifies the name of the cluster in which the I/O Server resides. This is optional if you have one cluster or are resolving the I/O server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "IODeviceControl.html"
    },
    "iodeviceinfo": {
      "name": "IODeviceInfo",
      "returnType": "UNKNOWN",
      "params": [
        "IODevice",
        "Type [",
        "sClusterName] [",
        "ServerName]"
      ],
      "doc": "Gets information about a specified I/O device.",
      "returns": "The type of information (as a string).",
      "paramDocs": {
        "0": "Name of I/O device",
        "1": "Protocol of I/O device",
        "2": "Protocol address",
        "3": "Client I/O device state",
        "4": "Current generic error number (decimal)",
        "5": "Current driver error number (decimal)",
        "6": "Disabled flag",
        "7": "Statistics, minimum read time",
        "8": "Statistics, maximum read time",
        "9": "Statistics, average read time",
        "10": "I/O server I/O device state",
        "11": "Unit number",
        "12": "Configured I/O server name",
        "13": "Configured Port name",
        "14": "Configured startup mode",
        "15": "Configured comment",
        "16": "The primary I/O server name the client uses to communicate to this device",
        "17": "The I/O Server the client is using to communicate to this device. Will be Standby if the Primary is down.",
        "18": "State of the remote unit:",
        "19": "Number of successful attempts to communicate with the scheduled I/O device.",
        "20": "Number of unsuccessful attempts to communicate with the scheduled I/O device.",
        "21": "Write mode: Write On Request, and normal (as per schedule defined in the Express Communications Wizard).",
        "22": "Number of queued read requests for the scheduled I/O device. (This mode causes redirection to the I/O server if running in separate processes.)",
        "23": "Number of queued write requests for the scheduled I/O device. (This mode causes redirection to the I/O server if running in separate processes.)",
        "24": "The cache timeout (in milliseconds).",
        "26": "The name of the line device (for example, modem) you are using to connect to the I/O device. (This mode causes redirection to the I/O server if running in separate processes.)",
        "27": "The call_status of a currently connected remote I/O device.",
        "28": "The call rate (in bits per second) which may be the DTE or DCE connection speed depending on the server modem settings. (This mode causes redirection to the I/O server if running in separate processes.)",
        "30": "The last time an I/O device from the remote I/O device redundant group was connected (primary or any standbys).",
        "31": "The state of the remote I/O device redundant group:",
        "32": "The next time the specified I/O device is scheduled to connect (unless a higher priority I/O device comes online).",
        "Type": "Apart from when Type is set to 3 or 17, this function can only be used if the I/O Server is on the current machine, otherwise the function will not succeed and will return empty string. When the I/O Server is not in the calling process, this function will become blocking and cannot be called from a foreground task. In this case, the return value will be undefined and a Cicode hardware alarm will be raised.",
        "IODevice, Type [, sClusterName] [, ServerName]": "IODeviceInfo(IODevice, Type [, sClusterName] [, ServerName])",
        "IODevice": "The I/O device number, or the I/O device name enclosed in double quotes.",
        "nType": "The type of information:",
        "sClusterName": "Specifies the name of the cluster in which the I/O Server resides. This is optional if you have one cluster or are resolving the I/O server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "IODeviceInfo.html"
    },
    "iodevicestats": {
      "name": "IODeviceStats",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets statistical information for all I/O devices, and displays the information in a dialog box.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "IODeviceStats.html"
    },
    "iserror": {
      "name": "IsError",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the current error value. The error value is set when any error is detected, and is reset after this function is called.",
      "returns": "The current error value. The current error is reset to 0 after this function is called.",
      "paramDocs": {},
      "helpPath": "IsError.html"
    },
    "kercmd": {
      "name": "KerCmd",
      "returnType": "UNKNOWN",
      "params": [
        "Window",
        "sCommand"
      ],
      "doc": "Executes a command in a Kernel window.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Window, sCommand": "KerCmd(Window, sCommand)",
        "Window": "The name of the Kernel window.",
        "sCommand": "The command to execute in the Kernel window."
      },
      "helpPath": "KerCmd.html"
    },
    "kernelqueuelength": {
      "name": "KernelQueueLength",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Obtains the number of records in a queue.",
      "returns": "This function returns the Length value of the page queue command.",
      "paramDocs": {
        "sName": "KernelQueueLength(sName)"
      },
      "helpPath": "KernelQueueLength.html"
    },
    "kerneltableinfo": {
      "name": "KernelTableInfo",
      "returnType": "UNKNOWN",
      "params": [
        "sTable",
        "sRecord",
        "sField"
      ],
      "doc": "Provides a consistent method of accessing items within Kernel Table.",
      "returns": "Returns the content of a field of the given table in the format of a Cicode STRING.",
      "paramDocs": {
        "sTable, sRecord, sField": "KernelTableInfo(sTable, sRecord, sField)",
        "sTable": "The name of the table. The following tables are supported:",
        "sRecord": "The key to a column in the table depending on the sTable parameter.",
        "sField": "The key to a column in the table depending on the sTable parameter."
      },
      "helpPath": "KernelTableInfo.html"
    },
    "kerneltableitemcount": {
      "name": "KernelTableItemCount",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Obtains the number of rows in a Kernel Table.",
      "returns": "Returns the number of active records in the table (not the length value displayed by the page table kernel command).",
      "paramDocs": {
        "sName": "KernelTableItemCount(sName)"
      },
      "helpPath": "KernelTableItemCount.html"
    },
    "keyallowcursor": {
      "name": "KeyAllowCursor",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "State"
      ],
      "doc": "Allows (or disallows) the command cursor to move to the specified AN or to all ANs.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Do not allow the cursor to move to this AN.",
        "1": "Allow the cursor to move to this AN.",
        "nAN, State": "KeyAllowCursor(nAN, State)",
        "nAN": "The AN where the command cursor can move. If 0, all ANs are implied.",
        "State": "Allow state:"
      },
      "helpPath": "KeyAllowCursor.html"
    },
    "keybs": {
      "name": "KeyBs",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Removes the last key from the key command line.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyBs.html"
    },
    "keydown": {
      "name": "KeyDown",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Moves the command cursor down the page to the closest AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyDown.html"
    },
    "keyget": {
      "name": "KeyGet",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the last key code from the key command line.",
      "returns": "The last key code from the key command line. If the key command line is empty, 0 (zero) is returned.",
      "paramDocs": {},
      "helpPath": "KeyGet.html"
    },
    "keygetcursor": {
      "name": "KeyGetCursor",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the AN at the position of the command cursor.",
      "returns": "The AN at the position of the command cursor. If no cursor is visible, -1 is returned.",
      "paramDocs": {},
      "helpPath": "KeyGetCursor.html"
    },
    "keyleft": {
      "name": "KeyLeft",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Moves the command cursor left (across the page) to the closest AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyLeft.html"
    },
    "keymove": {
      "name": "KeyMove",
      "returnType": "UNKNOWN",
      "params": [
        "Direction"
      ],
      "doc": "Moves the command cursor in a specified direction to the closest AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Do not move",
        "1": "Left",
        "2": "Right",
        "3": "Up",
        "4": "Down",
        "Direction": "KeyMove(Direction)"
      },
      "helpPath": "KeyMove.html"
    },
    "keypeek": {
      "name": "KeyPeek",
      "returnType": "UNKNOWN",
      "params": [
        "Offset"
      ],
      "doc": "Gets the ascii key code from the key command line (at a specified offset), without removing the key from the key command line.",
      "returns": "The ASCII key code.",
      "paramDocs": {
        "Offset": "KeyPeek(Offset)"
      },
      "helpPath": "KeyPeek.html"
    },
    "keyput": {
      "name": "KeyPut",
      "returnType": "UNKNOWN",
      "params": [
        "KeyCode"
      ],
      "doc": "Puts an ASCII key code or Keyboard key code into the last position of the key command line.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "KeyCode": "KeyPut(KeyCode)"
      },
      "helpPath": "KeyPut.html"
    },
    "keyputstr": {
      "name": "KeyPutStr",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Puts a string at the end of the key command line. The string can contain either key names or data characters.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "String": "KeyPutStr(String)"
      },
      "helpPath": "KeyPutStr.html"
    },
    "keyreplay": {
      "name": "KeyReplay",
      "returnType": "UNKNOWN",
      "params": [
        "sub"
      ],
      "doc": "Replays the last key sequence (except for the last key, which would execute the command).",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sub": "KeyReplay(sub)"
      },
      "helpPath": "KeyReplay.html"
    },
    "keyreplayall": {
      "name": "KeyReplayAll",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Replays the last key sequence and executes the command.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyReplayAll.html"
    },
    "keyright": {
      "name": "KeyRight",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Moves the command cursor right (across the page) to the closest AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyRight.html"
    },
    "keysetcursor": {
      "name": "KeySetCursor",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Displays the command cursor at a specified AN.",
      "returns": "If the AN does not exist, or if a command does not exist at that AN, or if KeyAllowCursor() has not been called, the return value is 1. Otherwise, the function will return 0.",
      "paramDocs": {
        "nAN": "KeySetCursor(nAN)"
      },
      "helpPath": "KeySetCursor.html"
    },
    "keysetseq": {
      "name": "KeySetSeq",
      "returnType": "UNKNOWN",
      "params": [
        "sKeySeq",
        "AN",
        "Fn"
      ],
      "doc": "Adds a keyboard sequence to the current page at runtime. The key sequence is only added to the current window.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sKeySeq, AN, Fn": "KeySetSeq(sKeySeq, AN, Fn)",
        "sKeySeq": "The keyboard sequence.",
        "nAN": "The AN where the keyboard sequence will apply. If you set AN to 0 (zero), the keyboard sequence will apply to all ANs on the page.",
        "Fn": "The function to call when the keyboard sequence matches. This function needs to be a callback function."
      },
      "helpPath": "KeySetSeq.html"
    },
    "keyup": {
      "name": "KeyUp",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Moves the command cursor up the page to the closest AN.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "KeyUp.html"
    },
    "languagefiletranslate": {
      "name": "LanguageFileTranslate",
      "returnType": "UNKNOWN",
      "params": [
        "sSourceFile",
        "sDestFile"
      ],
      "doc": "Translates an ASCII file into a local language. Use this function to translate RTF reports for viewing on client screens.",
      "returns": "1 if successful, otherwise 0.",
      "paramDocs": {
        "sSourceFile, sDestFile": "LanguageFileTranslate(sSourceFile, sDestFile)",
        "sSourceFile": "The name of the ASCII file containing multi-language text, which will be copied and translated. You should specify the full path or use path substitution. The path and name should be contained within quotation marks.",
        "sDestFile": "The name of the destination file which will be created/ replaced with the local/translated version of the source file. You should specify the full path or use path substitution. The path and name should be contained within quotation marks."
      },
      "helpPath": "LanguageFileTranslate.html"
    },
    "leavecriticalsection": {
      "name": "LeaveCriticalSection",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Relinquishes the current thread's ownership of a critical section (shared critical resource).",
      "returns": "This function does not return a value.",
      "paramDocs": {
        "sName": "LeaveCriticalSection(sName)"
      },
      "helpPath": "LeaveCriticalSection.html"
    },
    "libalarmfilterform": {
      "name": "LibAlarmFilterForm",
      "returnType": "UNKNOWN",
      "params": [
        "[INT FormType [",
        "STRING FilterSrc [",
        "STRING Title [",
        "INT Mode [",
        "STRING AppliedCallbackFn]]]]]"
      ],
      "doc": "Displays a generic alarm filter pop-up for specifying filtering criteria for either an alarm list or a named filter.",
      "returns": "1 if filter has been applied, 0 if filter has been cleared, or -1 if no change is made",
      "paramDocs": {
        "([INT FormType [, STRING FilterSrc [, STRING Title [, INT Mode [, STRING AppliedCallbackFn]]]]])": "INT LibAlarmFilterForm([INT FormType [, STRING FilterSrc [, STRING Title [, INT Mode [, STRING AppliedCallbackFn]]]]])"
      },
      "helpPath": "LibAlarmFilterForm.html"
    },
    "ln": {
      "name": "Ln",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the natural (base e) logarithm of a number.",
      "returns": "The natural (base e) logarithm of Number.",
      "paramDocs": {
        "Number": "Ln(Number)",
        "Number.": "The natural (base e) logarithm of Number."
      },
      "helpPath": "Ln.html"
    },
    "log": {
      "name": "Log",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Calculates the base 10 logarithm of a number.",
      "returns": "The base 10 logarithm of Number.",
      "paramDocs": {
        "Number": "Log(Number)",
        "Number.": "The base 10 logarithm of Number."
      },
      "helpPath": "Log.html"
    },
    "login": {
      "name": "Login",
      "returnType": "UNKNOWN",
      "params": [
        "sUserName",
        "sPassword [",
        "bSync][",
        "sLanguage]"
      ],
      "doc": "Logs a user into the system using Plant SCADA security and gives users access to the areas and privileges assigned to them in the Users database. Not available when logged in as Windows user.",
      "returns": "0 (zero) if successful.",
      "paramDocs": {
        "sUserName, sPassword [, bSync]": "Login(sUserName, sPassword [, bSync][, sLanguage])",
        "sUserName": "The user's name, as defined in the Users database.",
        "sPassword": "The user's password, as defined in the Users database.",
        "bSync": "Optionally specifies whether the function operates in blocking or non-blocking mode. If set to 1 blocks caller until login is complete. If set to 0 (default) does not block caller.",
        "sLanguage": "The specified language needs to be one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line."
      },
      "helpPath": "Login.html"
    },
    "loginform": {
      "name": "LoginForm",
      "returnType": "UNKNOWN",
      "params": [
        "[sUserName [",
        "sPassword [",
        "sLanguage]]]"
      ],
      "doc": "Displays a form in which a user can log in to the system by entering their name and password and local language.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "[sUserName [, sPassword [, sLanguage": "LoginForm([sUserName [, sPassword [, sLanguage]]])",
        "sUserName": "Optionally, the user's name, as defined in the Users database.",
        "sPassword": "Optionally, the user's password, as defined in the Users database.",
        "sLanguage": "The specified language must be one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line."
      },
      "helpPath": "LoginForm.html"
    },
    "logout": {
      "name": "Logout",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Logs the current user out of the Plant SCADA system.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "Logout.html"
    },
    "logoutidle": {
      "name": "LogoutIdle",
      "returnType": "UNKNOWN",
      "params": [
        "Idle"
      ],
      "doc": "Sets an idle time for logging out the current user.",
      "returns": "No return value.",
      "paramDocs": {
        "Idle": "LogoutIdle(Idle)"
      },
      "helpPath": "LogoutIdle.html"
    },
    "lowbyte": {
      "name": "LowByte",
      "returnType": "UNKNOWN",
      "params": [
        "TwoByteInteger"
      ],
      "doc": "Gets the low-order byte of a two-byte integer.",
      "returns": "The low-order byte (that is | - | X |)",
      "paramDocs": {
        "TwoByteInteger": "LowByte(TwoByteInteger)"
      },
      "helpPath": "LowByte.html"
    },
    "lowword": {
      "name": "LowWord",
      "returnType": "UNKNOWN",
      "params": [
        "FourByteInteger"
      ],
      "doc": "Gets the low-order word of a four-byte integer.",
      "returns": "The low-order word (that is | - | - | X | X |)",
      "paramDocs": {
        "FourByteInteger": "LowWord(FourByteInteger)"
      },
      "helpPath": "LowWord.html"
    },
    "mailerror": {
      "name": "MailError",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the last mail error code. The error code is extracted from the MAPI mail system.",
      "returns": "0 (zero) if successful, otherwise an error is returned. Refer also to MAPI errors.",
      "paramDocs": {},
      "helpPath": "MailError.html"
    },
    "maillogoff": {
      "name": "MailLogoff",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Logs off from the mail system.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "MailLogoff.html"
    },
    "maillogon": {
      "name": "MailLogon",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sPassword",
        "iMode"
      ],
      "doc": "Logs on to the mail system.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Normal logon.",
        "2": "Get unique logon, do not share existing mail client logon.",
        "sName, sPassword, iMode": "MailLogon(sName, sPassword, iMode)",
        "sName": "The name of the mail user. This name is the user's mail box name (the unique shorthand name, not the full user's name).",
        "sPassword": "The password of the mail user.",
        "iMode": "The mode of the logon:"
      },
      "helpPath": "MailLogon.html"
    },
    "mailread": {
      "name": "MailRead",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sSubject",
        "sNote",
        "sFileName",
        "iMode"
      ],
      "doc": "Reads a standard mail message. The mail message can contain text, an attached file, or both.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Read a message. If no message is available, wait for a message.",
        "1": "Read a message. If no message is available, return with an error code.",
        "sName, sSubject, sNote, sFileName, iMode": "MailRead(sName, sSubject, sNote, sFileName, iMode)",
        "sName": "The name of the mail user who sent the message. Must be a String type variable.",
        "sSubject": "The subject text of the mail message. Must be a String type variable.",
        "sNote": "The note section of the message. If the message is longer than 255 characters, Plant SCADA will save the message in a file and return the file name in sNote. Use the file functions to read the message. The name of the file will be in the form CTxxxxx where x is a unique number. You need to delete the file after you have finished with the mail message. Must be a String type variable.",
        "sFileName": "The name of any attached file. If there is no attached file in the message, specify sFileName as an empty string \"\". Must be a String type variable.",
        "iMode": "The mode of the read:"
      },
      "helpPath": "MailRead.html"
    },
    "mailsend": {
      "name": "MailSend",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sSubject",
        "sNote",
        "sFileName",
        "iMode"
      ],
      "doc": "Sends a standard mail message. The mail message can contain text, an attached file, or both.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Normal mail message.",
        "1": "The sNote argument is the name of a text file to send as the note.",
        "sName, sSubject, sNote, sFileName, iMode": "MailSend(sName, sSubject, sNote, sFileName, iMode)",
        "sName": "The name of the mail user who will receive the message. This name is the user's full name (not their mailbox name).",
        "sSubject": "The subject text of the mail message (a short description of what the message is about).",
        "sNote": "The note section of the message (the main section of the message text). You can enter up to 255 characters, or a file name for longer messages. If you enter a file name, set iMode to 1.",
        "sFileName": "The name of any attached file. If there is no attached file in the message, set sFileName to an empty string \"\".",
        "iMode": "The mode of the send:"
      },
      "helpPath": "MailSend.html"
    },
    "makecitectcolour": {
      "name": "MakeCitectColour",
      "returnType": "UNKNOWN",
      "params": [
        "nRed",
        "nGreen",
        "nBlue"
      ],
      "doc": "Creates a color from red, green and blue component parts.",
      "returns": "An integer that is an encoded representation of the color created.",
      "paramDocs": {
        "nRed,nGreen,nBlue": "MakeCitectColour(nRed,nGreen,nBlue)",
        "nRed": "The color value for red, from 0-255",
        "nGreen": "The color value for green, from 0-255",
        "nBlue": "The color value for blue, from 0-255"
      },
      "helpPath": "MakeCitectColour.html"
    },
    "mapclear": {
      "name": "MapClear",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName"
      ],
      "doc": "Clear all entries in a map.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "INT MapClear(STRING sMapName)"
      },
      "helpPath": "MapClear.html"
    },
    "mapclose": {
      "name": "MapClose",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName"
      ],
      "doc": "Closes a previously created map.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "INT MapClose(STRING sMapName)"
      },
      "helpPath": "MapClose.html"
    },
    "mapexists": {
      "name": "MapExists",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName"
      ],
      "doc": "Checks for the existence of the map.",
      "returns": "TRUE if the map exists, or FALSE if not.",
      "paramDocs": {
        "sMapName": "INT MapExists(STRING sMapName)"
      },
      "helpPath": "MapExists.html"
    },
    "mapkeycount": {
      "name": "MapKeyCount",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName"
      ],
      "doc": "Retrieves the number of keys in a map.",
      "returns": "The number of keys in the map, or a value less than 0 if an error is encountered.",
      "paramDocs": {
        "sMapName": "Name of the map."
      },
      "helpPath": "MapKeyCount.html"
    },
    "mapkeydelete": {
      "name": "MapKeyDelete",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName"
      ],
      "doc": "Use this function to delete a key and value from a map.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "INT MapKeyDelete(STRING sMapName, STRING sKeyName)",
        "sKeyName": "Name of key and value to be deleted."
      },
      "helpPath": "MapKeyDelete.html"
    },
    "mapkeyexists": {
      "name": "MapKeyExists",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName"
      ],
      "doc": "Checsk if a key exists in a map.",
      "returns": "TRUE if the map exists, or FALSE if not.",
      "paramDocs": {
        "sMapName": "INT MapKeyExists(STRING sMapName, STRING sKeyName)",
        "sKeyName": "Name of the key to get the value from."
      },
      "helpPath": "MapKeyExists.html"
    },
    "mapkeyfirst": {
      "name": "MapKeyFirst",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName"
      ],
      "doc": "Use this function to retrieve the first property key in a cicode object.",
      "returns": "The first key in the map, if there are no keys in the map and empty string is returned.",
      "paramDocs": {
        "sMapName": "Name of map to get the value from."
      },
      "helpPath": "MapKeyFirst.html"
    },
    "mapkeynext": {
      "name": "MapKeyNext",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName"
      ],
      "doc": "Retrieves the next key after the supplied key in a map.",
      "returns": "The next key if successful or, an empty string if no next key exists.",
      "paramDocs": {
        "sMapName": "STRING MapKeyNext(STRING sMapName, STRING sKeyName)",
        "sKeyName": "Name of the key to retrieve the value for."
      },
      "helpPath": "MapKeyNext.html"
    },
    "mapopen": {
      "name": "MapOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "INT nOpenMode",
        "STRING sCloseCallback"
      ],
      "doc": "Creates a new map or to open an existing map.",
      "returns": "Name of map if successful, otherwise an empty string will be returned.",
      "paramDocs": {
        "sMapName": "STRING MapOpen(STRING sMapName, INT nOpenMode, STRING sCloseCallback)",
        "nOpenMode": "Indicates the open or create mode of the map. Modes include:",
        "sCloseCallback": "The function to call when this instance is closed."
      },
      "helpPath": "MapOpen.html"
    },
    "mapvalueget": {
      "name": "MapValueGet",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName"
      ],
      "doc": "Gets the value from a key in a map.",
      "returns": "Value returned is a VARIANT that also contains QUALITY and TIMESTAMP components, otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "VARIANT MapValueGet(STRING sMapName, STRING sKeyName)",
        "sKeyName": "Name of the key to retrieve the value from."
      },
      "helpPath": "MapValueGet.html"
    },
    "mapvalueset": {
      "name": "MapValueSet",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName",
        "VARIANT Value INT nSetMode"
      ],
      "doc": "Sets a value of a map key.",
      "returns": "If the value is set correctly, the result is No Error (0), otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "INT MapValueSet(STRING sMapName, STRING sKeyName, VARIANT Value INT nSetMode)",
        "sKeyName": "Name of the key to set.",
        "Value": "Name of the value to be set",
        "nSetMode": "0 - Create a new property"
      },
      "helpPath": "MapValueSet.html"
    },
    "mapvaluesetquality": {
      "name": "MapValueSetQuality",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sMapName",
        "STRING sKeyName",
        "QUALITY Quality"
      ],
      "doc": "Sets the quality of a property in a cicode object.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sMapName": "INT MapValueSetQuality(STRING sMapName, STRING sKeyName, QUALITY Quality)",
        "sKeyName": "Name of the key to override the quality for",
        "Quality": "Quality to override in an existing value. There is no default value. The QUALITY type is created using the QualityCreate function."
      },
      "helpPath": "MapValueSetQuality.html"
    },
    "max": {
      "name": "Max",
      "returnType": "UNKNOWN",
      "params": [
        "Number1",
        "Number2"
      ],
      "doc": "Gets the higher of two numbers.",
      "returns": "The higher of numbers Number1 and Number2.",
      "paramDocs": {
        "Number1, Number2": "Max(Number1, Number2)",
        "Number1": "The first number.",
        "Number2": "The second number."
      },
      "helpPath": "Max.html"
    },
    "menugetchild": {
      "name": "MenuGetChild",
      "returnType": "UNKNOWN",
      "params": [
        "hParent",
        "sName"
      ],
      "doc": "Returns the handle to the child node with the specified name.",
      "returns": "The handle of the child node with the requested name, or -1 if unsuccessful.",
      "paramDocs": {
        "hParent": "MenuGetChild(hParent, sName)",
        "sName": "The name of the child Menu node requested."
      },
      "helpPath": "MenuGetChild.html"
    },
    "menugetfirstchild": {
      "name": "MenuGetFirstChild",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Returns the handle to the first child of a menu node.",
      "returns": "The handle to the first child node of a menu node, or -1 if unsuccessful.",
      "paramDocs": {
        "hNode": "MenuGetFirstChild(hNode)"
      },
      "helpPath": "MenuGetFirstChild.html"
    },
    "menugetgenericnode": {
      "name": "MenuGetGenericNode",
      "returnType": "UNKNOWN",
      "params": [
        "[bCreate]"
      ],
      "doc": "Returns the handle to the base node of the menu tree for the generic pages.",
      "returns": "The handle to the base node of the menu tree, or -1 if it cannot find the node.",
      "paramDocs": {
        "[bCreate]": "MenuGetGenericNode([bCreate])",
        "bCreate": "Determines if the node should be created if it does not exist. Defaults to 0, do not create."
      },
      "helpPath": "MenuGetGenericNode.html"
    },
    "menugetnextchild": {
      "name": "MenuGetNextChild",
      "returnType": "UNKNOWN",
      "params": [
        "hChild"
      ],
      "doc": "Returns the next node that shares the same parent.",
      "returns": "The handle to next node that shares the same parent, or -1 if unsuccessful.",
      "paramDocs": {
        "hChild": "MenuGetNextChild(hChild)"
      },
      "helpPath": "MenuGetNextChild.html"
    },
    "menugetnodebypath": {
      "name": "MenuGetNodeByPath",
      "returnType": "UNKNOWN",
      "params": [
        "INT hMenuNode",
        "STRING sMenuPath"
      ],
      "doc": "Returns a menu handle corresponding to a menu item expressed as a string path in the format <level>.<level>.<level>.<level>.",
      "paramDocs": {
        "INT": "MenuGetNodeByPath(INT hMenuNode, STRING sMenuPath)",
        "hMenuNode": "hMenuNode",
        "sMenuPath": "sMenuPath"
      },
      "helpPath": "MenuGetNodeByPath.htm"
    },
    "menugetpagenode": {
      "name": "MenuGetPageNode",
      "returnType": "UNKNOWN",
      "params": [
        "sPage [",
        "nMode]"
      ],
      "doc": "Returns the handle to the base node of the menu tree of a specified page.",
      "returns": "The handle of the menu tree, or -1 if no menu tree exists for a specified page.",
      "paramDocs": {
        "sPage [, nMode]": "MenuGetPageNode(sPage [, nMode])",
        "sPage": "The name of the page for which to return the menu tree handle.",
        "nMode": "The mode to use for generating the menu handle for the page:"
      },
      "helpPath": "MenuGetPageNode.html"
    },
    "menugetparent": {
      "name": "MenuGetParent",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Returns the parent node of the menu item.",
      "returns": "The handle to parent menu node of the given menu item, or -1 if unsuccessful.",
      "paramDocs": {
        "hNode": "MenuGetParent(hNode)"
      },
      "helpPath": "MenuGetParent.html"
    },
    "menugetprevchild": {
      "name": "MenuGetPrevChild",
      "returnType": "UNKNOWN",
      "params": [
        "hChild"
      ],
      "doc": "Returns the previous node that shares the same parent.",
      "returns": "The handle to previous node that shares the same parent, or -1 if unsuccessful.",
      "paramDocs": {
        "hChild": "MenuGetPrevChild(hChild)"
      },
      "helpPath": "MenuGetPrevChild.html"
    },
    "menugetwindownode": {
      "name": "MenuGetWindowNode",
      "returnType": "UNKNOWN",
      "params": [
        "hWin"
      ],
      "doc": "Returns the handle to the root node for a given window.",
      "returns": "The handle to the root node of a given window, or -1 if unsuccessful.",
      "paramDocs": {
        "hWin": "MenuGetWindowNode(hWin)"
      },
      "helpPath": "MenuGetWindowNode.html"
    },
    "menunodeaddchild": {
      "name": "MenuNodeAddChild",
      "returnType": "UNKNOWN",
      "params": [
        "hParent",
        "sName",
        "sCommandName [",
        "sCommandArgs] [",
        "sSymbol] [",
        "iOrder]"
      ],
      "doc": "Dynamically add a new item to the menu at runtime.",
      "returns": "The handle of the new node, or -1 if unsuccessful.",
      "paramDocs": {
        "hParent": "MenuNodeAddChild(hParent, sName, sCommandName [, sCommandArgs] [, sSymbol] [, iOrder])",
        "sName": "The string label of the new menu item.",
        "sCommandName": "Specifies the name of the Cicode function to run.",
        "sCommandArgs": "Specifies the parameters of the Cicode function to run.",
        "sSymbol": "The symbol to be associated with the menu item.",
        "iOrder": "The relative position in the menu for new item."
      },
      "helpPath": "MenuNodeAddChild.html"
    },
    "menunodegetcurr": {
      "name": "MenuNodeGetCurr",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Return the item value of the specified menu node.",
      "returns": "The handle of the menu node.",
      "paramDocs": {},
      "helpPath": "MenuNodeGetCurr.html"
    },
    "menunodegetdepth": {
      "name": "MenuNodeGetDepth",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Return the item value of the specified menu node.",
      "returns": "The depth of the specified node within the menu hierarchy. For example, 0 indicates it is on the root node of the menu, 1 indicates one level below the root node, and so on.",
      "paramDocs": {
        "hNode": "MenuNodeGetDepth(hNode)"
      },
      "helpPath": "MenuNodeGetDepth.html"
    },
    "menunodegetexpanded": {
      "name": "MenuNodeGetExpanded",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Returns the expansion state value of the specified menu node.",
      "returns": "The expansion state value to set for the Menu node or -1 if unsuccessful.",
      "paramDocs": {
        "hNode": "MenuNodeGetExpanded(hNode)"
      },
      "helpPath": "MenuNodeGetExpanded.html"
    },
    "menunodegetproperty": {
      "name": "MenuNodeGetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "hNode",
        "iField"
      ],
      "doc": "Return the item value of the specified menu node.",
      "returns": "The value for the specified menu node field.",
      "paramDocs": {
        "0": "Name of menu item.",
        "1": "Icon symbol to be associated with the menu item.",
        "2": "Privilege level required to run the command, otherwise the menu item is disabled.",
        "3": "Area level required to run the command, otherwise the menu item is disabled.",
        "4": "Disabled Style. Allows different display style for a disabled menu item.",
        "5": "Checked setting. Whether the menu item will display a check box next to the label.",
        "6": "Width. Specifies the menu item width in pixels.",
        "7": "Comment.",
        "8": "Cluster.",
        "9": "Equipment.",
        "10": "Expansion state value stored by MenuNodeSetExpanded.",
        "11": "Order.",
        "12": "Page.",
        "13": "Target page of the menu item.",
        "hNode": "MenuNodeGetProperty(hNode, iField)",
        "iField": "Field for which you want the value:",
        "101-108": "Custom 1 to Custom 8."
      },
      "helpPath": "MenuNodeGetProperty.html"
    },
    "menunodegettargetpage": {
      "name": "MenuNodeGetTargetPage",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Return the item value of the specified menu node.",
      "returns": "The name of the target page for the specified node.",
      "paramDocs": {
        "hNode": "MenuNodeGetTargetPage(hNode)"
      },
      "helpPath": "MenuNodeGetTargetPage.html"
    },
    "menunodehascommand": {
      "name": "MenuNodeHasCommand",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Checks whether the menu node has a valid cicode command associated with it.",
      "returns": "1 if the menu node has a valid Cicode command, 0 if the menu node has no Cicode command.",
      "paramDocs": {
        "hNode": "MenuNodeHasCommand(hNode)"
      },
      "helpPath": "MenuNodeHasCommand.html"
    },
    "menunodeisdisabled": {
      "name": "MenuNodeIsDisabled",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Checks whether the menu node is disabled by evaluating its DisabledWhen cicode expression.",
      "returns": "1 if menu node DisabledWhen expression evaluates to true, 0 if menu node DisabledWhen expression evaluates to false.",
      "paramDocs": {
        "hNode": "MenuNodeIsDisabled(hNode)"
      },
      "helpPath": "MenuNodeIsDisabled.html"
    },
    "menunodeishidden": {
      "name": "MenuNodeIsHidden",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Checks whether the menu node is hidden by evaluating its HiddenWhen Cicode expression.",
      "returns": "1 if menu node HiddenWhen expression evaluates to true, 0 if menu node HiddenWhen expression evaluates to false.",
      "paramDocs": {
        "hNode": "MenuNodeIsHidden(hNode)"
      },
      "helpPath": "MenuNodeIsHidden.html"
    },
    "menunoderemove": {
      "name": "MenuNodeRemove",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Remove the menu node from the menu tree.",
      "returns": "Zero (0) if node successfully removed. -1 if hNode is an invalid menu handle.",
      "paramDocs": {
        "hNode": "MenuNodeRemove(hNode)"
      },
      "helpPath": "MenuNodeRemove.html"
    },
    "menunoderuncommand": {
      "name": "MenuNodeRunCommand",
      "returnType": "UNKNOWN",
      "params": [
        "hNode"
      ],
      "doc": "Run the associated command for a menu node.",
      "returns": "No error(0) on success. Bad handle specified (269) if hNode does not refer to a valid node.",
      "paramDocs": {
        "hNode": "MenuNodeRunCommand(hNode)"
      },
      "helpPath": "MenuNodeRunCommand.html"
    },
    "menunodesetdisabledwhen": {
      "name": "MenuNodeSetDisabledWhen",
      "returnType": "UNKNOWN",
      "params": [
        "hNode",
        "sDisabledWhenName [",
        "sDisabledWhenArgs] [",
        "iDisabledStyle]"
      ],
      "doc": "Set the DisabledWhen expression for a newly added node.",
      "returns": "No Error(0) on success, Bad handle specified (269) if hNode does not refer to a valid node, Invalid argument passed (274) if DisabledWhen Cicode has already been set or is not a valid expression.",
      "paramDocs": {
        "hNode": "MenuNodeSetDisabledWhen(hNode, sDisabledWhenName [, sDisabledWhenArgs] [, iDisabledStyle])",
        "sDisabledWhenName": "Cicode function for DisabledWhen expression. The function needs to return an INT.",
        "sDisabledWhenArgs": "Cicode parameters for DisabledWhen expression. Only supports static arguments.",
        "iDisabledStyle": "Disabled Style. Allows different display styles for a disabled menu item."
      },
      "helpPath": "MenuNodeSetDisabledWhen.html"
    },
    "menunodesetexpanded": {
      "name": "MenuNodeSetExpanded",
      "returnType": "UNKNOWN",
      "params": [
        "hNode. iValue"
      ],
      "doc": "Set the expansion state value of the specified menu node in number.",
      "returns": "Zero (0) if successful. -1 if hNode is invalid or an error code for any other error.",
      "paramDocs": {
        "hNode": "MenuNodeSetExpanded(hNode. iValue)",
        "iValue": "The expansion state value to set for the Menu node."
      },
      "helpPath": "MenuNodeSetExpanded.html"
    },
    "menunodesethiddenwhen": {
      "name": "MenuNodeSetHiddenWhen",
      "returnType": "UNKNOWN",
      "params": [
        "hNode",
        "sHiddenWhenName [",
        "sHiddenWhenArgs]"
      ],
      "doc": "Set the HiddenWhen expression for a newly added node.",
      "returns": "No Error (0) on success, Bad handle specified (269) if hNode does not refer to a valid node, or Invalid argument passed (274) if HiddenWhen Cicode has already been set or is not a valid expression.",
      "paramDocs": {
        "hNode": "MenuNodeSetHiddenWhen(hNode, sHiddenWhenName [, sHiddenWhenArgs])",
        "sHiddenWhenName": "Cicode function for HiddenWhen expression. The function needs to return an INT.",
        "sHiddenWhenArgs": "Cicode parameters for HiddenWhen expression. Only supports static arguments."
      },
      "helpPath": "MenuNodeSetHiddenWhen.html"
    },
    "menunodesetproperty": {
      "name": "MenuNodeSetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "hNode",
        "iField",
        "sValue"
      ],
      "doc": "Set the item value of the specified menu node.",
      "returns": "Zero (0) if successful. -1 if hNode or iField is invalid. An error code for others.",
      "paramDocs": {
        "0": "Name of menu item.",
        "1": "Icon symbol to be associated with the menu item.",
        "2": "Privilege level required to run the command, otherwise the menu item is disabled.",
        "3": "Area level required to run the command, otherwise the menu item is disabled.",
        "4": "Disabled Style. Allows different display style for a disabled menu item.",
        "5": "Checked setting. Whether the menu item will display a check box next to the label.",
        "6": "Width. Specifies the menu item width in pixels.",
        "7": "Comment.",
        "8": "Cluster.",
        "9": "Equipment.",
        "10": "Expansion state value.",
        "13": "Target page for the menu item.",
        "hNode": "MenuNodeSetProperty(hNode, iField, sValue)",
        "iField": "Field for which you want to set the value:",
        "101 to108": "Custom 1 to Custom 8.",
        "sValue": "The item value to set for the Menu node."
      },
      "helpPath": "MenuNodeSetProperty.html"
    },
    "menureload": {
      "name": "MenuReload",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Reload base Menu Configuration from the compiled database.",
      "returns": "None.",
      "paramDocs": {},
      "helpPath": "MenuReload.html"
    },
    "message": {
      "name": "Message",
      "returnType": "UNKNOWN",
      "params": [
        "Title",
        "Prompt",
        "Mode"
      ],
      "doc": "Displays a message box on the screen and waits for the user to select the OK or Cancel button.",
      "returns": "0 (zero) if successful, otherwise an error is returned. If the user presses the Cancel button the function returns an error code of 299.",
      "paramDocs": {
        "0": "OK button",
        "1": "OK and Cancel button",
        "16": "Stop Icon",
        "32": "Question Icon",
        "48": "Exclamation Icon",
        "64": "Information Icon",
        "Title, Prompt, Mode": "Message(Title, Prompt, Mode)",
        "Title": "The title of the message box. The maximum length is 254 chars.",
        "Prompt": "The prompt displayed in the message box.",
        "Mode": "The mode of the message box:"
      },
      "helpPath": "Message.html"
    },
    "min": {
      "name": "Min",
      "returnType": "UNKNOWN",
      "params": [
        "Number1",
        "Number2"
      ],
      "doc": "Returns the lower of two numbers.",
      "returns": "The lower of numbers Number1 and Number2.",
      "paramDocs": {
        "Number1, Number2": "Min(Number1, Number2)",
        "Number1": "The first number.",
        "Number2": "The second number."
      },
      "helpPath": "Min.html"
    },
    "msgbrdcst": {
      "name": "MsgBrdcst",
      "returnType": "UNKNOWN",
      "params": [
        "Name",
        "Type",
        "Str [",
        "sClusterName]"
      ],
      "doc": "Broadcasts a message to all the clients of a server.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Name, Type, Str [, sClusterName]": "MsgBrdcst(Name, Type, Str [, sClusterName])",
        "sName": "The name of the Plant SCADA server.",
        "nType": "The message number.",
        "Str": "The message text."
      },
      "helpPath": "MsgBrdcst.html"
    },
    "msgclose": {
      "name": "MsgClose",
      "returnType": "UNKNOWN",
      "params": [
        "Name",
        "hMsg"
      ],
      "doc": "Closes a message. After the message is closed, the message post function (the callback function specified in the MsgOpen() function) is not called if a message is received.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Name, hMsg": "MsgClose(Name, hMsg)",
        "sName": "The name of the Plant SCADA server.",
        "hMsg": "The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored."
      },
      "helpPath": "MsgClose.html"
    },
    "msggetcurr": {
      "name": "MsgGetCurr",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the handle of the client message that called the report or remote procedure that is currently running.",
      "returns": "The handle for the client message. The message handle identifies the table where all data on the associated message is stored. The function returns -1 if no client called the report or function.",
      "paramDocs": {},
      "helpPath": "MsgGetCurr.html"
    },
    "msgopen": {
      "name": "MsgOpen",
      "returnType": "UNKNOWN",
      "params": [
        "Name",
        "Mode",
        "Fn [",
        "sClusterName]"
      ],
      "doc": "Opens a message session with a Plant SCADA server.",
      "returns": "The message handle, or -1 if the session cannot be opened. The message handle identifies the table where data on the associated message is stored. The exception to this is mode 1 where the handle 4096 will be returned if the session can be opened.",
      "paramDocs": {
        "0": "Open the client side.",
        "1": "Open the server side.",
        "2": "Open a session from a server to the default computer name. Set Name to the computer name of the computer, as defined by the [LAN]Node parameter.",
        "3": "Open a message session between redundant servers. (Clients cannot tell which server they are connected to or if something has changed on the server. Changes should be performed on the redundant server as well.)",
        "4": "Open a message session from the calling process to the client process. The Name and Fn are ignored in this mode. The message session opened in this mode does not need to call MsgClose.",
        "Name, Mode, Fn [": "MsgOpen(Name, Mode, Fn [, sClusterName] )",
        "sName": "The name of the server to open, either:",
        "Mode": "The mode of the message session to open:",
        "Fn": "The message post function, that is a callback function for the message event. Set Fn to 0 if no event callback function is required.",
        "sClusterName": "The name of the cluster the server being communicated with belongs to, this is used when mode is 0, 1 or 3. This is not required if the client is connected to only one cluster containing a server of the type set in the name parameter."
      },
      "helpPath": "MsgOpen.html"
    },
    "msgread": {
      "name": "MsgRead",
      "returnType": "UNKNOWN",
      "params": [
        "Type",
        "Str"
      ],
      "doc": "Reads a message from a message session.",
      "returns": "The message handle of the message being read.",
      "paramDocs": {
        "nType": "The nType and Str variables of this function return the message number and the text of the message. The return value of this function is the message handle (allowing a response to be sent back if required).",
        "Type, Str": "MsgRead(Type, Str)",
        "Str": "The message text. Must be a String type variable."
      },
      "helpPath": "MsgRead.html"
    },
    "msgrpc": {
      "name": "MsgRPC",
      "returnType": "UNKNOWN",
      "params": [
        "hMsg",
        "sName",
        "Arg",
        "Mode"
      ],
      "doc": "Calls a remote procedure on another Plant SCADA computer.",
      "returns": "The result of the remote function call (as a string). If the function is called in asynchronous mode the result of the remote function cannot be returned, so an empty string is returned.",
      "paramDocs": {
        "0": "Blocking mode - synchronous.",
        "1": "Non-blocking mode - asynchronous.",
        "sName": "Calls a remote procedure on another Plant SCADA computer. You can call any of the built-in Cicode functions remotely, or your own functions. You pass the sName of the function as a string, not as the function tag, and pass all the arguments for that function in Arg.",
        "hMsg, sName, Arg, Mode": "MsgRPC(hMsg, sName, Arg, Mode)",
        "hMsg": "The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
        "Arg": "The arguments to pass to the function, separated by commas (,). Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If you do not enclose the string in quotes, then the string is only the first tag found.",
        "Mode": "The mode of the call:"
      },
      "helpPath": "MsgRPC.html"
    },
    "msgstate": {
      "name": "MsgState",
      "returnType": "UNKNOWN",
      "params": [
        "hMsg"
      ],
      "doc": "Verifies the status of a message session.",
      "returns": "This function has the following possible return values:",
      "paramDocs": {
        "hMsg": "MsgState(hMsg)"
      },
      "helpPath": "MsgState.html"
    },
    "msgwrite": {
      "name": "MsgWrite",
      "returnType": "UNKNOWN",
      "params": [
        "hMsg",
        "Type",
        "Str"
      ],
      "doc": "Writes a message to a message session.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hMsg, Type, Str": "MsgWrite(hMsg, Type, Str)",
        "hMsg": "The message handle, returned from the MsgOpen() function. The message handle identifies the table where all data on the associated message is stored.",
        "nType": "The integer message data, that is the message number.",
        "Str": "The message text."
      },
      "helpPath": "MsgWrite.html"
    },
    "multimonitorstart": {
      "name": "MultiMonitorStart",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a Plant SCADA window on each of the configured monitors when a display client starts up.",
      "returns": "None.",
      "paramDocs": {},
      "helpPath": "MultiMonitorStart.html"
    },
    "multisignatureform": {
      "name": "MultiSignatureForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a form that allows up to 4 users to have their credentials verified in order to approve an operation.",
      "returns": "TRUE (1) if the operation approved (that is all users' credentials were verified and the operator clicked the \"Approve\" button, otherwise FALSE (0).",
      "paramDocs": {
        "sOperationDescription, sLogDevice, sUser1, sUser2, sUser3, sUser4": "MultiSignatureForm(sOperationDescription, sLogDevice, sUser1, sUser2, sUser3, sUser4)",
        "sOperationDescription": "A description of the operation that requires approval. This string will be displayed on the signature form and logged to the log device if the operation is approved.",
        "sLogDevice": "The name of a log device if logging is required, otherwise pass an empty string."
      },
      "helpPath": "MultiSignatureForm.html"
    },
    "multisignaturetagwrite": {
      "name": "MultiSignatureTagWrite",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a form that allows up to four users to have their credentials verified in order to approve a write of a specific value to a specific tag.",
      "returns": "TRUE (1) if the operation was approved (that is all users' credentials were verified and the operator clicked the \"Approve\" button, otherwise FALSE (0).",
      "paramDocs": {
        "sTagName, sValueToWrite, sLogDevice, sUser1, sUser2, sUser3, sUser4": "MultiSignatureTagWrite(sTagName, sValueToWrite, sLogDevice, sUser1, sUser2, sUser3, sUser4)",
        "sTagName": "The name of the tag to which a write needs to be approved.",
        "sLogDevice": "The name of a log device if logging is required, otherwise pass an empty string."
      },
      "helpPath": "MultiSignatureTagWrite.html"
    },
    "name": {
      "name": "Name",
      "returnType": "UNKNOWN",
      "params": [
        "[bIncludeDomain]"
      ],
      "doc": "Gets the name of the operator who is currently logged on to the display system.",
      "returns": "The name of the user as a string. If the user is logged on as a Windows user the name will be the Windows user account name.",
      "paramDocs": {
        "[bIncludeDomain]": "Name([bIncludeDomain])",
        "bIncludeDomain": "bIncludeDomain = 0: Return Windows user name only"
      },
      "helpPath": "Name.html"
    },
    "objectassociateevents": {
      "name": "ObjectAssociateEvents",
      "returnType": "UNKNOWN",
      "params": [
        "sEventClass",
        "hSource"
      ],
      "doc": "Allows you to change the ActiveX object's event class.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sEventClass, hSource": "ObjectAssociateEvents(sEventClass, hSource)",
        "sClass": "The class of the object. You can use the object's human readable name, its program ID, or its GUID. If the class does not exist, the function will report an error.",
        "hSource": "The source object firing the events which are to be handled by the event handler."
      },
      "helpPath": "ObjectAssociateEvents.html"
    },
    "objectassociatepropertywithtag": {
      "name": "ObjectAssociatePropertyWithTag",
      "returnType": "UNKNOWN",
      "params": [
        "sObject",
        "sPropertyName",
        "sTagName [",
        "sOnChangeEvent]"
      ],
      "doc": "Establishes an association between an ActiveX property and a variable tag.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sObject, sPropertyName, sTagName [, sOnChangeEvent]": "ObjectAssociatePropertyWithTag(sObject, sPropertyName, sTagName [, sOnChangeEvent] )",
        "sObject": "The object instance that associates a property with a tag.",
        "sPropertyName": "The name of the ActiveX property to associate with the tag.",
        "sTagName": "The name of the Plant SCADA variable tag to associate with the property.",
        "sOnChangeEvent": "The name of the \"on change\" event that informs Plant SCADA of a change to the ActiveX object. This is required where the ActiveX object does not automatically generate a property change notification. Choose an event that happens to be fired whenever the ActiveX object property changes, for example, the MS Calendar Control fires an AfterUpdate event whenever a day button is pressed."
      },
      "helpPath": "ObjectAssociatePropertyWithTag.html"
    },
    "objectbyname": {
      "name": "ObjectByName",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name"
      ],
      "doc": "Retrieves an ActiveX object. This is useful when you know the object by name only.",
      "returns": "The requested object, if successful, otherwise an error is generated.",
      "paramDocs": {
        "STRING Name": "ObjectByName(STRING Name)",
        "Name": "The name used to access the object, as specified when creating it in Cicode. For objects created in the Graphics Builder, the object name is set in the Access (Identification) tab, and defaults to \"AN\" followed by its AN number, for example, \"AN35\". The Name argument should be enclosed in quotes \"\"."
      },
      "helpPath": "ObjectByName.html"
    },
    "objecthasinterface": {
      "name": "ObjectHasInterface",
      "returnType": "UNKNOWN",
      "params": [
        "hObject",
        "sInterface"
      ],
      "doc": "Queries the ActiveX component to determine if its specific interface is supported.",
      "returns": "0 if the interface is not supported, otherwise 1.",
      "paramDocs": {
        "hObject, sInterface": "ObjectHasInterface(hObject, sInterface)",
        "hObject": "The handle for the object (as returned by the ObjectByName() function).",
        "sInterface": "The name of the interface (case sensitive)."
      },
      "helpPath": "ObjectHasInterface.html"
    },
    "objectisvalid": {
      "name": "ObjectIsValid",
      "returnType": "UNKNOWN",
      "params": [
        "hObject"
      ],
      "doc": "Determines if the given handle for an object is a valid handle.",
      "returns": "0 if the handle is not valid, otherwise 1.",
      "paramDocs": {
        "hObject": "ObjectIsValid(hObject)"
      },
      "helpPath": "ObjectIsValid.html"
    },
    "objecttostr": {
      "name": "ObjectToStr",
      "returnType": "UNKNOWN",
      "params": [
        "hObject"
      ],
      "doc": "Converts an object handle to a string.",
      "returns": "A string containing the converted object handle",
      "paramDocs": {
        "hObject": "ObjectToStr(hObject)"
      },
      "helpPath": "ObjectToStr.html"
    },
    "oledatetotime": {
      "name": "OLEDateToTime",
      "returnType": "UNKNOWN",
      "params": [
        "OLEDate",
        "Local"
      ],
      "doc": "Converts an OLE DATE value (stored in a REAL) to a Plant SCADA time/date value.",
      "returns": "Returns a Plant SCADA time/date value.",
      "paramDocs": {
        "OLEDate, Local": "OLEDateToTime(OLEDate, Local)",
        "OLEDate": "The OLE DATE value to convert (stored as a REAL).",
        "Local": "0 - OleDate represents a UTC time."
      },
      "helpPath": "OLEDateToTime.html"
    },
    "onevent": {
      "name": "OnEvent",
      "returnType": "UNKNOWN",
      "params": [
        "Type",
        "Fn"
      ],
      "doc": "Sets an event callback function for an event type. The callback function is called when the event occurs.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.",
        "1": "A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.",
        "2": "Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.",
        "3": "Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.",
        "4": "Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.",
        "5": "Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.",
        "6": "Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.",
        "7": "Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.",
        "8": "Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.",
        "9": "Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.",
        "10": "Page always. This event is called while a page is active. Reserved for use by Plant SCADA.",
        "18": "Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.",
        "19": "Device history. A device history has just completed. The return value must be 0.",
        "20": "Login. A user has just logged in.",
        "21": "Logout. A user has just logged out.",
        "22": "Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)",
        "23": "Hardware error has been detected.",
        "24": "Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().",
        "25": "Network shutdown. A Shutdown network command has been issued.",
        "26": "Runtime system shutdown and restart. (Required because of configuration changes.)",
        "27": "Event. An event has occurred.",
        "28": "Accumulator. An accumulator has logged a value.",
        "29": "Slider. A slider has been selected.",
        "30": "Slider. A slider has moved.",
        "31": "Slider. A slider has been released (that is stopped moving).",
        "32": "Shutdown. Plant SCADA is being shutdown.",
        "33": "Reserved for Plant SCADA internal use.",
        "34": "Plant SCADA Event: Child Window Close Confirmation.",
        "35": "Plant SCADA Event: Main Window Close Confirmation.",
        "36": "Plant SCADA Event: Maximize Window Confirmation.",
        "37": "Plant SCADA Event: Minimize Window Confirmation.",
        "38": "Plant SCADA Event: Restore Window Confirmation.",
        "39": "Plant SCADA Event: Move Window Confirmation.",
        "40": "Plant SCADA Event: Size Window Confirmation.",
        "41": "Plant SCADA Event: Shutdown Confirmation Confirmation.",
        "42": "Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "43": "Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.",
        "44": "Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "45": "Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.",
        "46": "Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "47": "Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.",
        "48": "Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.",
        "49": "Shutdown Confirmation, when shutdown() function is called.",
        "Type, Fn": "OnEvent(Type, Fn)",
        "Type": "The type of event:",
        "11..17": "Undefined.",
        "34 - 41": "Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler.",
        "42 to 49": "User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.",
        "50 - 127": "Reserved for future Plant SCADA use.",
        "128 - 256": "User-defined events. These events are for your own use.",
        "Fn": "The function to call when the event occurs. This callback function needs to have no arguments, so you specify the function with no parentheses (). The callback function needs to return INT as its return data type. You cannot specify a Plant SCADA built-in function as a callback function."
      },
      "helpPath": "OnEvent.html"
    },
    "packedrgb": {
      "name": "PackedRGB",
      "returnType": "UNKNOWN",
      "params": [
        "nRed",
        "nGreen",
        "nBlue"
      ],
      "doc": "Returns a packed RGB color based on specified red, green, and blue values.",
      "returns": "The packed RGB color value - if successful, otherwise an error is returned.",
      "paramDocs": {
        "nRed, nGreen, nBlue": "PackedRGB(nRed, nGreen, nBlue)",
        "nRed": "The red component of the desired packed RGB color.",
        "nGreen": "The green component of the desired packed RGB color.",
        "nBlue": "The blue component of the desired packed RGB color."
      },
      "helpPath": "PackedRGB.html"
    },
    "packedrgbtocitectcolour": {
      "name": "PackedRGBToCitectColour",
      "returnType": "UNKNOWN",
      "params": [
        "nPackedRGB"
      ],
      "doc": "Converts a packed RGB color into a calculated color value.",
      "returns": "The Plant SCADA color value if successful; otherwise an error is returned.",
      "paramDocs": {
        "nPackedRGB": "PackedRGBToCitectColour(nPackedRGB)"
      },
      "helpPath": "PackedRGBToCitectColour.html"
    },
    "pagealarm": {
      "name": "PageAlarm",
      "returnType": "UNKNOWN",
      "params": [
        "[Category]"
      ],
      "doc": "Displays a category of active alarms on the alarm page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "[Category]": "PageAlarm( [Category] )",
        "Category": "The alarm category to display. Set to 0 (the default) to display all alarm categories."
      },
      "helpPath": "PageAlarm_CIREF.html"
    },
    "pageback": {
      "name": "PageBack",
      "returnType": "UNKNOWN",
      "params": [
        "[iCount]"
      ],
      "doc": "Displays the previously displayed page in the Window.",
      "returns": "No Error (0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Invalid argument passed (274) if count is outside of allowable bounds.",
      "paramDocs": {
        "iCount": "PageBack([iCount])"
      },
      "helpPath": "PageBack.html"
    },
    "pagedisabled": {
      "name": "PageDisabled",
      "returnType": "UNKNOWN",
      "params": [
        "[Category]"
      ],
      "doc": "Displays a category of disabled alarms on the disabled alarms page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "[Category]": "PageDisabled( [Category] )",
        "Category": "The alarm category to display. Set to 0 (the default) to display all alarm categories."
      },
      "helpPath": "PageDisabled.html"
    },
    "pagedisplay": {
      "name": "PageDisplay",
      "returnType": "UNKNOWN",
      "params": [
        "Page",
        "[ClusterName]"
      ],
      "doc": "Displays a graphics page in the active window.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {
        "Page,": "PageDisplay(Page,[ClusterName])",
        "Page": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
        "ClusterName": "The name of the cluster that will accommodate the page at runtime (in quotation marks \"\"). The specified cluster is used to resolve any tags that have a cluster omitted. If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "PageDisplay.html"
    },
    "pageexists": {
      "name": "PageExists",
      "returnType": "UNKNOWN",
      "params": [
        "STRING[sPageName]"
      ],
      "doc": "Use this function to check if a particular page exists in your project.",
      "returns": "1 if the page does exist, 0 if the page does not.",
      "paramDocs": {
        "sPageName": "INT PageExists(STRING[sPageName])"
      },
      "helpPath": "PageExists.html"
    },
    "pagefile": {
      "name": "PageFile",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Displays a file on the page.",
      "returns": "0 (zero) if the file is successfully displayed, otherwise an error is returned.",
      "paramDocs": {
        "sName": "PageFile(sName)"
      },
      "helpPath": "PageFile.html"
    },
    "pagefileinfo": {
      "name": "PageFileInfo",
      "returnType": "UNKNOWN",
      "params": [
        "sPageName",
        "nMode"
      ],
      "doc": "Returns the width or height of an unopened page.",
      "returns": "The height or width of the specified page in pixels, depending on the value set for nMode.",
      "paramDocs": {
        "0": "returns the page width",
        "1": "returns the page height",
        "sPageName, nMode": "PageFileInfo(sPageName, nMode)",
        "sPageName": "The name of the page you would like to retrieve size information for.",
        "nMode": "Retrieves either the width or the height of the specified page in pixels."
      },
      "helpPath": "PageFileInfo.html"
    },
    "pagefileinfoex": {
      "name": "PageFileInfoEx",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "nMode"
      ],
      "doc": "Returns the width or height of an unopened page.",
      "returns": "The height, width, content type, parent or title of the specified page, depending on the value set for nMode.",
      "paramDocs": {
        "0": "returns the page width.",
        "1": "returns the page height.",
        "2": "returns the content type of the page.",
        "3": "returns the parent page of the page.",
        "4": "returns the configured page title of the page.",
        "sPage, nMode": "PageFileInfoEx(sPage, nMode)",
        "sPageName": "The name of the page for which you would like to retrieve information.",
        "nMode": "Determines if the width, height, content type, parent or title is returned for the specified page."
      },
      "helpPath": "PageFileInfoEx.html"
    },
    "pageforward": {
      "name": "PageForward",
      "returnType": "UNKNOWN",
      "params": [
        "[iCount]"
      ],
      "doc": "If PageBack() is called, PageForward() will restore the previously displayed page in the window.",
      "returns": "No Error (0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Invalid argument passed (274) if count is outside of allowable bounds.",
      "paramDocs": {
        "iCount": "PageForward([iCount])"
      },
      "helpPath": "PageForward.html"
    },
    "pagegetint": {
      "name": "PageGetInt",
      "returnType": "UNKNOWN",
      "params": [
        "sLabel [",
        "iWinNum]"
      ],
      "doc": "Returns the integer value associated with a variable name on a particular page.",
      "returns": "Integer stored in variable sLabel.",
      "paramDocs": {
        "sLabel [, iWinNum]": "PageGetInt(sLabel [, iWinNum])",
        "sLabel": "String name of the variable to return",
        "iWinNum": "Window number of the page. Default is current window."
      },
      "helpPath": "PageGetInt.html"
    },
    "pagegetstr": {
      "name": "PageGetStr",
      "returnType": "UNKNOWN",
      "params": [
        "sLabel [",
        "iWinNum]"
      ],
      "doc": "Gets the string associated with a variable name on a particular page.",
      "returns": "Value stored in variable sLabel.",
      "paramDocs": {
        "sLabel [, iWinNum]": "PageGetStr(sLabel [, iWinNum])",
        "sLabel": "String name of the variable to return",
        "iWinNum": "Window number of the page. Default is current window."
      },
      "helpPath": "PageGetStr.html"
    },
    "pagegoto": {
      "name": "PageGoto",
      "returnType": "UNKNOWN",
      "params": [
        "Page",
        "ClusterName"
      ],
      "doc": "Displays a graphics page in the active window. The page needs to be in one of the operator's current areas.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {
        "Page,ClusterName": "PageGoto(Page,ClusterName)",
        "Page": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
        "sClusterName": "The name of the cluster that will accommodate the page at runtime (in quotation marks \"\"). The specified cluster is used to resolve any tags that have the cluster name omitted. If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "PageGoto.html"
    },
    "pagehardware": {
      "name": "PageHardware",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the active hardware alarms on the hardware alarms page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PageHardware.html"
    },
    "pagehistorydspmenu": {
      "name": "PageHistoryDspMenu",
      "returnType": "UNKNOWN",
      "params": [
        "[iType]"
      ],
      "doc": "Displays a pop-up menu which lists the page history of current window.",
      "returns": "Zero (0) if the function is executed successfully. Otherwise an error is returned.",
      "paramDocs": {
        "0": "full history (default)",
        "1": "back history",
        "2": "forward history",
        "iType": "PageHistoryDspMenu([iType])"
      },
      "helpPath": "PageHistoryDspMenu.html"
    },
    "pagehistoryempty": {
      "name": "PageHistoryEmpty",
      "returnType": "UNKNOWN",
      "params": [
        "[iType]"
      ],
      "doc": "Used to determine if the page history of the current window is empty.",
      "returns": "1 if page history of specified type is empty, or 0 if it is not empty.",
      "paramDocs": {
        "0": "full history (default)",
        "1": "back history",
        "2": "forward history",
        "iType": "PageHistoryEmpty([iType])"
      },
      "helpPath": "PageHistoryEmpty.html"
    },
    "pagehome": {
      "name": "PageHome",
      "returnType": "UNKNOWN",
      "params": [
        "[sCluster]"
      ],
      "doc": "Displays the predefined home page in the window.",
      "returns": "No eerror(0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Bad handle specified (274) if INI parameter [Page]HomePage is not set.",
      "paramDocs": {
        "sCluster": "PageHome([sCluster])"
      },
      "helpPath": "PageHome.html"
    },
    "pageinfo": {
      "name": "PageInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nType"
      ],
      "doc": "Gets information about the current page.",
      "returns": "The information (as a string).",
      "paramDocs": {
        "0": "Page name.",
        "1": "Page number.",
        "2": "Page title.",
        "3": "Display file name.",
        "4": "Symbol file name.",
        "5": "Next page name.",
        "6": "Previous page name",
        "7": "Previous display count, incremented at each page scan. The page scan rate defaults to the value of the Citect.ini parameter [Page]ScanTime, and can be overridden per page by changing the scan time setting in the General tab of the page properties in Graphics Builder.",
        "8": "Parent window number. Returns -1 if there is no parent.",
        "9": "First child window number. Returns -1 if there are no children.",
        "10": "Next child in child link. Returns -1 for the end of the list.",
        "11": "Window mode (set by the WinNewAt() function).",
        "12": "Width of window. If the target is a pinned window, the return value will represent the width of the window as it is on the unscaled version of the page that hosts it.",
        "13": "Height of window. If the target is a pinned window, the return value will represent the height of the window as it is on the unscaled version of the page that hosts it.",
        "14": "X position of window. If the target is a pinned window, the value will reflect the coordinates for the window based on its location on the unscaled version of the page that hosts it.",
        "15": "Y position of window. If the target is a pinned window, the value will reflect the coordinates for the window based on its location on the unscaled version of the page that hosts it.",
        "16": "Dynamic window horizontal scale.",
        "17": "Dynamic window vertical scale.",
        "18": "Flashing color state. Type 18 returns one of the following:",
        "19": "In animation cycle. Returns a 1 (true) or 0 (false).",
        "20": "In communications cycle. Returns a 1 (true) or 0 (false).",
        "21": "Width of background page.",
        "22": "Height of background page.",
        "23": "Returns the highest AN.",
        "24": "Returns the number of ANs.",
        "25": "Indicates when the page's \"On Page Shown\" event has been triggered. Returns 1 if triggered, 0 if it has not.",
        "26": "The cluster that has been specified to host the page. Returns the cluster name, or an empty string if no cluster has been specified.",
        "28": "Return X Coordinate of Client rectangle origin.",
        "29": "Return Y Coordinate of Client rectangle origin.",
        "30": "Returns the name of the monitor the current page is displayed on at runtime. For example, in a project where three monitors \"Screen 1\", \"Primary\", and \"Screen 2\" have been configured as part of a multi-monitor screen profile, PageInfo(30) has been set on the monitor named \"Left\" which means \"Left\" would be displayed at runtime.",
        "31": "Returns the \"Content Type\" configured for that page.",
        "nType": "PageInfo(nType)",
        "\"0\"": "the palette does not flash.",
        "\"1\"": "the palette is primary now.",
        "\"2\"": "the palette is secondary now."
      },
      "helpPath": "PageInfo.html"
    },
    "pagekeyboardcommandsput": {
      "name": "PageKeyboardCommandsPut",
      "returnType": "UNKNOWN",
      "params": [
        "nINdex",
        "bstrKeySequence",
        "bstrCommand",
        "nArea",
        "nPrivilege",
        "bstrLogging"
      ],
      "doc": "Allows you to assign keyboard commands to an object or group.",
      "paramDocs": {
        "nINdex, bstrKeySequence, bstrCommand, nArea, nPrivilege, bstrLogging": "HRESULT PageKeyboardCommandsPut(nINdex, bstrKeySequence, bstrCommand, nArea, nPrivilege, bstrLogging)",
        "nIndex": "Position of the keyboard command (as you can define more than one).",
        "bstrKeySequence": "bstrKeySequence",
        "bstrCommand": "bstrCommand",
        "bstrLogging": "bstrLogging"
      },
      "helpPath": "PageKeyboardCommandsPut.htm"
    },
    "pagelast": {
      "name": "PageLast",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the graphics page that was last displayed. With this function, you can successively recall the last ten pages that were displayed.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PageLast.html"
    },
    "pagelistcount": {
      "name": "PageListCount",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets number of pages in the page list of the current window.",
      "returns": "Number of pages in the list",
      "paramDocs": {},
      "helpPath": "PageListCount.html"
    },
    "pagelistcurrent": {
      "name": "PageListCurrent",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets Index of the current page in the page list of current window.",
      "returns": "List index (0 to list size -1), or -1 if unable to get index",
      "paramDocs": {},
      "helpPath": "PageListCurrent.html"
    },
    "pagelistdelete": {
      "name": "PageListDelete",
      "returnType": "UNKNOWN",
      "params": [
        "INT index"
      ],
      "doc": "Removes a page at the specific index from the page list of the current window.",
      "returns": "0 (zero) if the page is successfully removed, otherwise an error is returned.",
      "paramDocs": {
        "INT index": "PageListDelete(INT index)",
        "Index": "Index"
      },
      "helpPath": "PageListDelete.html"
    },
    "pagelistdisplay": {
      "name": "PageListDisplay",
      "returnType": "UNKNOWN",
      "params": [
        "INT index"
      ],
      "doc": "Recalls (displays) a page at the specific index in the page list of current window, and moves the current index to the page.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {
        "INT index": "PageListDisplay(INT index)",
        "Index": "Index"
      },
      "helpPath": "PageListDisplay.html"
    },
    "pagelistinfo": {
      "name": "PageListInfo",
      "returnType": "STRING",
      "params": [
        "INT index",
        "[ INT type]"
      ],
      "doc": "Gets information of a page at the specific index in the page list of the current window.",
      "returns": "String value of the requested information, or empty string if no valid information can be found",
      "paramDocs": {
        "INT index,[ INT type]": "PageListInfo(INT index,[ INT type])",
        "Index": "Index",
        "Type": "Type"
      },
      "helpPath": "PageListInfo.html"
    },
    "pagemenu": {
      "name": "PageMenu",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a menu page with page selection buttons.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PageMenu.html"
    },
    "pagenext": {
      "name": "PageNext",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the next page as specified in the project.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PageNext.html"
    },
    "pagepeekcurrent": {
      "name": "PagePeekCurrent",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Return the index in the page navigation history for the current page.",
      "returns": "Index in the page navigation history for the current page. -1 indicates that current window handle does not correspond to a valid window.",
      "paramDocs": {},
      "helpPath": "PagePeekCurrent.html"
    },
    "pagepeeklast": {
      "name": "PagePeekLast",
      "returnType": "STRING",
      "params": [
        "iOffset [",
        "iType]"
      ],
      "doc": "Gets information about a Page at an offset in the page navigation history.",
      "returns": "String value of the requested information, or empty string if no valid result for given arguments.",
      "paramDocs": {
        "iOffset": "PagePeekLast(iOffset [, iType] )",
        "iType": "An enumeration representing the type of information required. The default value is 0."
      },
      "helpPath": "PagePeekLast.html"
    },
    "pagepoplast": {
      "name": "PagePopLast",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the Page Name of the last item in the page navigation history and removes the page from the history.",
      "returns": "The page name or an empty string if there is no last page.",
      "paramDocs": {},
      "helpPath": "PagePopLast.html"
    },
    "pagepopup": {
      "name": "PagePopUp",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "[",
        "sClusterName]"
      ],
      "doc": "Display pop up window at the mouse position.",
      "paramDocs": {
        "sPage": "PagePopUp(sPage, [, sClusterName])",
        "sClusterName": "The name of the cluster that will accommodate the page at runtime (in quotation marks \"\"). The specified cluster is used to resolve any tags that have a cluster omitted. If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "PagePopUp.html"
    },
    "pageprev": {
      "name": "PagePrev",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the previous page as specified in the project.",
      "returns": "0 (zero) if the page is successfully displayed, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PagePrev.html"
    },
    "pageprocessanalyst": {
      "name": "PageProcessAnalyst",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sPAVFile1 [",
        "iFileLocation1 [",
        "iButtonMask1 [",
        "sObjName1 [",
        "sPAVFile2 [",
        "iFileLocation2 [",
        "iButtonMask2 [",
        "sObjName2 ]]]]]]]"
      ],
      "doc": "Displays a Process Analyst page.",
      "returns": "Zero (0) if the page is successfully displayed. Otherwise an error is returned.",
      "paramDocs": {
        "sPage, sPAVFile1 [, iFileLocation1 [, iButtonMask1 [, sObjName1 [, sPAVFile2 [, iFileLocation2 [, iButtonMask2 [, sObjName2 ]]]]]]]": "PageProcessAnalyst(sPage, sPAVFile1 [, iFileLocation1 [, iButtonMask1 [, sObjName1 [, sPAVFile2 [, iFileLocation2 [, iButtonMask2 [, sObjName2 ]]]]]]])",
        "sPage": "The name of the page that contains Process Analyst object(s). For example, pages based on the Process Analyst templates found in the Tab_Style_Include project.",
        "sPAVFile1": "Name of the 1st PAV file",
        "iFileLocation1": "PAV file location code for the 1st PAV file, see PA doc LoadFromFile() for details.",
        "iButtonMask1": "Bit mask for removing command buttons from the 1st PA, bit flags as shown below:",
        "sObjName1": "Name of the PA object on the given Page where the 1st PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\".",
        "sPAVFile2": "Name of the 2nd PAV file",
        "iFileLocation2": "PAV file location code for the 2nd PAV file",
        "iButtonMask2": "Bit mask for removing command buttons from the 2nd PA, refer iButtonMask1 for details",
        "sObjName2": "Name of the PA object on the given Page where the 2nd PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA2\"."
      },
      "helpPath": "PageProcessAnalyst.html"
    },
    "pageprocessanalystpens": {
      "name": "PageProcessAnalystPens",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sTag1 [",
        "sTag2..sTag8 [",
        "iButtonMask [",
        "sObjName [",
        "iPane [",
        "sPAVFile [",
        "iFileLocation ]]]]]]"
      ],
      "doc": "Display a page and add the specified pens to the first pane of the specified PA object on the page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sPage, sTag1 [, sTag2..sTag8 [, iButtonMask [, sObjName [, iPane [, sPAVFile [, iFileLocation ]]]]]]": "PageProcessAnalystPens(sPage, sTag1 [, sTag2..sTag8 [, iButtonMask [, sObjName [, iPane [, sPAVFile [, iFileLocation ]]]]]])",
        "sPage": "The name of the page that displays the PA.",
        "sTag1..sTag8": "Up to 8 Trend tags can be added to the PA.",
        "iButtonMask": "Mask to remove button(s) from the main tool bar of PA. The following values can be combined to remove multiple buttons:",
        "sObjName": "sObjName",
        "iPane": "iPane",
        "sPAVFile": "Optional Process Analyst View file to be loaded, default =\"\".",
        "iFileLocation": "Optional location of the PAV file. The allowed values are:"
      },
      "helpPath": "PageProcessAnalystPens.html"
    },
    "pagepushlast": {
      "name": "PagePushLast",
      "returnType": "UNKNOWN",
      "params": [
        "Page"
      ],
      "doc": "Places a page at the end of the page navigation history.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Page": "PagePushLast(Page)"
      },
      "helpPath": "PagePushLast.html"
    },
    "pagerecall": {
      "name": "PageRecall",
      "returnType": "UNKNOWN",
      "params": [
        "iIndex"
      ],
      "doc": "Displays the page at a specified depth in the page navigation history.",
      "returns": "No error(0) on success. Bad handle specified (269) if current window handle does not correspond to a valid window. Bad handle specified (274) if index is outside of allowable bounds.",
      "paramDocs": {
        "iIndex": "PageRecall(iIndex)"
      },
      "helpPath": "PageRecall.html"
    },
    "pagerichtextfile": {
      "name": "PageRichTextFile",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Filename",
        "nMode [",
        "nHeight] [",
        "nWidth]"
      ],
      "doc": "This function creates a rich edit object, and loads a copy of the rich text file Filename into that object.",
      "returns": "None",
      "paramDocs": {
        "0": "Disabled - should be used if the rich text object is to be used for display purposes only.",
        "1": "Enabled - allows you to select and copy the contents of the RTF object (for instance an RTF report), but you will not be able to make changes.",
        "2": "Read/Write - allows you to edit the contents of the RTF object. Remember, however, that the object needs to be enabled before it can be edited. If it has already been enabled, you can just enter Mode 2 as your argument. If it is not already enabled, you will need to enable it. By combining Mode 1 and Mode 2 in your argument (3), you can enable the object, and make it read/write at the same time.",
        "Filename": "This function creates a rich edit object, and loads a copy of the rich text file Filename into that object. The rich text object will be rectangular in shape, with dimensions determined by nHeight, and nWidth. If you do not specify nHeight and nWidth, nAN will define the position of one corner, and (AN + 1) the position of the diagonally opposite corner. This function would often be used as a page entry function.",
        "nAN, Filename, nMode [, nHeight] [, nWidth]": "PageRichTextFile(nAN, Filename, nMode [, nHeight] [, nWidth] )",
        "nAN": "The animation point at which to display the rich text object.",
        "nMode": "The display mode for the rich text object. The mode can be any combination of:",
        "nHeight": "The height of the rich text object in pixels. The height is established by measuring down from the animation point.",
        "nWidth": "The width of the rich text object in pixels. The width is established by measuring across to the right of the animation point."
      },
      "helpPath": "PageRichTextFile.html"
    },
    "pageselect": {
      "name": "PageSelect",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a dialog box with a list of graphics pages defined in the project.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {},
      "helpPath": "PageSelect.html"
    },
    "pagesetint": {
      "name": "PageSetInt",
      "returnType": "UNKNOWN",
      "params": [
        "sLabel",
        "sVar [",
        "iWinNum]"
      ],
      "doc": "Associates an integer variable with a particular page.",
      "returns": "No error(0) on success. 269 if WinNum handle does not correspond to a valid window. 274 if Label or Var is not a valid variable.",
      "paramDocs": {
        "sLabel, sVar [, iWinNum]": "PageSetInt(sLabel, sVar [, iWinNum])",
        "sLabel": "String name of the variable which will contain sValue.",
        "sVar": "The integer to store.",
        "iWinNum": "Window number of the page. Default is current window."
      },
      "helpPath": "PageSetInt.html"
    },
    "pagesetstr": {
      "name": "PageSetStr",
      "returnType": "UNKNOWN",
      "params": [
        "sLabel",
        "sVar [",
        "iWinNum]"
      ],
      "doc": "Stores a local page-based string and associates the string with the page.",
      "returns": "No error(0) on success. 269 if WinNum handle does not correspond to a valid window. 274 if Label or Var is not a valid variable.",
      "paramDocs": {
        "sLabel, sVar [, iWinNum]": "PageSetStr(sLabel, sVar [, iWinNum])",
        "sLabel": "String name of the variable which will contain sVar.",
        "sVar": "The string to store. The string length is 128 characters.",
        "iWinNum": "Window number of the page. Default is current window."
      },
      "helpPath": "PageSetStr.html"
    },
    "pagesoe": {
      "name": "PageSOE",
      "returnType": "UNKNOWN",
      "params": [
        "INT Category",
        "INT Fallback"
      ],
      "doc": "Displays a category of sequence of events (SOE) entries on the SOE page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "INT Category": "PageSOE(INT Category, INT Fallback)",
        "Category": "The category number for the alarms you want to display their events",
        "Fallback": "Whether to display the Summary page instead if the SOE page does not exist. If not specified it defaults to FALSE (0)."
      },
      "helpPath": "PageSOE.html"
    },
    "pagesummary": {
      "name": "PageSummary",
      "returnType": "UNKNOWN",
      "params": [
        "Category"
      ],
      "doc": "Displays a category of alarm summary entries on the alarms summary page.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Category": "PageSummary(Category)"
      },
      "helpPath": "PageSummary.html"
    },
    "pagetask": {
      "name": "PageTask",
      "returnType": "UNKNOWN",
      "params": [
        "iWinNum",
        "sFunctionName",
        "sFunctionArg"
      ],
      "doc": "PageTask() is used for running preliminary Cicode before displaying a page in a window.",
      "returns": "A handle to a code task the first time it is run. BAD_HANDLE (-1) if the function did not complete.",
      "paramDocs": {
        "iWinNum": "PageTask(iWinNum, sFunctionName, sFunctionArg)",
        "sFunctionName": "String representing the Cicode function to run each time the page is navigated to using the forward and backward navigation functions.",
        "sFunctionArg": "String representing the parameters to use with function fnTask."
      },
      "helpPath": "PageTask.html"
    },
    "pagetransformcoords": {
      "name": "PageTransformCoords",
      "returnType": "UNKNOWN",
      "params": [
        "hPage",
        "iPageX",
        "iPageY",
        "iDisplayX",
        "iDisplayY",
        "iType"
      ],
      "doc": "Converts Page coordinates to absolute screen coordinates.",
      "returns": "0  Success",
      "paramDocs": {
        "hPage, iPageX, iPageY , iDisplayX, iDisplayY, iType": "PageTransformCoords(hPage, iPageX, iPageY , iDisplayX, iDisplayY, iType)",
        "hPage": "Page handle of the relevant Window.",
        "PageX": "X coordinate of page coordinate.",
        "iPageY": "Y coordinate of page coordinate.",
        "iDisplayX": "Output parameter: Transformed X coordinate. Must be a Long type variable.",
        "iDisplayY": "Output parameter: Transformed Y coordinate. Must be a Long type variable.",
        "iType": "The value of output coordinate:"
      },
      "helpPath": "PageTransformCoords.html"
    },
    "pagetrend": {
      "name": "PageTrend",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sTag1 [",
        "sTag2..sTag8]"
      ],
      "doc": "Displays a trend page with the specified trend pens.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sPage, sTag1 [, sTag2..sTag8]": "PageTrend(sPage, sTag1 [, sTag2..sTag8] )",
        "sPage": "Name of the trend page (drawn with the Graphics Builder).",
        "sTag1": "The first trend tag to display on the page.",
        "sTag2..sTag8": "Optionally trend tags 2 to 8 to display on the page."
      },
      "helpPath": "PageTrend.html"
    },
    "pagetrendex": {
      "name": "PageTrendEx",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sCluster",
        "sTag1 [",
        "sTag2..sTag8]"
      ],
      "doc": "Displays a trend page of a specified cluster in a multi-cluster system with the specified trend pens.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "sCluster": "Displays a trend page of a specified cluster in a multi-cluster system with the specified trend pens. Use this function to display trends in a mult-cluster system with a single trend page. You need to create the trend page with the Graphics Builder and set the pen names to blank. Then display that page by calling this function and passing the required trend tags. Call this function from a menu of trend pages. This function can also be used in a single cluster system, the sCluster argument is optional in such a case.",
        "sPage, sCluster, sTag1 [, sTag2..sTag8]": "PageTrendEx(sPage, sCluster, sTag1 [, sTag2..sTag8] )",
        "sPage": "Name of the trend page (drawn with the Graphics Builder).",
        "sTag1": "The first trend tag to display on the page.",
        "sTag2..sTag8": "Optionally trend tags 2 to 8 to display on the page."
      },
      "helpPath": "PageTrendEx.html"
    },
    "parameterget": {
      "name": "ParameterGet",
      "returnType": "UNKNOWN",
      "params": [
        "Section",
        "Name",
        "Default"
      ],
      "doc": "Gets the value of a system parameter.",
      "returns": "The parameter (as a string).",
      "paramDocs": {
        "Section, Name, Default": "ParameterGet(Section, Name, Default)",
        "Section": "The section name.",
        "sName": "The system parameter name.",
        "Default": "The default value of the parameter."
      },
      "helpPath": "ParameterGet.html"
    },
    "parameterput": {
      "name": "ParameterPut",
      "returnType": "UNKNOWN",
      "params": [
        "Section",
        "Name",
        "Value"
      ],
      "doc": "Updates a system parameter in the Citect.ini file. If the system parameter does not exist, it is added to the Citect.ini file.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "Section, Name, Value": "ParameterPut(Section, Name, Value)",
        "Section": "The section name.",
        "sName": "The system parameter name.",
        "Value": "The value to put in the system parameter."
      },
      "helpPath": "ParameterPut.html"
    },
    "pathtostr": {
      "name": "PathToStr",
      "returnType": "UNKNOWN",
      "params": [
        "sPath"
      ],
      "doc": "Converts a path into a string.",
      "returns": "A string containing the converted path.",
      "paramDocs": {
        "sPath": "PathToStr(sPath)"
      },
      "helpPath": "PathToStr.html"
    },
    "pi": {
      "name": "Pi",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the value of pi (the ratio of the circumference of a circle to its diameter).",
      "returns": "The value of pi.",
      "paramDocs": {},
      "helpPath": "Pi.html"
    },
    "plotclose": {
      "name": "PlotClose",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot"
      ],
      "doc": "Displays the plot on screen or sends it to the printer.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "hPlot": "PlotClose(hPlot)"
      },
      "helpPath": "PlotClose.html"
    },
    "plotdraw": {
      "name": "PlotDraw",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "Type",
        "PenStyle",
        "PenCol",
        "PenWidth",
        "nFill",
        "X1",
        "Y1",
        "X2",
        "Y2"
      ],
      "doc": "Constructs drawings on your plot.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Solid",
        "1": "Rectangle or square",
        "2": "Circle or ellipse",
        "3": "Line",
        "4": "Point",
        "5": "Hollow",
        "X1,Y1": "Constructs drawings on your plot. Use the coordinates (X1,Y1) and (X2,Y2) to define a point, line, rectangle, square, circle, or ellipse. You can specify the style, color, and width of the pen, and a fill color for a box or circular shape.",
        "hPlot": "you need to call the PlotOpen() function first, to get the handle for the plot (hPlot) and to specify the output device.",
        "hPlot, Type, PenStyle, PenCol, PenWidth, nFill, X1, Y1, X2, Y2": "PlotDraw(hPlot, Type, PenStyle, PenCol, PenWidth, nFill, X1, Y1, X2, Y2)",
        "nType": "The type of drawing:",
        "PenStyle": "The style of the pen used to draw:",
        "PenCol": "The color of the pen (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "PenWidth": "Pen width in pixels. If the width is thicker than one pixel, you need to use a solid pen (PenStyle = 0). Maximum width is 32.",
        "nFill": "The fill color of the rectangle, square, circle, or ellipse (flashing color is not supported). Select a color from the list of predefined color names and codes or create an RGB-based color using the function MakeCitectColour. For a point or line, nFill is ignored.",
        "X1, Y1": "X and y coordinates (in pixels) of the upper-left corner of the drawing (the origin).",
        "X2, Y2": "X and y coordinates (in pixels) of the lower-right corner of the drawing."
      },
      "helpPath": "PlotDraw.html"
    },
    "plotgetmarker": {
      "name": "PlotGetMarker",
      "returnType": "UNKNOWN",
      "params": [
        "sSymbolName"
      ],
      "doc": "Gets the marker number of a symbol.",
      "returns": "The marker number if successful, otherwise -1 is returned.",
      "paramDocs": {
        "sSymbolName": "PlotGetMarker(sSymbolName)"
      },
      "helpPath": "PlotGetMarker.html"
    },
    "plotgrid": {
      "name": "PlotGrid",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "nSamples",
        "X1",
        "Y1",
        "X2",
        "Y2",
        "nHorGrid",
        "HorGridCol",
        "nVerGrid",
        "VerGridCol",
        "FrameWidth",
        "FrameCol",
        "nFill",
        "nMode"
      ],
      "doc": "Defines a frame and draws horizontal and vertical grid lines within this frame.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "nSamples": "Defines a frame and draws horizontal and vertical grid lines within this frame. These grid lines can then be used by the PlotLine(), PlotXYLine(), and PlotScaleMarker() functions. You need to define the frame for a plot before you can plot points with the PlotLine() and PlotXYLine() functions. nSamples specifies the maximum number of samples that can be plotted for a single line. If you set FrameWidth to 0 (zero), the frame will be defined but not displayed (however, the plot will still be displayed).",
        "nHorGrid": "You can specify the number of grid lines and their color, as well as the background color which will fill the frame. If nHorGrid and nVerGrid are set to 0 (zero), then the grid lines will not be drawn.",
        "hPlot": "you need to call the PlotOpen() function, first, to get the handle for the plot (hPlot), and to specify the output device. Then call this function to set up the frame and grid. You can then call the PlotScaleMarker() function to draw scale lines beside the frame, and call the PlotLine() or PlotXYLine() to plot a set of data points.",
        "hPlot, nSamples, X1, Y1, X2, Y2, nHorGrid, HorGridCol, nVerGrid, VerGridCol, FrameWidth, FrameCol, nFill, nMode": "PlotGrid(hPlot, nSamples, X1, Y1, X2, Y2, nHorGrid, HorGridCol, nVerGrid, VerGridCol, FrameWidth, FrameCol, nFill, nMode)",
        "X1, Y1": "The x and y coordinates of the upper-left corner of the frame containing the grid lines.",
        "X2, Y2": "The x and y coordinates of the lower-right corner of the frame containing the grid lines.",
        "HorGridCol": "The color of the horizontal grid lines (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "nVerGrid": "The number of columns (formed by the vertical grid lines) to draw within the frame. If there is no need of grid lines, set nVerGrid to 0 (zero) and VerGridCol to 0. nVerGrid cannot exceed the pixel height of the plot.",
        "VerGridCol": "The color of the vertical grid lines (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "FrameWidth": "The width (also called pen width) of the frame enclosing the grid, in pixels. To define the frame without drawing its boundaries, set FrameWidth to 0 (zero) and FrameCol to 0. The maximum is 32.",
        "FrameCol": "The color of the frame enclosing the grid (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "nFill": "The background color for the frame (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "nMode": "The mode of the plot. For future use only - set it to 0 (zero)."
      },
      "helpPath": "PlotGrid.html"
    },
    "plotinfo": {
      "name": "PlotInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "Type [",
        "sInput]"
      ],
      "doc": "Gets information about the plot.",
      "returns": "The attributes of the plot as a string.",
      "paramDocs": {
        "0": "Horizontal pixels on a printout page",
        "1": "Vertical pixels on a printout page",
        "2": "Horizontal pixels per inch",
        "3": "Vertical pixels per inch",
        "4": "Horizontal resolution",
        "5": "Vertical resolution",
        "6": "Height of the font used",
        "7": "External leading of the font used",
        "8": "Character width of the font used",
        "9": "Rotatable text is allowed or not",
        "10": "Indicates whether or not a font is supported",
        "11": "Horizontal size of a page in millimeters",
        "12": "Vertical size of a page in millimeters",
        "hPlot": "you need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device.",
        "hPlot, Type [, sInput]": "PlotInfo(hPlot, Type [, sInput] )",
        "nType": "The type of plot information to get:",
        "sInput": "The font handle (hFont), returned from the DspFont() function. Useful only for Type 6, 7, 8, or 10."
      },
      "helpPath": "PlotInfo.html"
    },
    "plotline": {
      "name": "PlotLine",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "PenStyle",
        "PenCol",
        "PenWidth",
        "MarkerStyle",
        "MarkerCol",
        "nMarker",
        "Length",
        "pTable",
        "LoScale",
        "HiScale",
        "Mode"
      ],
      "doc": "Draws a line (in the plot system) for a set of data points.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Solid",
        "1": "Dash ( - - - - - )",
        "2": "Dot (...............................)",
        "3": "Dash and dot ( - . - . - . - . - )",
        "4": "Dash, dot, dot ( - . . - . . - . . - )",
        "5": "Hollow",
        "6": "Filled square",
        "7": "Filled circle",
        "8": "Filled diamond",
        "pTable": "Draws a line (in the Plant SCADA plot system) for a set of data points. You specify the data points in the table pTable, and plot these points between the LoScale and HiScale values. The line is drawn inside the frame defined by the PlotGrid() function.",
        "hPlot": "you need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You should then use the PlotGrid() function to set up the frame and grid, before you call this function to plot the line.",
        "hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, pTable, LoScale, HiScale, Mode": "PlotLine(hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, pTable, LoScale, HiScale, Mode)",
        "PenStyle": "The style of the pen used to draw:",
        "PenCol": "The color of the pen (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "PenWidth": "The width of the pen, in pixels. If the width is thicker than one pixel, you need to use a solid pen (PenStyle = 0). The maximum width is 32.",
        "MarkerStyle": "The style of the markers:",
        "20 - 32000": "User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function if the number of markers you have previously registered are unknown.",
        "MarkerCol": "The color of the markers (flashing color is not supported). Select a color from the list of predefined color names and codes or create an RGB-based color using the function MakeCitectColour.",
        "nMarker": "The number of samples between markers.",
        "Length": "The length of the array, that is, the number of points in the table pTable for PlotLine(), or in tables xTable and yTable for PlotXYLine().",
        "LoScale": "The lowest value that will be displayed on the plot (that is the value assigned to the origin of your grid). The LoScale and HiScale values determine the scale of your grid. This scale is used to plot values. for example, If LoScale = 0 (zero) and HiScale = 100, a value of 50 will be plotted half way up the Y-axis of your grid. LoScale needs to be in the same units as the values in pTable.",
        "HiScale": "The highest value that will be displayed on the plot. The LoScale and HiScale values determine the scale of your grid. This scale is used to plot values. for example, If LoScale = 0 (zero) and HiScale = 100, a value of 50 will be plotted half way up the Y- axis of your grid. HiScale needs to be in the same units as the values in pTable.",
        "Mode": "The origin of your grid, and the direction of the plotted line:"
      },
      "helpPath": "PlotLine.html"
    },
    "plotmarker": {
      "name": "PlotMarker",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "MarkerStyle",
        "MarkerCol",
        "nMarker",
        "Length",
        "X",
        "Y"
      ],
      "doc": "Draws markers on a plotted line or at a specified point.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "No markers",
        "1": "Triangle",
        "2": "Square",
        "3": "Circle",
        "4": "Diamond",
        "5": "Filled triangle",
        "6": "Filled square",
        "7": "Filled circle",
        "8": "Filled diamond",
        "X": "To draw a single marker at a specified point, set X and Y to the coordinates of the point, and set Length to 1.",
        "hPlot, MarkerStyle, MarkerCol, nMarker, Length, X, Y": "PlotMarker(hPlot, MarkerStyle, MarkerCol, nMarker, Length, X, Y)",
        "hPlot": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where data on the plot is stored.",
        "MarkerStyle": "The style of the markers:",
        "20 - 32000": "User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function if the number of markers you have previously registered are unknown.",
        "MarkerCol": "The color of the marker (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "nMarker": "The number of samples between markers.",
        "Length": "The length of the array (the number of line points in the table pTable) plotted in the PlotLine() or PlotXYLine() function. To draw only one marker at a specified point, set Length to 1.",
        "X, Y": "The x and y coordinates, in pixels, of the point where the marker is to be drawn. If the plot is for display on the screen, the coordinates are relative to the AN specified in the PlotOpen() function. If the output device is a printer, the coordinates are relative to the point (0,0)."
      },
      "helpPath": "PlotMarker.html"
    },
    "plotopen": {
      "name": "PlotOpen",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "sOutput",
        "Mode"
      ],
      "doc": "Opens a new plot, sets its output device, and returns its plot handle.",
      "returns": "The plot handle if the plot is opened successfully, otherwise -1 is returned. The plot handle identifies the table where all data on the associated plot is stored.",
      "paramDocs": {
        "1": "Normal mode",
        "2": "Use for compatibility with the old graph functions",
        "17": "Soft (valid for normal mode). The background screen (a rectangular region beneath the plot) is restored with the original image. Any objects that are within the rectangular region are destroyed when the background is restored.",
        "33": "Hard (valid for normal mode). The background screen (a rectangular region beneath the plot) is painted with the color at the AN.",
        "65": "Persistent (valid for normal mode). The plot is not erased. As the plot is updated, it is re-displayed on top. This mode provides fast updates. Transparent color is supported in this mode.",
        "129": "Opaque animation (valid for normal mode). The plot is not erased. As the plot is updated, it is re-displayed on top. This mode provides the fastest updates. Transparent color is not supported in this mode.",
        "257": "Overlapped animation (valid for normal mode). The background screen (the rectangular region beneath the plot) is completely repainted.",
        "nAN, sOutput, Mode": "PlotOpen(nAN, sOutput, Mode)",
        "nAN": "The animation point (AN) where the plot will display. Set the AN to 0 (zero) when sOutput is a printer.",
        "sOutput": "The output device where the plot is sent, for example:",
        "Mode": "When a plot is removed or updated, the portion of the background screen beneath it is blanked out. The mode determines how the background screen is restored. The mode of the plot system:"
      },
      "helpPath": "PlotOpen.html"
    },
    "plotscalemarker": {
      "name": "PlotScaleMarker",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "X",
        "Y",
        "nMarker",
        "PenWidth",
        "PenCol",
        "Mode"
      ],
      "doc": "Draws scale lines beside the grid on your plot (if there is one) and places markers on them.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Both sides of the scale line",
        "1": "Left of the scale line",
        "2": "Right of the scale line",
        "hPlot, X, Y, nMarker, PenWidth, PenCol, Mode": "PlotScaleMarker(hPlot, X, Y, nMarker, PenWidth, PenCol, Mode)",
        "hPlot": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where data on the plot is stored.",
        "X, Y": "The x and y coordinates of the point where the scale line starts. The end coordinates of the scale line are automatically defined by the size of the frame (set in the PlotGrid() function).",
        "nMarker": "The number of markers on the scale line.",
        "PenWidth": "The width of the scale line, in pixels.",
        "PenCol": "The color of the pen (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "Mode": "The mode of the markers:"
      },
      "helpPath": "PlotScaleMarker.html"
    },
    "plotsetmarker": {
      "name": "PlotSetMarker",
      "returnType": "UNKNOWN",
      "params": [
        "MarkerNo",
        "sSymbolName"
      ],
      "doc": "Registers a symbol as a marker.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "MarkerNo": "Registers a symbol as a marker. You can then draw the new marker at points and on plotted lines, by specifying the MarkerNo of the symbol as the MarkerStyle in the PlotMarker() function. Call the PlotGetMarker() function if you do not know the number of a marker.",
        "MarkerNo, sSymbolName": "PlotSetMarker(MarkerNo, sSymbolName)",
        "sSymbolName": "The name and path of the symbol to be defined as a marker."
      },
      "helpPath": "PlotSetMarker.html"
    },
    "plottext": {
      "name": "PlotText",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "hFont",
        "Orientation",
        "X",
        "Y",
        "sText"
      ],
      "doc": "Prints text on a plot. You can specify the font, position, and orientation of the text.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Left-to-right",
        "1": "Upwards",
        "2": "Right-to-left",
        "3": "Downwards",
        "hFont": "you need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You also needs to call the DspFont() function to get a handle for the font (hFont).",
        "hPlot, hFont, Orientation, X, Y, sText": "PlotText(hPlot, hFont, Orientation, X, Y, sText)",
        "hPlot": "The plot handle, returned from the PlotOpen() function. The plot handle identifies the table where all data on the plot is stored.",
        "Orientation": "The orientation of the text:",
        "X, Y": "The x and y coordinates (in pixels) of the start of the text. If the plot is for display on the screen, the coordinates are relative to the AN specified in the PlotOpen() function. If the output device is a printer, the coordinates are relative to the point (0,0).",
        "sText": "The text string to be plotted."
      },
      "helpPath": "PlotText.html"
    },
    "plotxyline": {
      "name": "PlotXYLine",
      "returnType": "UNKNOWN",
      "params": [
        "hPlot",
        "PenStyle",
        "PenCol",
        "PenWidth",
        "MarkerStyle",
        "MarkerCol",
        "nMarker",
        "Length",
        "xTable",
        "LoXScale",
        "HiXScale",
        "YTable",
        "LoYScale",
        "HiYScale",
        "Mode"
      ],
      "doc": "Plots values from two different tables. Values from one table are considered X coordinates, and values from the other are considered Y coordinates.",
      "returns": "0 (zero) if successful, otherwise an error is returned.",
      "paramDocs": {
        "0": "Solid",
        "1": "Dash ( - - - - - )",
        "2": "Dot (...............................)",
        "3": "Dash and dot ( - . - . - . - . - )",
        "4": "Dash, dot, dot ( - . . - . . - . . - )",
        "5": "Hollow",
        "6": "Filled square",
        "7": "Filled circle",
        "8": "Filled diamond",
        "hPlot": "For each line, you can specify a different pen style, color, and width, and a different marker style and color. You can draw lines either from left to right or from right to left. You need to first call the PlotOpen() function to get the handle for the plot (hPlot) and specify the output device. You should then use the PlotGrid() function to set up the frame and grid, before you call this function to plot the line.",
        "hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, xTable, LoXScale, HiXScale, YTable, LoYScale, HiYScale, Mode": "PlotXYLine(hPlot, PenStyle, PenCol, PenWidth, MarkerStyle, MarkerCol, nMarker, Length, xTable, LoXScale, HiXScale, YTable, LoYScale, HiYScale, Mode)",
        "PenStyle": "The style of the pen used to draw:",
        "PenCol": "The color of the pen (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "PenWidth": "The width of the pen, in pixels. If the width is thicker than one pixel, you need to use a solid pen (PenStyle = 0). The maximum width is 32.",
        "MarkerStyle": "The style of the markers:",
        "20 - 32000": "User-defined markers. You can register any symbol as a marker with the PlotSetMarker() function. Call the PlotGetMarker() function to recall the number of a marker you have previously registered.",
        "MarkerCol": "The color of the markers (flashing color is not supported). Select a color from the list of Predefined Color Names and Codes or create an RGB-based color using the function MakeCitectColour.",
        "nMarker": "The number of samples between markers.",
        "Length": "The length of the array, that is the number of points in the table pTable for PlotLine(), or in tables xTable and yTable for PlotXYLine().",
        "xTable": "The x coordinates for the points in the line, as an array of floating point values.",
        "LoXScale": "The lowest X-axis value that will be displayed on the plot (that is the X-coordinate of the origin of your grid). The LoXScale and HiXScale values determine the scale of your grid. This scale is used to plot values. for example, If LoXScale = 0 (zero) and HiXScale = 100, a value of 50 will be plotted half way along the X-axis of your grid.",
        "HiXScale": "The highest X-axis value that will be displayed on the plot. The LoXScale and HiXScale values determine the scale of your grid. This scale is used to plot values. for example, If LoXScale = 0 (zero) and HiXScale = 100, a value of 50 will be plotted half way along the X-axis of your grid.",
        "yTable": "The y coordinates for the points in the line, as an array of floating point values.",
        "LoYScale": "The lowest Y-axis value that will be displayed on the plot (that is the Y-coordinate of the origin of your grid). The LoYScale and HiYScale values determine the scale of your grid. This scale is used to plot values. for example, If LoYScale = 0 (zero) and HiYScale = 100, a value of 50 will be plotted half way up the Y-axis of your grid.",
        "HiYScale": "The highest Y-axis value that will be displayed on the plot. The LoYScale and HiYScale values determine the scale of your grid. This scale is used to plot values. for example, If LoYScale = 0 (zero) and HiYScale = 100, a value of 50 will be plotted half way up the Y-axis of your grid.",
        "Mode": "The origin of your grid, and the direction of the plotted line:"
      },
      "helpPath": "PlotXYLine.html"
    },
    "pow": {
      "name": "Pow",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y"
      ],
      "doc": "Calculates x to the power of y.",
      "returns": "X to the power of Y.",
      "paramDocs": {
        "X, Y": "Pow(X, Y)",
        "X": "The base number.",
        "Y": "The exponent."
      },
      "helpPath": "Pow.html"
    },
    "print": {
      "name": "Print",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Prints a string on the current device. You should call this function only in a report.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "String": "Print(String)"
      },
      "helpPath": "Print.html"
    },
    "printfont": {
      "name": "PrintFont",
      "returnType": "UNKNOWN",
      "params": [
        "Font"
      ],
      "doc": "Changes the printing font on the current device.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Font": "PrintFont(Font)"
      },
      "helpPath": "PrintFont.html"
    },
    "println": {
      "name": "PrintLn",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Prints a string on the current device, followed by a newline character.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "String": "PrintLn(String)"
      },
      "helpPath": "PrintLn.html"
    },
    "processanalystloadfile": {
      "name": "ProcessAnalystLoadFile",
      "returnType": "UNKNOWN",
      "params": [
        "sPAVFile",
        "iFileLocation",
        "iButtonMask",
        "sObjName"
      ],
      "doc": "Loads the specified PAV file to a Process Analyst object, which is identified by parameter ObjName.",
      "returns": "Zero (0) if the function is successfully run. otherwise an error code is returned.",
      "paramDocs": {
        "sPAVFile, iFileLocation, iButtonMask, sObjName": "ProcessAnalystLoadFile(sPAVFile, iFileLocation, iButtonMask, sObjName )",
        "sPAVFile": "Name of the PAV file",
        "iFileLocation": "PAV file location code for the PAV file. Indicates which known location to load the file from.",
        "iButtonMask": "Bit mask for removing command buttons from the PA, bit flags as shown below:",
        "sObjName": "Name of the PA object on the given Page where the PAV file will be loaded."
      },
      "helpPath": "ProcessAnalystLoadFile.html"
    },
    "processanalystpopup": {
      "name": "ProcessAnalystPopup",
      "returnType": "UNKNOWN",
      "params": [
        "sPage [",
        "sPAVFile [",
        "iFileLocation [",
        "iButtonMask [",
        "sObjName [",
        "iMode ]]]]]"
      ],
      "doc": "Displays a Process Analyst page (in a new page child window) at the current mouse position.",
      "returns": "Window number if the window is successfully displayed. Otherwise -1 is returned.",
      "paramDocs": {
        "sPage": "ProcessAnalystPopup(sPage [, sPAVFile [, iFileLocation [, iButtonMask [, sObjName [, iMode ]]]]])",
        "sPAVFile": "Name of the PAV file",
        "iFileLocation": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details.",
        "iButtonMask": "Bit mask for removing command buttons from the PA, bit flags as shown below:",
        "sObjName": "Name of the PA object on the given Page where the PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\".",
        "iMode": "The mode of the window (see WinNewAt() for details)."
      },
      "helpPath": "ProcessAnalystPopUp.html"
    },
    "processanalystselect": {
      "name": "ProcessAnalystSelect",
      "returnType": "UNKNOWN",
      "params": [
        "(iWindow",
        "sPage [",
        "sObjName [",
        "sClusterName [",
        "iButtonMask [",
        "sPAVFile [",
        "iFileLocation]]]]])"
      ],
      "doc": "Allows a set of pens to be selected before displaying a PA page.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(iWindow, sPage [, sObjName [, sClusterName [, iButtonMask [, sPAVFile [, iFileLocation]]]]])": "ProcessAnalystSelect((iWindow, sPage [, sObjName [, sClusterName [, iButtonMask [, sPAVFile [, iFileLocation]]]]]) )",
        "iWindow": "The window number (returned from the WinNumber() function):",
        "sPage": "The name of the page that displays the PA.",
        "sObjName": "The name of the PA object. If this is not specified, it is defaulted to \"_TemplatePA1\" which is the name used by the built-in templates.",
        "sClusterName": "The name of the cluster that is associated with any trend tag for this PA. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\".",
        "iButtonMask": "Bit mask for removing command buttons from the PA, bit flags as shown below:",
        "sPAVFile": "Name of the PAV file",
        "iFileLocation": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details."
      },
      "helpPath": "ProcessAnalystSelect.html"
    },
    "processanalystsetpen": {
      "name": "ProcessAnalystSetPen",
      "returnType": "UNKNOWN",
      "params": [
        "(iPen",
        "sTag [",
        "sObjName [",
        "iPane [",
        "iPenType]]])"
      ],
      "doc": "Allows a new pen to be added to a PA display.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(iPen, sTag [, sObjName [, iPane [, iPenType]]])": "ProcessAnalystSetPen((iPen, sTag [, sObjName [, iPane [, iPenType]]]) )",
        "iPen": "Pen number. The allowed values are:",
        "sTag": "The trend tag name to be assigned to the pen.",
        "sObjName": "The name of the PA object. If this is set to \"-2\", the pen is set to the next displayed PA page set up by ProcessAnalystSelect(). If the specified ObjName is valid, the changes will be applied to the currently displayed PA. Otherwise, the function will try to set the pen to the specified object on the currently displayed page. If this parameter is not specified or is an empty string, it will default to the object name used in the tab style templates, that is \"_templatePA1\".",
        "iPane": "Optional number of the pane where the trend or variable tags are added. Please see the same parameter for function PageProcessAnalystPens() for details. Defaulted to 0, that is, the first pane.",
        "iPenType": "Pen type for creation. The allowed values are:"
      },
      "helpPath": "ProcessAnalystSetPen.html"
    },
    "processanalystwin": {
      "name": "ProcessAnalystWin",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "iX",
        "iY",
        "iMode [",
        "sPAVFile [",
        "iFileLocation [",
        "iButtonMask [",
        "sObjName ]]]]"
      ],
      "doc": "Displays a Process Analyst page (in a new window) preloaded with the pre-defined Process Analyst View (PAV) file.",
      "returns": "Window number if the window is successfully displayed. Otherwise -1 is returned.",
      "paramDocs": {
        "sPage, iX, iY, iMode [, sPAVFile [, iFileLocation [, iButtonMask [, sObjName ]]]]": "ProcessAnalystWin(sPage, iX, iY, iMode [, sPAVFile [, iFileLocation [, iButtonMask [, sObjName ]]]])",
        "sPage": "The name of the page that contains Process Analyst object(s). For example, pages based on the Process Analyst templates found in the Tab_Style_Include project.",
        "iX": "The X pixel coordinate",
        "iY": "The Y pixel coordinate",
        "iMode": "The mode of the window (see WinNewAt() for details).",
        "sPAVFile": "Name of the PAV file",
        "iFileLocation": "PAV file location code for the PAV file, see PA doc LoadFromFile() for details.",
        "iButtonMask": "Bit mask for removing command buttons from the PA, bit flags as shown below:",
        "sObjName": "Name of the PA object on the given Page where the PAV file will be loaded. If this parameter is not specified or empty string, it is defaulted to the object name used in the tab style templates, that is \"_templatePA1\"."
      },
      "helpPath": "ProcessAnalystWin.html"
    },
    "processisclient": {
      "name": "ProcessIsClient",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Determines if the currently executing process contains a client component.",
      "returns": "TRUE (1) if the process contains a Client component, otherwise FALSE (0).",
      "paramDocs": {},
      "helpPath": "ProcessIsClient.html"
    },
    "processisserver": {
      "name": "ProcessIsServer",
      "returnType": "UNKNOWN",
      "params": [
        "sServerType [",
        "sClusterName] [",
        "sServerName]"
      ],
      "doc": "Determines if the currently executing process contains a particular server component.",
      "returns": "TRUE (1) if the process contains the specified component, otherwise FALSE (0).",
      "paramDocs": {
        "sServerType": "ProcessIsServer(sServerType [, sClusterName] [, sServerName])",
        "sClusterName": "Optional case insensitive string specifying the cluster name to combine with the server type specified in the first argument and the server name (if specified).",
        "sServerName": "Optional case insensitive string specifying a server name to combine with the server type specified in the first argument and the cluster name (if specified)."
      },
      "helpPath": "ProcessIsServer.html"
    },
    "processrestart": {
      "name": "ProcessRestart",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Restarts the current process in which Cicode is running.",
      "returns": "0 (zero) if successful, otherwise the following error is returned:",
      "paramDocs": {},
      "helpPath": "ProcessRestart.html"
    },
    "productinfo": {
      "name": "ProductInfo",
      "returnType": "UNKNOWN",
      "params": [
        "iType"
      ],
      "doc": "Returns information about the Plant SCADA product.",
      "returns": "The product information. An empty string will be returned if the type is invalid.",
      "paramDocs": {
        "0": "product name, default",
        "1": "product company",
        "2": "product major version",
        "3": "product minor version",
        "4": "product version string",
        "iType": "ProductInfo(iType)"
      },
      "helpPath": "ProductInfo.html"
    },
    "projectinfo": {
      "name": "ProjectInfo",
      "returnType": "UNKNOWN",
      "params": [
        "iProject",
        "iType"
      ],
      "doc": "Returns information about a particular project, which is identified by a project enumerated number.",
      "returns": "The specified project information. An empty string will be returned if the project number or type is invalid",
      "paramDocs": {
        "0": "Project name",
        "1": "Project description",
        "2": "Project major revision number",
        "3": "Project minor revision number",
        "4": "Project date",
        "5": "Project time",
        "iProject, iType": "ProjectInfo(iProject, iType)",
        "iProject": "Project number. This is a sequential number generated by the Compiler starting from 0,1,2,3,4,5.... to 1026, so the maximum include projects are limited to 1027.",
        "iType": "Type of information to return:"
      },
      "helpPath": "ProjectInfo.html"
    },
    "projectrestartget": {
      "name": "ProjectRestartGet",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the path to the project to be run the next time Plant SCADA is restarted.",
      "returns": "The path to the project to be run the next time Plant SCADA is restarted.",
      "paramDocs": {},
      "helpPath": "ProjectRestartGet.html"
    },
    "projectrestartset": {
      "name": "ProjectRestartSet",
      "returnType": "UNKNOWN",
      "params": [
        "sPath"
      ],
      "doc": "Sets the path to the project to be run the next time Plant SCADA is restarted.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPath": "ProjectRestartSet(sPath)"
      },
      "helpPath": "ProjectRestartSet.html"
    },
    "projectset": {
      "name": "ProjectSet",
      "returnType": "UNKNOWN",
      "params": [
        "sProject"
      ],
      "doc": "Sets either the name or the path of the project to be run next time Plant SCADA is restarted.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sProject": "ProjectSet(sProject)"
      },
      "helpPath": "projectset.html"
    },
    "prompt": {
      "name": "Prompt",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Displays a message in the prompt line on the operator's computer.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "String": "Prompt(String)"
      },
      "helpPath": "Prompt.html"
    },
    "pulse": {
      "name": "Pulse",
      "returnType": "UNKNOWN",
      "params": [
        "sTag"
      ],
      "doc": "Pulses (jogs) a variable tag on, then off.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTag": "Pulse(sTag)"
      },
      "helpPath": "Pulse.html"
    },
    "qualitycreate": {
      "name": "QualityCreate",
      "returnType": "UNKNOWN",
      "params": [
        "INT generalQuality [",
        "INT qualitySubstatus [",
        "INT qualityLimit [",
        "INT extendedSubstatus [",
        "INT bOverride [",
        "bControlInhibit [",
        "INT datasourceErrorCode ]]]]]]"
      ],
      "doc": "Creates a quality value based on the quality fields provided.",
      "returns": "The Quality value of the element.",
      "paramDocs": {
        "generalQuality": "Specifies the general quality.",
        "qualitySubstatus": "Specifies the quality substatus.",
        "qualityLimit": "TheQuality Limit."
      },
      "helpPath": "QualityCreate.html"
    },
    "qualitygetpart": {
      "name": "QualityGetPart",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY Quality",
        "INT Part"
      ],
      "doc": "Extracts a requested part of the quality value from a variable tag's quality item.",
      "returns": "The value of the requested Quality part (see tables below), or -1 if error.",
      "paramDocs": {
        "Quality": "QualityGetPart(QUALITY Quality, INT Part)",
        "Part": "The part to extract:",
        "part": "To determine which substatus group the return value is from, you need to initially call the General Quality Value (part = 0)."
      },
      "helpPath": "QualityGetPart.html"
    },
    "qualityisbad": {
      "name": "QualityIsBad",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality"
      ],
      "doc": "This function will return a value indicating whether the general part of quality is bad.",
      "returns": "0: the quality is not bad.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable."
      },
      "helpPath": "QualityIsBad.html"
    },
    "qualityiscontrolinhibit": {
      "name": "QualityIsControlInhibit",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality"
      ],
      "doc": "Returns a value indicating whether the tag is in Control Inhibit Mode.",
      "returns": "0: the tag is not in Control inhibit Mode.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable."
      },
      "helpPath": "QualityIsControlInhibit.html"
    },
    "qualityisgood": {
      "name": "QualityIsGood",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality"
      ],
      "doc": "This function will return a value indicating whether the general part of quality is good.",
      "returns": "0: the quality is not good.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable."
      },
      "helpPath": "QualityIsGood.html"
    },
    "qualityisoverrride": {
      "name": "QualityIsOverrride",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality"
      ],
      "doc": "Returns a value indicating whether the tag is in Override Mode.",
      "returns": "0: the tag is not in Override Mode.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable."
      },
      "helpPath": "QualityIsOverride.html"
    },
    "qualityisuncertain": {
      "name": "QualityIsUncertain",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality"
      ],
      "doc": "This function will return a value indicating whether the general part of quality is uncertain.",
      "returns": "0: the quality is not uncertain.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable."
      },
      "helpPath": "QualityIsUncertain.html"
    },
    "qualitysetpart": {
      "name": "QualitySetPart",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality",
        "INT part",
        "INT value"
      ],
      "doc": "Sets a Quality parts value to the QUALITY variable.",
      "returns": "The modified Quality value, or the original value if the given part is not applicable.",
      "paramDocs": {
        "quality": "Specifies the quality variable.",
        "part": "The part to extract:",
        "value": "The new value for the given part."
      },
      "helpPath": "QualitySetPart.html"
    },
    "qualitytostr": {
      "name": "QualityToStr",
      "returnType": "UNKNOWN",
      "params": [
        "QUALITY quality",
        "INT part",
        "INT localized"
      ],
      "doc": "Returns a textual representation of the quality.",
      "returns": "A textual representation of the quality, or an empty string if the part given is not applicable.",
      "paramDocs": {
        "quality": "Specifies the QUALITY variable.",
        "part": "Specifies the part of quality to obtain the textual representation.",
        "localized": "The flag indicating if the returned text should be in native language or in Runtime localized language."
      },
      "helpPath": "QualityToStr.html"
    },
    "queclose": {
      "name": "QueClose",
      "returnType": "UNKNOWN",
      "params": [
        "hQue"
      ],
      "doc": "Closes a queue opened with the QueOpen() function. All data is flushed from the queue.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hQue": "QueClose(hQue)"
      },
      "helpPath": "QueClose.html"
    },
    "quelength": {
      "name": "QueLength",
      "returnType": "UNKNOWN",
      "params": [
        "hQue"
      ],
      "doc": "Gets the current length of the queue.",
      "returns": "The current length of the queue. If the queue is closed then 0 is returned.",
      "paramDocs": {
        "hQue": "QueLength(hQue)"
      },
      "helpPath": "QueLength.html"
    },
    "queopen": {
      "name": "QueOpen",
      "returnType": "UNKNOWN",
      "params": [
        "Name",
        "Mode"
      ],
      "doc": "Open a queue for reading and writing data elements.",
      "returns": "The queue handle, or -1 if the queue cannot be opened. The queue handle identifies the table where all data on the associated queue is stored.",
      "paramDocs": {
        "0": "Open existing queue.",
        "1": "Create new queue.",
        "2": "Attempts to open an existing queue. If the queue does not exist, it will create it.",
        "4": "Create a queue that can have multiple blocked readers.",
        "Name, Mode": "QueOpen(Name, Mode)",
        "sName": "The name of the queue. You need to use the following syntax:",
        "Mode": "The mode of the queue open:"
      },
      "helpPath": "QueOpen.html"
    },
    "quepeek": {
      "name": "QuePeek",
      "returnType": "UNKNOWN",
      "params": [
        "hQue",
        "Type",
        "Str",
        "Mode"
      ],
      "doc": "Searches a queue for a queue element.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "Search for a matching string.",
        "2": "Search for a matching number.",
        "4": "Search for a matching string and use a case-sensitive search.",
        "8": "If the element is found, remove it from the queue.",
        "16": "Search the queue, in order, for the element at the offset specified by Type.",
        "Mode": "Searches a queue for a queue element. You can search for the element by specifying a string, an integer, or both. You can remove the element from the queue by adding 8 to the Mode.",
        "hQue, Type, Str, Mode": "QuePeek(hQue, Type, Str, Mode)",
        "hQue": "The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
        "nType": "The number to search for (if using the search mode for a matching number). If you are using a matching string mode, the number found is returned in Type. Must be a Long type variable.",
        "Str": "The string to search for (if using the search mode for a matching string). If you are using a matching number mode, the string found is returned in Str. Must be a String type variable."
      },
      "helpPath": "QuePeek.html"
    },
    "queread": {
      "name": "QueRead",
      "returnType": "UNKNOWN",
      "params": [
        "hQue",
        "Type",
        "Str",
        "Mode"
      ],
      "doc": "Reads data from a queue, starting from the head of the queue.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Non-blocking.",
        "1": "Wait for element.",
        "Mode": "Reads data from a queue, starting from the head of the queue. Data is returned in the same order as it was written onto the queue and is removed from the queue when read. If the Mode is 0 (non-blocking) and the queue is empty, the function returns with an error. If the Mode is 1 (blocking) the function does not return until another Cicode task writes data onto the queue.",
        "hQue, Type, Str, Mode": "QueRead(hQue, Type, Str, Mode)",
        "hQue": "The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
        "nType": "The integer to read from the queue (written to the queue as Type by the QueWrite() function). Must be an Integer type variable.",
        "Str": "The string to read from the queue (written to the queue as Str by the QueWrite() function). Must be a String type variable."
      },
      "helpPath": "QueRead.html"
    },
    "quewrite": {
      "name": "QueWrite",
      "returnType": "UNKNOWN",
      "params": [
        "hQue",
        "Type",
        "Str"
      ],
      "doc": "Writes an integer and string onto the end of a queue.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hQue, Type, Str": "QueWrite(hQue, Type, Str)",
        "hQue": "The queue handle, returned from the QueOpen() function. The queue handle identifies the table where all data on the associated queue is stored.",
        "nType": "The integer to put into the queue.",
        "Str": "The string to put into the queue."
      },
      "helpPath": "QueWrite.html"
    },
    "radtodeg": {
      "name": "RadToDeg",
      "returnType": "UNKNOWN",
      "params": [
        "Angle"
      ],
      "doc": "Converts an angle from radians to degrees.",
      "returns": "The angle in degrees.",
      "paramDocs": {
        "Angle": "RadToDeg(Angle)"
      },
      "helpPath": "RadToDeg.html"
    },
    "rand": {
      "name": "Rand",
      "returnType": "UNKNOWN",
      "params": [
        "Maximum"
      ],
      "doc": "Generates a random number between 0 and a specified maximum number less one.",
      "returns": "A random number of integer type.",
      "paramDocs": {
        "Maximum": "Rand(Maximum)"
      },
      "helpPath": "Rand.html"
    },
    "realtostr": {
      "name": "RealToStr",
      "returnType": "UNKNOWN",
      "params": [
        "Number",
        "Width",
        "Places[",
        "Separator]"
      ],
      "doc": "Converts a floating-point number into a string.",
      "returns": "The floating-point number (as a string).",
      "paramDocs": {
        "Number, Width, Places[, Separator]": "RealToStr(Number, Width, Places[, Separator])",
        "Number": "The floating-point number to convert.",
        "Width": "The width of the string.",
        "Places": "The number of decimal places contained in the string.",
        "Separator": "Optionally, the decimal separator contained in the string. Defaults to empty string.",
        "\".\"": "period",
        "\",\"": "comma",
        "\"\"": "empty string"
      },
      "helpPath": "RealToStr.html"
    },
    "repgetcluster": {
      "name": "RepGetCluster",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "This function retrieves the name of the cluster a report is running on.",
      "returns": "The name of the cluster the report in running on.",
      "paramDocs": {},
      "helpPath": "RepGetCluster.html"
    },
    "repgetcontrol": {
      "name": "RepGetControl",
      "returnType": "UNKNOWN",
      "params": [
        "ReportName",
        "Type [",
        "sClusterName]"
      ],
      "doc": "Gets report control information on a report.",
      "returns": "The control information, as an integer.",
      "paramDocs": {
        "0": "State of the report - returns one of:",
        "1": "Time of day that the report is due to run next.",
        "2": "The report period, in seconds, or week day, month or year, for example, if the report is weekly, this is the day of the week, 0 (Sunday) to 6 (Saturday).",
        "3": "Synchronisation time of day of the report, for example, 10:00:00 (In seconds from midnight).",
        "4": "Type of report schedule - returns one of:",
        "5": "Report state - returns one of:",
        "ReportName, Type [, sClusterName]": "RepGetControl(ReportName, Type [, sClusterName])",
        "ReportName": "The name of the report (can be prefixed by the name of the cluster that is ClusterName.ReportName).",
        "nType": "The type of report control information to get (send back in the return value):",
        "sClusterName": "Name of the cluster in which the report resides. This is optional if you have one cluster or are resolving the report server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "RepGetControl.html"
    },
    "report": {
      "name": "Report",
      "returnType": "UNKNOWN",
      "params": [
        "ReportName [",
        "sClusterName]"
      ],
      "doc": "Runs a report on the Report Server.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "ReportName [, sClusterName]": "Report(ReportName [, sClusterName] )",
        "ReportName": "The name of the report to run (can be prefixed by the name of the cluster that is ClusterName.ReportName).",
        "sClusterName": "Name of the cluster in which the report resides. This is optional if you have one cluster or are resolving the report server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "Report.html"
    },
    "repsetcontrol": {
      "name": "RepSetControl",
      "returnType": "UNKNOWN",
      "params": [
        "ReportName",
        "Type",
        "Data [",
        "sClusterName]"
      ],
      "doc": "Sets report control information to temporarily override the normal settings for a specified report.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "The time of day at which to run the next report in Cicode (date/time) variable type. Subsequent reports are run at the times calculated from the period (Type 2) and synchronisation time (Type 3). Use Type 1 to specify a one-time report. Set the time in Data in seconds from midnight (for example, specify 6 p.m. as TimeMidNight() + (18 * 60 * 60) ).",
        "2": "The report period. Set the new period in Data according to the report schedule (Type 4), in seconds from midnight, day of week (0 to 6, Sunday = 0), month (1 to 12), or year.",
        "3": "Synchronisation time of day of the report. Set the time in Data in seconds from midnight, for example, to synchronize at 10a.m., set Data to 10 * 60 * 60.",
        "4": "Type of report schedule. Set Data to one of the following:",
        "5": "Report state. Set Data to either:",
        "ReportName, Type, Data [, sClusterName]": "RepSetControl(ReportName, Type, Data [, sClusterName] )",
        "ReportName": "The name of the report (can be prefixed by the name of the cluster that is ClusterName.ReportName).",
        "nType": "The type of report control information to set:",
        "Data": "Data",
        "sClusterName": "Name of the cluster in which the report resides. This is optional if you have one cluster or are resolving the report server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "RepSetControl.html"
    },
    "reread": {
      "name": "ReRead",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "ReRead is deprecated in this version of Plant SCADA.",
      "returns": "No value (void).",
      "paramDocs": {
        "0": "Read only if data is stale.",
        "1": "Read anyway.",
        "Mode": "ReRead(Mode)"
      },
      "helpPath": "ReRead.html"
    },
    "resetscreenprofile": {
      "name": "ResetScreenProfile",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Moves all top level windows back to their original screen starting position as defined by the screen profile.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "ResetScreenProfile.html"
    },
    "round": {
      "name": "Round",
      "returnType": "UNKNOWN",
      "params": [
        "Number",
        "Places"
      ],
      "doc": "Rounds a number to a specified number of decimal places.",
      "returns": "The number rounded to Places decimal places.",
      "paramDocs": {
        "Number, Places": "Round(Number, Places)",
        "Number": "The floating-point number to round.",
        "Places": "The number of decimal places."
      },
      "helpPath": "Round.html"
    },
    "schdclose": {
      "name": "SchdClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdClose function terminates a browsing session and cleans up the resources used by the session.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdClose(LONG Session)",
        "Session": "The handle to a browse session previously returned by the SchdOpen call"
      },
      "helpPath": "SchdClose.html"
    },
    "schdconfigclose": {
      "name": "SchdConfigClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdConfigClose function terminates a browsing session and cleans up the resources used by the session.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdConfigClose(LONG Session )",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call."
      },
      "helpPath": "SchdConfigClose.html"
    },
    "schdconfigfirst": {
      "name": "SchdConfigFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdConfigFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdConfigFirst(LONG Session)",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call."
      },
      "helpPath": "SchdConfigFirst.html"
    },
    "schdconfiggetfield": {
      "name": "SchdConfigGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING Field"
      ],
      "doc": "The SchdConfigGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG Session": "STRING SchdConfigGetField(LONG Session, STRING Field )",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call.",
        "field": "field"
      },
      "helpPath": "SchdConfigGetField.html"
    },
    "schdconfignext": {
      "name": "SchdConfigNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdConfigNext function places the data browse cursor at the next available record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdConfigNext(LONG Session)",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call."
      },
      "helpPath": "SchdConfigNext.html"
    },
    "schdconfignumrecords": {
      "name": "SchdConfigNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdConfigNumRecords function returns the number of records that match the current filter criteria.",
      "returns": "Returns number of records. 0 means no records were found.",
      "paramDocs": {
        "LONG Session": "LONG SchdConfigNumRecords(LONG Session)",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call"
      },
      "helpPath": "SchdConfigNumRecords.html"
    },
    "schdconfigopen": {
      "name": "SchdConfigOpen",
      "returnType": "UNKNOWN",
      "params": [
        "[TIMESTAMP Start] [",
        "LONG Duration] [",
        "STRING Filter] [",
        "STRING Fields] [",
        "STRING Clusters]"
      ],
      "doc": "The SchdConfigOpen function initiates a new session for browsing the schedules configured.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "TIMESTAMP Start": "LONG SchdConfigOpen([TIMESTAMP Start] [, LONG Duration] [, STRING Filter] [, STRING Fields] [, STRING Clusters] )",
        "start": "The start date of the schedules in UTC time to return during the browse.If not specified, today at midnight will be taken as start time. The types of this field is TIMESTAMP. Use StrToTimestamp or TimestampCreate cicode functions to create a TIMESTAMP type.",
        "Duration": "The duration of the browse in seconds. The default is 86400 seconds(24 hour)",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned.",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column."
      },
      "helpPath": "SchdConfigOpen.html"
    },
    "schdconfigprev": {
      "name": "SchdConfigPrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdConfigPrev function places the data browse cursor at the previous record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdConfigPrev(LONG Session)",
        "Session": "The handle to a browse session previously returned by the SchdConfigOpen call"
      },
      "helpPath": "SchdConfigPrev.html"
    },
    "schdfirst": {
      "name": "SchdFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "Session": "INT SchdFirst(LONG Session)"
      },
      "helpPath": "SchdFirst.html"
    },
    "schdgetfield": {
      "name": "SchdGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING Field"
      ],
      "doc": "The SchdGetField function returns the value of the particular field in a record to which the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "(LONG Session, STRING Field": "STRING SchdGetField(LONG Session, STRING Field)",
        "Session": "The handle to a browse session previously returned by the SchdOpen call.",
        "Field": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. See SchdOpen for supported fields."
      },
      "helpPath": "SchdGetField.html"
    },
    "schdnext": {
      "name": "SchdNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdNext function places the data browse cursor at the next available record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "Session": "INT SchdNext(LONG Session)"
      },
      "helpPath": "SchdNext.html"
    },
    "schdnumrecords": {
      "name": "SchdNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdNumRecords function returns the number of records that matchthe current filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "Session": "LONG SchdNumRecords(LONG Session)"
      },
      "helpPath": "SchdNumRecords.html"
    },
    "schdopen": {
      "name": "SchdOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Equipment[",
        "TIMESTAMP Start] [",
        "LONG Duration] [",
        "STRING Filter] [",
        "STRING Fields] [",
        "STRING Clusters]"
      ],
      "doc": "The SchdOpen function initiates a new session for browsing the runtime schedules.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING Equipment": "LONG SchdOpen(STRING Equipment[, TIMESTAMP Start] [,LONG Duration] [,STRING Filter] [,STRING Fields] [, STRING Clusters] )",
        "Equipment": "The name of the equipment to browse.",
        "Start": "The start date of the schedules. If not specified, today at midnight will be taken as the start time. The types of this field is TIMESTAMP. Use StrToTimestamp or TimestampCreate Cicode functions to create a TIMESTAMP type.",
        "Duration": "The duration of the browse in seconds. The default is 86400 seconds(24 hour)",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned.",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed."
      },
      "helpPath": "SchdOpen.html"
    },
    "schdprev": {
      "name": "SchdPrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdPrev function places the data browse cursor at the previous record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "Session": "INT SchdPrev(LONG Session)"
      },
      "helpPath": "SchdPrev.html"
    },
    "schdspecialadd": {
      "name": "SchdSpecialAdd",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "STRING Name"
      ],
      "doc": "The SchdSpecialAdd adds a new Special Day Group to the scheduler engine.",
      "returns": "Returns the Id of the Special Day Group which can be used for modifying and deleting this Special Day Group. Returns the ID for an existing Special Day group. This function returns -1 if, unsuccessful. Trap the error to get the error returned by this function.",
      "paramDocs": {
        "STRING Cluster, STRING Name": "LONG SchdSpecialAdd(STRING Cluster, STRING Name)",
        "Cluster": "The name of the cluster",
        "Name": "Name of the special day group"
      },
      "helpPath": "SchdSpecialAdd.html"
    },
    "schdspecialclose": {
      "name": "SchdSpecialClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialClose function terminates a browsing session and cleans up the resources used by the session.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialClose(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialOpen"
      },
      "helpPath": "SchdSpecialClose.html"
    },
    "schdspecialdelete": {
      "name": "SchdSpecialDelete",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID"
      ],
      "doc": "The SchdSpecialDelete function deletes an existing special day group.",
      "returns": "Returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "STRING Cluster": "LONG SchdSpecialDelete(STRING Cluster, LONG ID)",
        "Cluster": "Name of the Cluster",
        "ID": "ID"
      },
      "helpPath": "SchdSpecialDelete.html"
    },
    "schdspecialfirst": {
      "name": "SchdSpecialFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialFirst(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialOpen"
      },
      "helpPath": "SchdSpecialFirst.html"
    },
    "schdspecialgetfield": {
      "name": "SchdSpecialGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING Field"
      ],
      "doc": "The SchdSpecialGetField function returns the value of a particular field from the record currently referenced by the data browse cursor.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG Session": "STRING SchdSpecialItemGetField(LONG Session, STRING Field)",
        "Session": "Session",
        "Field": "Field"
      },
      "helpPath": "SchdSpecialGetField.html"
    },
    "schdspecialitemadd": {
      "name": "SchdSpecialItemAdd",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG GroupID",
        "STRING Name",
        "TIMESTAMP Day"
      ],
      "doc": "The SchdSpecialItemAdd function adds a new Special Day to the scheduler engine.",
      "returns": "Returns the ID for an existing special day or -1 if unsuccessful. Trap the error to get the error returned by this function.",
      "paramDocs": {
        "Cluster": "LONG SchdSpecialItemAdd(STRING Cluster, LONG GroupID, STRING Name, TIMESTAMP Day)",
        "GroupID": "Special day group ID",
        "Name": "Name of special day",
        "Day": "The special day as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value."
      },
      "helpPath": "SchdSpecialItemAdd.html"
    },
    "schdspecialitemaddrange": {
      "name": "SchdSpecialItemAddRange",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "STRING GroupID",
        "TIMESTAMP FirstDay",
        "TIMESTAMP LastDay"
      ],
      "doc": "The SchdSpecialItemAddRange function adds a range of special days in the specified special day group (category).",
      "returns": "0 if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Cluster": "INT SchdSpecialItemAddRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay)",
        "GroupID": "The ID of the special day group.",
        "FirstDay": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
        "LastDay": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
      },
      "helpPath": "SchdSpecialItemAddRange.html"
    },
    "schdspecialitemclose": {
      "name": "SchdSpecialItemClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "This function terminates a browsing session and cleans up the resources used by the session.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialItemClose(LONG Session)",
        "Session": "Current schedule special item browsing session obtained by SchdSpecialItemOpen"
      },
      "helpPath": "SchdSpecialItemClose.html"
    },
    "schdspecialitemdelete": {
      "name": "SchdSpecialItemDelete",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID"
      ],
      "doc": "This function deletes an existing Special Day.",
      "returns": "This function returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "Cluster": "LONG SchdSpecialItemDelete(STRING Cluster, LONG ID)"
      },
      "helpPath": "SchdSpecialItemDelete.html"
    },
    "schdspecialitemdeleterange": {
      "name": "SchdSpecialItemDeleteRange",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "STRING GroupID",
        "TIMESTAMP FirstDay",
        "TIMESTAMP LastDay"
      ],
      "doc": "The SchdSpecialItemDeleteRange function removes a range of special days in a specified special day group (category).",
      "returns": "0 if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Cluster": "INT SchdSpecialItemDeleteRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay)",
        "GroupID": "The ID of the special day group.",
        "FirstDay": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
        "LastDay": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
      },
      "helpPath": "SchdSpecialItemDeleteRange.html"
    },
    "schdspecialitemfirst": {
      "name": "SchdSpecialItemFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialItemFirst places the data browse cursor at the first record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialItemFirst(LONG Session)",
        "Session": "Current schedule special item browsing session obtained by SchdSpecialItemOpen"
      },
      "helpPath": "SchdSpecialItemFirst.html"
    },
    "schdspecialitemgetfield": {
      "name": "SchdSpecialItemGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING Field"
      ],
      "doc": "This function returns the value of the particular field in a record to which the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "LONG Session": "STRING SchdSpecialItemGetField(LONG Session, STRING Field)",
        "Session": "Session",
        "Field": "Field"
      },
      "helpPath": "SchdSpecialItemGetField.html"
    },
    "schdspecialitemmodify": {
      "name": "SchdSpecialItemModify",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID",
        "STRING Name",
        "TIMESTAMP Day"
      ],
      "doc": "This function modifies an existing Special Day.",
      "returns": "This function returns 0 if successful otherwise it returns an error code.",
      "paramDocs": {
        "Cluster,": "LONG SchdSpecialItemModify(STRING Cluster, LONG ID, STRING Name, TIMESTAMP Day)",
        "Cluster": "The name of the cluster.",
        "ID": "ID",
        "Name": "Name",
        "Day": "The special day as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value."
      },
      "helpPath": "SchdSpecialItemModify.html"
    },
    "schdspecialitemmodifyrange": {
      "name": "SchdSpecialItemModifyRange",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "STRING GroupID",
        "TIMESTAMP FirstDay",
        "TIMESTAMP LastDay",
        "STRING NewName",
        "TIMESTAMP NewFirstDay",
        "TIMESTAMP NewLastDay"
      ],
      "doc": "The SchdSpecialItemModifyRange function can be used to modify a range of special days in a specified special day group (category).",
      "returns": "0 if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Cluster": "INT SchdSpecialItemAddRange(STRING Cluster, STRING GroupID, TIMESTAMP FirstDay, TIMESTAMP LastDay, STRING NewName, TIMESTAMP NewFirstDay, TIMESTAMP NewLastDay)",
        "GroupID": "The ID of the special day group.",
        "FirstDay": "The first day of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
        "LastDay": "Last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
        "NewName": "A new name for the special days.",
        "NewFirstDay": "A new first day for the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day.",
        "NewLastDay": "A new last day (inclusive) of the special day range as a timestamp. Use TimestampCreate or StrToTimestamp Cicode functions to get a timestamp data value. When creating a timestamp, please use midnight of the required day."
      },
      "helpPath": "SchdSpecialItemModifyRange.html"
    },
    "schdspecialitemnext": {
      "name": "SchdSpecialItemNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "This function places the data browse cursor at the next available record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialItemNext(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialItemOpen"
      },
      "helpPath": "SchdSpecialItemNext.html"
    },
    "schdspecialitemnumrecords": {
      "name": "SchdSpecialItemNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialItemNumRecords function returns the number of records that match the current filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "LONG Session": "LONG SchdSpecialItemNumRecords(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialItemOpen"
      },
      "helpPath": "SchdSpecialItemNumRecords.html"
    },
    "schdspecialitemopen": {
      "name": "SchdSpecialItemOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters]"
      ],
      "doc": "This function initiates a new session for browsing the special days.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING Filter, STRING Fields [, STRING Clusters]": "LONG SchdSpecialItemOpen(STRING Filter, STRING Fields [, STRING Clusters])",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that all records will be returned.",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed."
      },
      "helpPath": "SchdSpecialItemOpen.html"
    },
    "schdspecialitemprev": {
      "name": "SchdSpecialItemPrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "This function places the data browse cursor at the previous record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialItemPrev(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialItemOpen"
      },
      "helpPath": "SchdSpecialItemPrev.html"
    },
    "schdspecialmodify": {
      "name": "SchdSpecialModify",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID",
        "STRING NewName"
      ],
      "doc": "This function modifies an existing special day group.",
      "returns": "This function returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "STRING Cluster": "LONG SchdSpecialModify(STRING Cluster, LONG ID, STRING NewName)",
        "Cluster": "The name of the cluster",
        "NewName": "New name of the current special day group."
      },
      "helpPath": "SchdSpecialModify.html"
    },
    "schdspecialnext": {
      "name": "SchdSpecialNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "This function places the data browse cursor at the next available record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialNext(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialOpen"
      },
      "helpPath": "SchdSpecialNext.html"
    },
    "schdspecialnumrecords": {
      "name": "SchdSpecialNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialNumRecords function returns the number of records that match the current filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "LONG Session": "LONG SchdSpecialNumRecords(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialOpen"
      },
      "helpPath": "SchdSpecialNumRecords.html"
    },
    "schdspecialopen": {
      "name": "SchdSpecialOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields[",
        "STRING Clusters]"
      ],
      "doc": "The SchdSpecialOpen function initiates a new session for browsing the special day groups.",
      "returns": "Returns an integer handle to the browse session. Returns -1 when an error is detected.",
      "paramDocs": {
        "STRING Filter": "LONG SchdSpecialOpen(STRING Filter, STRING Fields[, STRING Clusters])",
        "Filter": "A filter expression specifying the records to return during the browse. An empty string indicates that every record will be returned. Multiple filters can be specified and separated with ';'. Where a fieldname is not specified in the filter, it is assumed to be tagname. For example, the filter \"AAA\" is equivalent to \"name=AAA\".",
        "Fields": "Specifies via a comma delimited string the columns to be returned during the browse. An empty string indicates that the server will return every available column. Supported fields are:",
        "Clusters": "An optional parameter that specifies via a comma delimited string the subset of the clusters to browse. An empty string indicates that the connected clusters will be browsed."
      },
      "helpPath": "SchdSpecialOpen.html"
    },
    "schdspecialprev": {
      "name": "SchdSpecialPrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The SchdSpecialPrev places the data browse cursor at the previous record.",
      "returns": "0 (zero) if the browsing session exists, otherwise an error code is returned.",
      "paramDocs": {
        "LONG Session": "INT SchdSpecialPrev(LONG Session)",
        "Session": "Current special day group browsing session obtained by SchdSpecialOpen"
      },
      "helpPath": "SchdSpecialPrev.html"
    },
    "scheduleitemadd": {
      "name": "ScheduleItemAdd",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "STRING Equipment",
        "STRING State",
        "TIMESTAMP Start",
        "TIMESTAMP End",
        "STRING Desc"
      ],
      "doc": "The ScheduleItemAdd function adds a new schedule to the scheduler engine.",
      "returns": "The id of the schedule which can be used for modifying, setting recurrence and deleting this schedule. This function returns -1 if unsuccessful. Trap the error to get the error returned by this function.",
      "paramDocs": {
        "Cluster, STRING Equipment, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc": "LONG ScheduleItemAdd(STRING Cluster, STRING Equipment, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc)",
        "Cluster": "The name of the cluster",
        "Equipment": "The name of the equipment to browse.",
        "State": "The state of the schedule",
        "Start": "The start time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
        "End": "The end time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
        "Desc": "Desc"
      },
      "helpPath": "ScheduleItemAdd.html"
    },
    "scheduleitemdelete": {
      "name": "ScheduleItemDelete",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "The ScheduleItemDelete function deletes an existing schedule.",
      "returns": "Returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "STRING Cluster, LONG ID": "LONG ScheduleItemDelete(STRING Cluster, LONG ID)",
        "Cluster": "Name of cluster.",
        "ID": "The unique ID of the schedule within the schedule engine."
      },
      "helpPath": "ScheduleItemDelete.html"
    },
    "scheduleitemmodify": {
      "name": "ScheduleItemModify",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID",
        "STRING State",
        "TIMESTAMP Start",
        "TIMESTAMP End",
        "STRING Desc"
      ],
      "doc": "The ScheduleItemModify function modifies an existing schedule.",
      "returns": "Returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "(STRING Cluster, LONG ID, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc)": "LONG ScheduleItemModify(STRING Cluster, LONG ID, STRING State, TIMESTAMP Start, TIMESTAMP End, STRING Desc)",
        "Cluster": "Name of cluster.",
        "ID": "The unique ID of the schedule within the schedule engine",
        "State": "The state of the schedule",
        "Start": "The start time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
        "End": "The end time of the schedule. The type of this parameter is TIMESTAMP. Use TimestampCreate or StrToTimestamp to get a TIMESTAMP value.",
        "Desc": "Desc"
      },
      "helpPath": "ScheduleItemModify.html"
    },
    "scheduleitemsetrepeat": {
      "name": "ScheduleItemSetRepeat",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Cluster",
        "LONG ID",
        "LONG Freq",
        "LONG Interval",
        "LONG Weekday",
        "LONG WeekDayMask",
        "LONG MaxRec",
        "LONG RecUntil",
        "LONG DayOrd",
        "LONG Day",
        "LONG Month",
        "LONG SpecialInc",
        "STRING GroupIds"
      ],
      "doc": "The ScheduleItemSetRepeat function adds recurrence information to an existing schedule to the scheduler engine.",
      "returns": "Returns 0 if successful otherwise it returns an error.",
      "paramDocs": {
        "STRING Cluster, LONG ID, LONG Freq, LONG Interval, LONG Weekday, LONG WeekDayMask, LONG MaxRec, LONG RecUntil,LONG DayOrd, LONG Day, LONG Month,LONG SpecialInc, STRING GroupIds)": "LONG ScheduleItemSetRepeat(STRING Cluster, LONG ID, LONG Freq, LONG Interval, LONG Weekday, LONG WeekDayMask, LONG MaxRec, LONG RecUntil,LONG DayOrd, LONG Day, LONG Month,LONG SpecialInc, STRING GroupIds)",
        "Cluster": "Cluster"
      },
      "helpPath": "ScheduleItemSetRepeat.html"
    },
    "semclose": {
      "name": "SemClose",
      "returnType": "UNKNOWN",
      "params": [
        "hSem"
      ],
      "doc": "Closes a semaphore opened with SemOpen().",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hSem": "SemClose(hSem)"
      },
      "helpPath": "SemClose.html"
    },
    "semopen": {
      "name": "SemOpen",
      "returnType": "UNKNOWN",
      "params": [
        "Name",
        "Mode"
      ],
      "doc": "Opens a semaphore for access control.",
      "returns": "The semaphore handle, or -1 if the semaphore was not opened successfully. The semaphore handle identifies the table where all data on the associated semaphore is stored.",
      "paramDocs": {
        "0": "Open existing semaphore.",
        "1": "Create new semaphore.",
        "2": "Attempts to open an existing semaphore. If the semaphore does not exist, it will create it.",
        "Name, Mode": "SemOpen(Name, Mode)",
        "sName": "The name of the semaphore. Follow the naming convention outlined in the topic Tag Name Syntax in the main help.",
        "Mode": "The mode of the open:"
      },
      "helpPath": "SemOpen.html"
    },
    "semsignal": {
      "name": "SemSignal",
      "returnType": "UNKNOWN",
      "params": [
        "hSem"
      ],
      "doc": "Signals a semaphore. If several Cicode tasks are waiting on this semaphore, the first task is released.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hSem": "SemSignal(hSem)"
      },
      "helpPath": "SemSignal.html"
    },
    "semwait": {
      "name": "SemWait",
      "returnType": "UNKNOWN",
      "params": [
        "hSem",
        "Timeout"
      ],
      "doc": "Waits on a semaphore to be signalled.",
      "returns": "0 (zero) if the semaphore has been gained, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Do not wait - return immediately. (This timeout can be used to check the state.)",
        "hSem": "SemWait(hSem, Timeout)",
        "Timeout": "Semaphore time-out time:",
        "-1": "Wait until semaphore is clear (regardless of how long).",
        "> 0": "The number of seconds to wait if semaphore is not signalling, then return."
      },
      "helpPath": "SemWait.html"
    },
    "sendkeys": {
      "name": "SendKeys",
      "returnType": "UNKNOWN",
      "params": [
        "sTitle",
        "sKeys"
      ],
      "doc": "Sends a keystroke (or string of keystrokes) to a window as if they were typed on the keyboard.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTitle, sKeys": "SendKeys(sTitle, sKeys)",
        "sTitle": "The title (caption) of the destination window.",
        "sKeys": "The key (or keys) to send to sTitle."
      },
      "helpPath": "SendKeys.html"
    },
    "serialkey": {
      "name": "SerialKey",
      "returnType": "UNKNOWN",
      "params": [
        "sPort"
      ],
      "doc": "Redirects all serial characters from a port to the keyboard.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPort": "SerialKey(sPort)"
      },
      "helpPath": "SerialKey.html"
    },
    "serverbrowseclose": {
      "name": "ServerBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The ServerBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
      "returns": "0 (zero) if the server browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "ServerBrowseClose(iSession)"
      },
      "helpPath": "ServerBrowseClose.html"
    },
    "serverbrowsefirst": {
      "name": "ServerBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The ServerBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the server browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "ServerBrowseFirst(iSession)"
      },
      "helpPath": "ServerBrowseFirst.html"
    },
    "serverbrowsegetfield": {
      "name": "ServerBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "iSession",
        "sFieldName"
      ],
      "doc": "The ServerBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "iSession": "ServerBrowseGetField(iSession, sFieldName)"
      },
      "helpPath": "ServerBrowseGetField.html"
    },
    "serverbrowsenext": {
      "name": "ServerBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The ServerBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the server browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "ServerBrowseNext(iSession)"
      },
      "helpPath": "ServerBrowseNext.html"
    },
    "serverbrowsenumrecords": {
      "name": "ServerBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The ServerBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that matched the filter criteria. A value of 0 denotes that no records matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This could be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "iSession": "ServerBrowseNumRecords(iSession)"
      },
      "helpPath": "ServerBrowseNumRecords.html"
    },
    "serverbrowseopen": {
      "name": "ServerBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields",
        "STRING Clusters"
      ],
      "doc": "The ServerBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "An integer handle to the browse session. Returns -1 on error.",
      "paramDocs": {
        "Filter": "ServerBrowseOpen(STRING Filter , STRING Fields , STRING Clusters)"
      },
      "helpPath": "ServerBrowseOpen.html"
    },
    "serverbrowseprev": {
      "name": "ServerBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The ServerBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the server browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "ServerBrowsePrev(iSession)"
      },
      "helpPath": "ServerBrowsePrev.html"
    },
    "serverdumpkernel": {
      "name": "ServerDumpKernel",
      "returnType": "UNKNOWN",
      "params": [
        "iMode",
        "sName",
        "sServer [",
        "sCluster]"
      ],
      "doc": "Dumps Kernel data to the KERNEL.DAT file (written to the Logs folder) either on a local server or on a remote server.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "iMode, sName, sServer [, sCluster]": "ServerDumpKernel(iMode, sName, sServer [, sCluster])",
        "iMode": "The Kernel data to dump:",
        "sName": "The queue or table name (empty for all queues or tables). Only valid if iMode is 0x0020 and 0x0040.",
        "sServer": "Specifies the name of the server, as defined in the project, on which kernel data will be dumped.",
        "sCluster": "Specifies the cluster of the server on which kernel data will be dumped. This parameter is optional in a single cluster environment."
      },
      "helpPath": "ServerDumpKernel.html"
    },
    "servergetproperty": {
      "name": "ServerGetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Server",
        "STRING Property [",
        "STRINGCluster]"
      ],
      "doc": "This function returns information about a specified server and can be called from any client.",
      "returns": "The value of the server property requested.",
      "paramDocs": {
        "(STRING Server, STRING Property [, STRINGCluster]).": "STRING ServerGetProperty(STRING Server, STRING Property [, STRINGCluster]).",
        "\"LastReloadError\"": "Error Code from the latest reload",
        "\"LibRDBMemTime\"": "Date and time of currently loaded cicode library (_library.RDB)",
        "\"LibRDBDiskTime\"": "Date and time of cicode library on disk (_library.RDB)",
        "\"RDBDiskTime\"": "Returns the date and time of RDB on disk (compiled)",
        "\"RDBMemTime\"": "Returns the date and time of currently loaded RDB (in-memory)",
        "\"ReloadStatus\"": "Returns 1 if the server is reloading, 0 if not",
        "\"ReloadProgress\"": "Reload Progress (in percent) Range: 0  100",
        "\"ServerStartState\"": "Returns the start up state of the server. Returns 0 if the server is starting, 1 if it is running.",
        "\"SyncStatus\"": "Returns the startup synchronization status:",
        "\"SyncProgress\"": "The percentage of the server synchronization progress: Range: 0-100"
      },
      "helpPath": "ServerGetProperty.html"
    },
    "serverinfo": {
      "name": "ServerInfo",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "INT Type [",
        "STRING ClusterName]"
      ],
      "doc": "Gets status information on clients and servers.",
      "returns": "Status information specified by nnType.",
      "paramDocs": {
        "0": "Active flag (returns 1 if this is the active server, 0 if an inactive server).",
        "1": "Number of clients attached to this server.",
        "2": "If this client is attached to the primary or standby server for the specified server name. If Name is \"Alarm\" and if this client is attached to the primary alarm server, the return value is 0. If this client is attached to the standby, the return value is 1.",
        "3": "The status of the client connection to the specified server name. If Name is \"Report\" and the client is talking to a report server (either primary or standby), the return value is 1. If not, the return value is 0.",
        "4": "Alarm DB Status for the alarm server. Returns 1 if initializing, 2 if main, 3 if standby and 4 if invalid.",
        "5": "The number of messages sent to this client.",
        "6": "If this client has a licence (1) from this server or not (0).",
        "7": "The type of the licence; full licence (0), View-only Client (1), or Control Client (2).",
        "8": "If the client is remote (1) or local (0).",
        "Name": "STRING ServerInfo(STRING Name, INT Type [, STRING ClusterName] )",
        "Type": "The type of information required (depends on the Name you specify):",
        "ClusterName": "The name of the cluster that the server belongs to. This is only relevant if:",
        "n": "Status information specified by nnType."
      },
      "helpPath": "ServerInfo.html"
    },
    "serverinfoex": {
      "name": "ServerInfoEx",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "INT Type",
        "STRING Component [",
        "STRING ClusterName] [",
        "STRING ServerName]"
      ],
      "doc": "Gets status information on clients and servers from a specified component in a multiprocess runtime environment.",
      "returns": "Status information specified by nType.",
      "paramDocs": {
        "0": "Active flag (returns 1 if this is the active server, 0 if an inactive server).",
        "1": "Number of clients attached to this server.",
        "2": "If this client is attached to the primary or standby server for the specified server name. If Name is \"Alarm\" and if this client is attached to the primary alarm server, the return value is 0. If this client is attached to the standby, the return value is 1.",
        "3": "The status of the client connection to the specified server name. If Name is \"Report\" and the client is talking to a report server (either primary or standby), the return value is 1. If not, the return value is 0.",
        "4": "Alarm DB Status for the alarm server. Returns 1 if initializing, 2 if main, 3 if standby and 4 if invalid.",
        "5": "The number of messages sent to this client.",
        "6": "If this client has a licence (1) from this server or not (0).",
        "7": "The type of the licence; full licence (0), View-only Client (1), or Control Client (2).",
        "8": "If the client is remote (1) or local (0).",
        "sComponent": "When this function is called, the system redirects the call to the process that contains the specified component. If the specified component is in the calling process, the call is not redirected. If the specified component is not one of the servers listed in the sComponent argument description (see below), of if the system cannot find the component from the connected local processes, a hardware alarm is raised.",
        "Name": "STRING ServerInfoEx(STRING Name, INT Type, STRING Component [, STRING ClusterName] [, STRING ServerName] )",
        "Type": "The type of information required (depends on the Name you specify):",
        "Component": "Specifies the component name from which to retrieve the status information:",
        "\" \"": "An empty string causes the function to run on the calling process.",
        "Alarm": "\"Alarm\" - Redirects the function to the alarm server process.",
        "Trend": "\"Trend\" - Redirects the function to the trend server process.",
        "Report": "\"Report\" - Redirects the function to the report server process.",
        "IOServer": "\"IOServer\" - Redirects the function to the I/O server process.",
        "ClusterName": "The name of the cluster that the server belongs to. This is only relevant if:",
        "nType": "Status information specified by nType."
      },
      "helpPath": "ServerInfoEx.html"
    },
    "serverisonline": {
      "name": "ServerIsOnline",
      "returnType": "UNKNOWN",
      "params": [
        "STRING ServerName[",
        "STRING Clusters][",
        "INT bLocal]"
      ],
      "doc": "The ServerIsOnline function checks if the given server can be contacted by the client for giving the online/offline status of the server.",
      "returns": "An integer value of online/offline status. Returns 1 for online, 0 for offline.",
      "paramDocs": {
        "STRING": "INT ServerIsOnline(STRING ServerName[, STRING Clusters][, INT bLocal])"
      },
      "helpPath": "ServerIsOnline.html"
    },
    "serverreload": {
      "name": "ServerReload",
      "returnType": "UNKNOWN",
      "params": [
        "STIRNG Server [",
        "STRING Cluster] [",
        "INT Sync]"
      ],
      "doc": "This function can only be called for Alarm, Report and Trend Servers and reloads the server specified by cluster and server name.",
      "returns": "0 (zero) if the function was successful. Returns an error if unsuccessful.Outline of errors:",
      "paramDocs": {
        "LibRDBMemTime": "It is recommended that the ServerGetProperty cicode function be used with the LibRDBMemTime and LibRDBDiskTime properties to check if there is a change to the Cicode library before attempting a reload. Following a reload please check the corresponding server's syslog.dat file for any reload messages. The cicode changes will not be reloaded, therefore a restart may be more appropriate.",
        "STIRNG Server": "INT ServerReload(STIRNG Server [, STRING Cluster] [, INT Sync] )"
      },
      "helpPath": "ServerReload.html"
    },
    "serverrestart": {
      "name": "ServerRestart",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sServerName",
        "STRING sCluster = \"\""
      ],
      "doc": "Allows you to restart any specific alarm, report, trend or I/O server from any Cicode node in a system, without affecting other server processes running on the same machine.",
      "returns": "0 (zero) if successful, otherwise one of the following error codes is returned:",
      "paramDocs": {
        "sServerName": "INT error = ServerRestart (STRING sServerName, STRING sCluster = \"\")"
      },
      "helpPath": "ServerRestart.html"
    },
    "serverrpc": {
      "name": "ServerRPC",
      "returnType": "UNKNOWN",
      "params": [
        "sServerName",
        "sName",
        "sArg",
        "iMode [",
        "sClusterName]"
      ],
      "doc": "Calls a remote procedure on the Plant SCADA server specified by the ServerName argument.",
      "returns": "The result of the remote function call (as a string). If the function is called in asynchronous mode the result of the remote function cannot be returned, so an empty string is returned. If the function cannot work due to an error, empty string is also returned and the error can be obtained by calling the IsError function. If current user has view-only access on client side, the function will return an error code.",
      "paramDocs": {
        "0": "Blocking mode - synchronous",
        "1": "Non-blocking mode - asynchronous",
        "ServerName": "Calls a remote procedure on the Plant SCADA server specified by the ServerName argument. You can call any of the built-in Cicode functions remotely, or your own functions. You pass the Name of the function as a string and pass the arguments for that function in Arg.",
        "iMode": "This means this function is a blocking function if iMode is set to zero (0). A logged on user is required for this function to be successful.",
        "(sServerName, sName, sArg, iMode [, sClusterName])": "ServerRPC(sServerName, sName, sArg, iMode [, sClusterName])",
        "sServerName": "Plant SCADA server name where the Cicode function needs to be executed. You can optionally specify this name in <ClusterName>.<ServerName> syntax.",
        "sName": "The name of the Cicode function to call remotely as string.",
        "sArg": "The arguments to pass to the function, separated by commas (,).Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If you forget to enclose the string in quotes, then the string is only the first tag found.",
        "sClusterName": "The name of the cluster that the server resides in. This argument is optional, as in several situations it may not be required. In single cluster systems, it is not required, or if the current Cicode task already has the correct cluster context for the server you may omit this argument."
      },
      "helpPath": "ServerRPC.html"
    },
    "servicegetlist": {
      "name": "ServiceGetList",
      "returnType": "STRING",
      "params": [],
      "doc": "Determines the service type(s), cluster name(s), and service name(s) of all services currently running in the component that called this function.",
      "returns": "String in the form:",
      "paramDocs": {
        "serviceType1.clusterName1.serviceName1": "serviceType1.clusterName1.serviceName1,serviceType2.clusterName2.serviceName2, ... ,Client"
      },
      "helpPath": "ServiceGetList.html"
    },
    "setarea": {
      "name": "SetArea",
      "returnType": "UNKNOWN",
      "params": [
        "Area"
      ],
      "doc": "Sets the current viewable areas. You can pass a single area number, or a group of areas to set multiple areas.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Area": "SetArea(Area)"
      },
      "helpPath": "SetArea.html"
    },
    "setevent": {
      "name": "SetEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nType",
        "hFn"
      ],
      "doc": "Sets an event callback function by specifying a function handle.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The mouse has moved. When the mouse moves the callback function is called. The return value must be 0.",
        "1": "A key has been pressed. When the user presses a key, the callback function is called after Plant SCADA checks for hot keys. If the return value is 0, Plant SCADA checks for key sequences. If the return value is not 0, Plant SCADA assumes that you will process the key and does not check the key sequence. It is up to you to remove the key from the key command line.",
        "2": "Error event. This event is called if an error is detected in Cicode, so you can write a single error function to check for your errors. If the return value is 0, Plant SCADA continues to process the error and generates a hardware error - it may then halt the Cicode task. If the return value is not 0, Plant SCADA assumes that you will process the error, and continues the Cicode without generating a hardware error.",
        "3": "Page user communication error. A communication error has been detected in the data required for this page. If the return value is 0 (zero), Plant SCADA still animates the page. If the return value is not zero, it does not update the page.",
        "4": "Page user open. A new page is being opened. This event allows you to define a single function that is called when all pages are opened. The return value must be 0.",
        "5": "Page user close. The current page is being closed. This event allows you to define a single function that is called when all pages are closed. The return value must be 0.",
        "6": "Page user always. The page is active. This event allows you to define a single function that is called when all pages are active. The return value must be 0.",
        "7": "Page communication error. A communication error has been detected in the data required for this page. Reserved for use by Plant SCADA.",
        "8": "Page open. This event is called each time a page is opened. Reserved for use by Plant SCADA.",
        "9": "Page close. This event is called each time a page is closed. Reserved for use by Plant SCADA.",
        "10": "Page always. This event is called while a page is active. Reserved for use by Plant SCADA.",
        "18": "Report start. The report server is about to start a new report. This event is called on the report server. The return value must be 0.",
        "19": "Device history. A device history has just completed. The return value must be 0.",
        "20": "Login. A user has just logged in.",
        "21": "Logout. A user has just logged out.",
        "22": "Trend needs repainting. This event is called each time Plant SCADA re-animates a real-time trend or scrolls an historical trend. You should use this event to add additional animation to a trend, because Plant SCADA deletes all existing animation when a trend is re-drawn. (For example, if you want to display extra markers, you must use this event.)",
        "23": "Hardware error has been detected.",
        "24": "Keyboard cursor moved. This event is called each time the keyboard command cursor moves. The cursor can be moved by the cursor keys, the mouse, or the Cicode function KeySetCursor(). Note that you can find where the keyboard command cursor is located by calling the function KeyGetCursor().",
        "25": "Network shutdown. A Shutdown network command has been issued.",
        "26": "Runtime system shutdown and restart. (Required because of configuration changes.)",
        "27": "Event. An event has occurred.",
        "28": "Accumulator. An accumulator has logged a value.",
        "29": "Slider. A slider has been selected.",
        "30": "Slider. A slider has moved.",
        "31": "Slider. A slider has been released (that is stopped moving).",
        "32": "Shutdown. Plant SCADA is being shutdown.",
        "33": "Reserved for Plant SCADA internal use.",
        "34": "Plant SCADA Event: Child Window Close Confirmation.",
        "35": "Plant SCADA Event: Main Window Close Confirmation.",
        "36": "Plant SCADA Event: Maximize Window Confirmation.",
        "37": "Plant SCADA Event: Minimize Window Confirmation.",
        "38": "Plant SCADA Event: Restore Window Confirmation.",
        "39": "Plant SCADA Event: Move Window Confirmation.",
        "40": "Plant SCADA Event: Size Window Confirmation.",
        "41": "Plant SCADA Event: Shutdown Confirmation Confirmation.",
        "42": "Child Window Close Confirmation, when the close button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "43": "Main Window Close Confirmation, when close button of the windows' title bar is clicked which will cause the process to shutdown.",
        "44": "Maximize Window Confirmation, when the maximize button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "45": "Minimize Window Confirmation, when the minimize button of the windows' title bar is licked or an equivalent Windows' message is received.",
        "46": "Restore Window Confirmation, when the restore button of the windows' title bar is clicked or an equivalent Windows' message is received.",
        "47": "Move Window Confirmation, when the window is being dragged or an equivalent Windows' message is received.",
        "48": "Size Window Confirmation, when the windows is being resized or an equivalent Windows' message is received.",
        "49": "Shutdown Confirmation, when shutdown() function is called.",
        "nType, hFn": "SetEvent(nType, hFn)",
        "Type": "The type of event:",
        "11..17": "Undefined.",
        "34 - 41": "Plant SCADA Confirmation Events. Reserved for Plant SCADA internal use. For the confirmation events, two sets of event type code are defined. The runtime calls the Plant SCADA event handler first, and conditionally proceed to the user's event handler depending on the return value of the Plant SCADA event handler.",
        "42 to 49": "User Confirmation Events. These functions are called when a specific event (mainly from Window title bar) occur and before the runtime performs the intended action. This gives a chance for the user to decide what to do with the event. If the return value is 0, the event will be passed on to the default handler so the intended action will be performed. If the return value is not 0, the event will be ignored and no further action will be taken.",
        "50 - 127": "Reserved for future Plant SCADA use.",
        "128 - 256": "User-defined events. These events are for your own use.",
        "hFn": "hFn"
      },
      "helpPath": "SetEvent.html"
    },
    "setlogging": {
      "name": "SetLogging",
      "returnType": "UNKNOWN",
      "params": [
        "Section",
        "Name",
        "Value",
        "Persist"
      ],
      "doc": "Adjusts logging parameters while online.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Section, Name, Value, Persist": "SetLogging(Section, Name, Value, Persist)",
        "Section": "The INI section name.",
        "sName": "The system parameter name.",
        "Value": "The value you would like to set the parameter to.",
        "Persist": "Makes the value persistent across restarts by writing the value to the INI file."
      },
      "helpPath": "SetLogging.html"
    },
    "shutdown": {
      "name": "Shutdown",
      "returnType": "UNKNOWN",
      "params": [
        "[sDest] [",
        "sProject] [",
        "Mode] [",
        "sClusterName] [",
        "CallEvent]"
      ],
      "doc": "Terminates Plant SCADA's operation.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "Shutdown Plant SCADA only - Default value.",
        "2": "Shutdown and restart Plant SCADA (without logging off Windows).",
        "3": "Shutdown and restart Plant SCADA and log off Windows (an auto login to the Operating System and Plant SCADA needs to be configured to run on start up or log in).",
        "4": "Shutdown Plant SCADA and re-boot the computer.",
        "5": "Shutdown Plant SCADA only.",
        "6": "Shutdown and restart Plant SCADA on remote computers, but not this computer.",
        "7": "Shutdown Plant SCADA and shutdown the computer. If the computer supports power off feature the power will be turned off.",
        "sDest": "The shutdown can affect only the computer that calls it, or all or part of a Plant SCADA network. If you are shutting down a network, specify the computers (Control Clients and servers) to be shut down in sDest, and the extent of the shutdown in Mode.",
        "[sDest] [, sProject] [, Mode] [, sClusterName] [, CallEvent]": "Shutdown( [sDest] [, sProject] [, Mode] [, sClusterName] [, CallEvent])",
        "sProject": "The full path of the project to run on restart as a string. The path is written to the configuration files and is used when the system restarts. The default value is \"\", which means that no changes are made to the configuration and the current project is restarted.",
        "Mode": "The type of shutdown:",
        "sClusterName": "The name of the cluster to which the machine(s) named in Dest belong. This is not required if:",
        "CallEvent": "Flag for initiating a user-specified shutdown event prior to shutting down. Refer to OnEvent() type code for the value of shutdown event."
      },
      "helpPath": "Shutdown.html"
    },
    "shutdownform": {
      "name": "ShutdownForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a dialog box to verify that the user really wants to shut down the Plant SCADA system.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "ShutdownForm.html"
    },
    "shutdownmode": {
      "name": "ShutdownMode",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the mode of the last Shutdown function call.",
      "returns": "The shutdown mode set when shutdown was called.",
      "paramDocs": {},
      "helpPath": "ShutdownMode.html"
    },
    "sign": {
      "name": "Sign",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Gets the sign of a number.",
      "returns": "The sign of Number.",
      "paramDocs": {
        "Number": "Sign(Number)"
      },
      "helpPath": "Sign.html"
    },
    "sin": {
      "name": "Sin",
      "returnType": "UNKNOWN",
      "params": [
        "Angle"
      ],
      "doc": "Calculates the trigonometric sine of an angle.",
      "returns": "The sine of Angle.",
      "paramDocs": {
        "Angle": "Sin(Angle)"
      },
      "helpPath": "Sin.html"
    },
    "sleep": {
      "name": "Sleep",
      "returnType": "UNKNOWN",
      "params": [
        "Seconds"
      ],
      "doc": "Suspends the current Cicode task for a specified number of seconds.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Seconds": "Sleep(Seconds)"
      },
      "helpPath": "Sleep.html"
    },
    "sleepms": {
      "name": "SleepMS",
      "returnType": "UNKNOWN",
      "params": [
        "Milliseconds"
      ],
      "doc": "Suspends the current Cicode task for a specified number of milliseconds.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Milliseconds": "SleepMS(Milliseconds)"
      },
      "helpPath": "SleepMS.html"
    },
    "soearchive": {
      "name": "SOEArchive",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Path[",
        "STRING ClusterName]"
      ],
      "doc": "Use this function to archive event journals.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT SOEArchive(STRING Path[, STRING ClusterName])",
        "Path": "(optional)",
        "sClusterName": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters."
      },
      "helpPath": "SOEArchive.html"
    },
    "soedismount": {
      "name": "SOEDismount",
      "returnType": "UNKNOWN",
      "params": [
        "[",
        "STRING ClusterName]"
      ],
      "doc": "Use this function to dismount archive volume.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT SOEDisMount([, STRING ClusterName])",
        "sClusterName": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters."
      },
      "helpPath": "SOEDismount.html"
    },
    "soeeventadd": {
      "name": "SOEEventAdd",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP TimeStamp",
        "STRING Message[",
        "STRING Tag",
        "STRING Cluster]"
      ],
      "doc": "Use this function to insert an event into the Event Journal.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT SOEEventAdd(TIMESTAMP TimeStamp, STRING Message[,STRING Tag, STRING Cluster])",
        "TimeStamp": "The time of the inserted event.",
        "Message": "The message for the event.",
        "Tag": "Alarm tag associated with the event. This can be Cluster.Tag or Tag if running on a single cluster system. If not specified the event is classed as a User event.",
        "Cluster": "Specify if running on a multi-cluster system and Tag has been specified. If Tag has not been specified and the Cluster is blank, the User event will be broadcast to all of the clusters to which the client is currently connected."
      },
      "helpPath": "SOEEventAdd.html"
    },
    "soemount": {
      "name": "SOEMount",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sPath [",
        "STRING ClusterName]"
      ],
      "doc": "Use this function to mount an archive volume.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT": "INT SOEMount(STRING sPath [, STRING ClusterName])",
        "sClusterName": "Optional cluster on which to perform mounting operation. If not specified, the operation will be performed on all clusters."
      },
      "helpPath": "SOEMount.html"
    },
    "spcalarms": {
      "name": "SPCAlarms",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "AlarmType"
      ],
      "doc": "Returns the status of the specified SPC alarm.",
      "returns": "Alarm status, ON (1) or OFF (0).",
      "paramDocs": {
        "sSPCTag, AlarmType": "SPCAlarms(sSPCTag, AlarmType)",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "AlarmType": "The description of the alarm type. The following types are valid:"
      },
      "helpPath": "SPCAlarms.html"
    },
    "spcclientinfo": {
      "name": "SPCClientInfo",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "iType"
      ],
      "doc": "Returns SPC data for the given SPC tag.",
      "returns": "The requested data specified by iType. It is of type REAL.",
      "paramDocs": {
        "1": "Subgroup Size",
        "2": "No. of Subgroups",
        "3": "Process Mean (x double bar)",
        "4": "Process Range",
        "5": "Process Standard Deviation",
        "6": "Lower Specification Limit (LSL)",
        "7": "Upper Specification Limit (USL)",
        "8": "Cp - Process Capability Actual",
        "9": "Cpk - Process Capability Potential",
        "10": "Process Skewness",
        "11": "Process kurtosis",
        "sSPCTag, iType": "SPCClientInfo(sSPCTag, iType)",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "iType": "The information to be returned:"
      },
      "helpPath": "SPCClientInfo.html"
    },
    "spcgethistogramtable": {
      "name": "SPCGetHistogramTable",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "iNoBars",
        "TableVariable"
      ],
      "doc": "Returns an array containing the frequencies of particular ranges for the given SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. The histogram table is written to TableVariable.",
      "paramDocs": {
        "sSPCTag, iNoBars, TableVariable": "SPCGetHistogramTable(sSPCTag, iNoBars, TableVariable)",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "iNoBars": "The number of bars in the table. The valid range is restricted to values from 7 to 100. This also indicates the size of the array to be returned.",
        "TableVariable": "The Cicode array that will store the histogram data. The number of elements in the array needs to be equal to (or greater than) iNoBars. Must be a Real type global array variable."
      },
      "helpPath": "SPCGetHistogramTable.html"
    },
    "spcgetsubgrouptable": {
      "name": "SPCGetSubgroupTable",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "iSubgroup",
        "TableVariable"
      ],
      "doc": "Returns an array containing the specified subgroup's elements with the mean, range and standard deviation.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. The subgroup's data is written to TableVariable.",
      "paramDocs": {
        "sSPCTag, iSubgroup, TableVariable": "SPCGetSubgroupTable(sSPCTag, iSubgroup, TableVariable)",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "iSubgroup": "The number of the subgroup being displayed whose data is to be retrieved. Zero ('0') represents the latest subgroup.",
        "TableVariable": "The first element of the Cicode array that will store the sample data. . The number of elements in the array needs to be equal to (or greater than) the subgroup size + 3. Must be a Real type global array variable."
      },
      "helpPath": "SPCGetSubgroupTable.html"
    },
    "spcplot": {
      "name": "SPCPlot",
      "returnType": "UNKNOWN",
      "params": [
        "sPort",
        "nAN [",
        "sTitle] [",
        "sComment] [",
        "nMode]"
      ],
      "doc": "This function is designed to work only on an SPCXRSChart page.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Black and White (default)",
        "1": "Color",
        "nAN": "This function is designed to work only on an SPCXRSChart page. It prints a single page showing three separate trends of the SPC Mean, Range, and Standard Deviation. The Mean needs to be at nAN, the Range at AN + 1, and the Standard Deviation at AN + 2. You can specify a title and a comment for the plot, and whether it is printed in color or in black and white.",
        "sPort, nAN [, sTitle] [, sComment] [,": "SPCPlot(sPort, nAN [, sTitle] [, sComment] [, nMode] )",
        "sPort": "The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks. For example LPT1:, to print to the local printer, or \\\\Pserver\\canon1 using UNC to print to a network printer.",
        "sTitle": "The title of the trend plot.",
        "sComment": "The comment that is to display beneath the title of the trend plot. You do not have to enter a comment.",
        "nMode": "The color mode of the printer."
      },
      "helpPath": "SPCPlot.html"
    },
    "spcprocessxrsget": {
      "name": "SPCProcessXRSGet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "XVariable",
        "RVariable",
        "SVariable [",
        "sClusterName]"
      ],
      "doc": "Gets the process mean, range, and standard deviation overrides for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. The process mean is written to XVariable, the process range to RVariable, and the standard deviation to SVariable.",
      "paramDocs": {
        "sSPCTag, XVariable, RVariable, SVariable [, sClusterName]": "SPCProcessXRSGet(sSPCTag, XVariable, RVariable, SVariable [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "XVariable": "The Cicode variable that stores the process mean (X double bar). A constant is not allowed. Must be a Real type global variable.",
        "RVariable": "The Cicode variable that stores the range (R). A constant is not allowed. Must be a Real type global variable.",
        "SVariable": "The Cicode variable that stores the standard deviation (S). A constant is not allowed. Must be a Real type global variable.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCProcessXRSGet.html"
    },
    "spcprocessxrsset": {
      "name": "SPCProcessXRSSet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "rMean",
        "rRange",
        "rStdDev [",
        "sClusterName]"
      ],
      "doc": "Sets the process mean, range and standard deviation overrides for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned.",
      "paramDocs": {
        "sSPCTag, rMean, rRange, rStdDev [, sClusterName]": "SPCProcessXRSSet(sSPCTag, rMean, rRange, rStdDev [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "rMean": "The new value of process mean (x double bar) to set.",
        "rRange": "The new value of process range to set.",
        "rStdDev": "The new value of process standard deviation to set.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCProcessXRSSet.html"
    },
    "spcsetlimit": {
      "name": "SPCSetLimit",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Type",
        "Value",
        "Setting"
      ],
      "doc": "Sets the upper or lower control limits of X-bar, range, or standard deviation charts.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Automatic",
        "1": "X-bar upper control limit",
        "2": "X-bar lower control limit",
        "3": "Range upper control limit",
        "4": "Range lower control limit",
        "5": "Standard deviation upper control limit",
        "6": "Standard deviation lower control limit",
        "7": "X-bar centre line",
        "8": "Range centre line",
        "9": "Standard deviation centre line",
        "nAN, Type, Value, Setting": "SPCSetLimit(nAN, Type, Value, Setting)",
        "nAN": "The AN where the SPC chart is located.",
        "nType": "The SPC type:",
        "Value": "The value for the control limit.",
        "Setting": "Automatic calculation or manual setting of control limits:"
      },
      "helpPath": "SPCSetLimit.html"
    },
    "spcspeclimitget": {
      "name": "SPCSpecLimitGet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "LSLVariable",
        "USLVariable [",
        "sClusterName]"
      ],
      "doc": "Gets the process Upper and Lower Specification Limits (USL and LSL) for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. The LSL is written to LSLVariable, while the USL is written to USLVariable.",
      "paramDocs": {
        "sSPCTag, LSLVariable, USLVariable [, sClusterName]": "SPCSpecLimitGet(sSPCTag, LSLVariable, USLVariable [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "LSLVariable": "The Cicode variable that stores the Lower Specification Limit (LSL). Do not specify a constant in this field. Must be a Real type global variable.",
        "USLVariable": "The Cicode variable that stores the Upper Specification Limit (USL). Do not specify a constant in this field. Must be a Real type global variable.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCSpecLimitGet.html"
    },
    "spcspeclimitset": {
      "name": "SPCSpecLimitSet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "rLSL",
        "rUSL [",
        "sClusterName]"
      ],
      "doc": "Sets the process Upper and Lower Specification Limits (USL and LSL) for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned.",
      "paramDocs": {
        "sSPCTag, rLSL, rUSL [, sClusterName]": "SPCSpecLimitSet(sSPCTag, rLSL, rUSL [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "rLSL": "The new value of Lower Specification Limit (LSL) to set.",
        "rUSL": "The new value of Upper Specification Limit (USL) to set.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCSpecLimitSet.html"
    },
    "spcsubgroupsizeget": {
      "name": "SPCSubgroupSizeGet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "SizeVariable [",
        "sClusterName]"
      ],
      "doc": "Gets the subgroup size for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. The subgroup size is written to SizeVariable.",
      "paramDocs": {
        "sSPCTag, SizeVariable [, sClusterName]": "SPCSubgroupSizeGet(sSPCTag, SizeVariable [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "SizeVariable": "The Cicode variable that stores the subgroup size. This variable needs to be defined as a global of type INT. A constant is not allowed. Must be a Long type variable.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCSubgroupSizeGet.html"
    },
    "spcsubgroupsizeset": {
      "name": "SPCSubgroupSizeSet",
      "returnType": "UNKNOWN",
      "params": [
        "sSPCTag",
        "iSize [",
        "sClusterName]"
      ],
      "doc": "Sets a new subgroup size for the specified SPC tag.",
      "returns": "0 (zero) if successful, otherwise an error number is returned.",
      "paramDocs": {
        "sSPCTag, iSize [, sClusterName]": "SPCSubgroupSizeSet(sSPCTag, iSize [, sClusterName] )",
        "sSPCTag": "The SPC Tag name as defined in SPC Tags.",
        "iSize": "The new size of the subgroup to set.",
        "sClusterName": "Specifies the name of the cluster of the SPC tag."
      },
      "helpPath": "SPCSubgroupSizeSet.html"
    },
    "sqlappend": {
      "name": "SQLAppend",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "String"
      ],
      "doc": "Appends a query string to the SQL buffer.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral, String": "SQLAppend(hGeneral, String)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle, the operation is performed on the default query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "String": "The query string to append to the SQL buffer."
      },
      "helpPath": "SQLAppend.html"
    },
    "sqlbegintran": {
      "name": "SQLBeginTran",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Starts a database transaction. When you make a transaction, your changes are not written to the database until you call the SQLCommit() function.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL": "SQLBeginTran(hSQL)"
      },
      "helpPath": "SQLBeginTran.html"
    },
    "sqlcall": {
      "name": "SQLCall",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sSelect"
      ],
      "doc": "Executes an SQL query on a database. The function returns the number of rows affected by the executed query.",
      "returns": "The number of affected records or -1 if an error is detected. (For details call the SQLErrMsg() function). The presence of error code can be tested by calling the IsError() CiCode function.",
      "paramDocs": {
        "hGeneral, sSelect": "SQLCall(hGeneral, sSelect)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "sSelect": "The SQL query to be sent to the SQL database."
      },
      "helpPath": "SQLCall.html"
    },
    "sqlcancel": {
      "name": "SQLCancel",
      "returnType": "UNKNOWN",
      "params": [
        "hConnection"
      ],
      "doc": "This function cancels both the current operation on the given connection and all other pending operations on the given connection.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hConnection": "SQLCancel(hConnection)"
      },
      "helpPath": "SQLCancel.html"
    },
    "sqlclose": {
      "name": "SQLClose",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Closes a SQL connection between the DB connection object specified by the function's parameter and a database.",
      "returns": "0 if success, otherwise an error code (For details call the SQLErrMsg() function).",
      "paramDocs": {
        "hSQL": "SQLClose(hSQL)"
      },
      "helpPath": "SQLClose.html"
    },
    "sqlcommit": {
      "name": "SQLCommit",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Commits (to the database) all changes made within a transaction.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hSQL": "SQLCommit(hSQL)"
      },
      "helpPath": "SQLCommit.html"
    },
    "sqlconnect": {
      "name": "SQLConnect",
      "returnType": "UNKNOWN",
      "params": [
        "sConnect"
      ],
      "doc": "Creates an internal database connection object and tries to connect it to a database specified by the connection string.",
      "returns": "The handle to the database connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the database connection object where details of the associated SQL connection to a DB are stored.",
      "paramDocs": {
        "sConnect": "SQLConnect(sConnect)"
      },
      "helpPath": "SQLConnect.html"
    },
    "sqlcreate": {
      "name": "SQLCreate",
      "returnType": "UNKNOWN",
      "params": [
        "sConnect"
      ],
      "doc": "Creates an internal DB connection object and returns a handle to the object for use by the other DB functions.",
      "returns": "The handle to the DB connection object if the connection is successful, otherwise -1 is returned. (For details call the SQLErrMsg() function). The handle identifies the DB connection object where details of the associated SQL connection to a DB are stored.",
      "paramDocs": {
        "sConnect": "SQLCreate(sConnect)"
      },
      "helpPath": "SQLCreate.html"
    },
    "sqldisconnect": {
      "name": "SQLDisconnect",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Closes the SQL connection to a database and disposes the DB connection object specified by the function parameter.",
      "returns": "0 if success, otherwise an error code (For details call the SQLErrMsg() function).",
      "paramDocs": {
        "hSQL": "SQLDisconnect(hSQL)"
      },
      "helpPath": "SQLDisconnect.html"
    },
    "sqldispose": {
      "name": "SQLDispose",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Closes the SQL connection to a database and disposes the DB connection object specified by the function parameter.",
      "returns": "0  if success, otherwise an error code (For details call the SQLErrMsg() function).",
      "paramDocs": {
        "hSQL": "SQLDispose(hSQL)"
      },
      "helpPath": "SQLDispose.html"
    },
    "sqlend": {
      "name": "SQLEnd",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "SQLEnd() releases the memory that was allocated when the last query was executed via SQLExec.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hGeneral": "SQLEnd(hGeneral)"
      },
      "helpPath": "SQLEnd.html"
    },
    "sqlerrmsg": {
      "name": "SQLErrMsg",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "Returns an error message from either a particular data object or entire data system.",
      "returns": "The error message (as a string).",
      "paramDocs": {
        "hGeneral": "SQLErrMsg(hGeneral)"
      },
      "helpPath": "SQLErrMsg.html"
    },
    "sqlexec": {
      "name": "SQLExec",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sSelect"
      ],
      "doc": "Executes an SQL query on a database.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hGeneral, sSelect": "SQLExec(hGeneral, sSelect)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "sSelect": "The SQL query to be sent to the SQL database."
      },
      "helpPath": "SQLExec.html"
    },
    "sqlfieldinfo": {
      "name": "SQLFieldInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "hField",
        "sName",
        "Width"
      ],
      "doc": "Gets information about the fields or columns selected by a SQL query.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral, hField, sName, Width": "SQLFieldInfo(hGeneral, hField, sName, Width)",
        "hGeneral": "The handle either to:",
        "hField": "The field (or column) handle, indicating the position of the field in the database.",
        "sName": "Output Parameter: A string in which the function stores the field name. The argument is returned by the function. Must be a String type variable.",
        "Width": "Output Parameter: An integer in which the function stores the maximum number of characters in the field. The argument is returned by the function. Must be an Integer type variable."
      },
      "helpPath": "SQLFieldInfo.html"
    },
    "sqlgetfield": {
      "name": "SQLGetField",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sField",
        "nRowIndex"
      ],
      "doc": "Gets field or column data from a database field.",
      "returns": "The field or column data (as a string).",
      "paramDocs": {
        "hGeneral, sField, nRowIndex": "SQLGetField(hGeneral, sField, nRowIndex)",
        "hGeneral": "The handle either to:",
        "sField": "The name of the field or column.",
        "nRowIndex": "If hGeneral is a connection handle and nRowindex is not equal -1, then the function returns an empty string."
      },
      "helpPath": "SQLGetField.html"
    },
    "sqlgetrecordset": {
      "name": "SQLGetRecordset",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sSelect"
      ],
      "doc": "Executes an SQL query on a database and returns a handle to any resulting disconnected recordset.",
      "returns": "The handle to a recordset holding the result of the query. If unsuccessful an invalid handle and an error code are returned (for details call the SQLErrMsg() function). If no data is returned, an invalid handle and no error message are returned. The presence of an error can be tested by calling the IsError() CiCode function",
      "paramDocs": {
        "hGeneral, sSelect": "SQLGetRecordset(hGeneral, sSelect)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "sSelect": "The SQL query to be sent to the SQL database."
      },
      "helpPath": "SQLGetRecordset.html"
    },
    "sqlgetscalar": {
      "name": "SQLGetScalar",
      "returnType": "STRING",
      "params": [
        "hGeneral",
        "sSelect",
        "isNull"
      ],
      "doc": "Executes an SQL query on a database.",
      "returns": "String representing a value from the first column and the first row of the result of executing the SQL query. If the value is NULL, the string is empty and isNull parameter is set to TRUE. If there are no records in the result, the string is empty and the error code is set to 294. For details of the 307 error code, call the SQLErrMsg() function. The presence of error code can be tested by calling the IsError() CiCode function.",
      "paramDocs": {
        "hGeneral, sSelect, isNull": "SQLGetScalar(hGeneral, sSelect, isNull)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle and sSelect is an empty string, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "sSelect": "The SQL query to be sent to the SQL database.",
        "isNull": "Output Parameter: Indicated whether the returned variable is NULL. The argument is returned by the function."
      },
      "helpPath": "SQLGetScalar.html"
    },
    "sqlinfo": {
      "name": "SQLInfo",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "Type"
      ],
      "doc": "Gets information about a database connection, recordset or query properties.",
      "returns": "The information (as a string).",
      "paramDocs": {
        "0": "The connection string",
        "1": "The current SQL query for connection handles and query handles or the source SQL query for recordset handles",
        "2": "The current database filename (only works with SQL device)",
        "3": "No longer supported.",
        "4": "No longer supported. Now returns an empty string and sets the SQL error to 'Invalid Type'.",
        "5": "The DB connection object's state: Closed (The connection is closed), Open (The connection is open), Connecting (The connection object is connecting to the data source. For future release), Executing (The connection object is executing a command. For future release), Fetching (The connection object is retrieving data. For future release), Broken (The connection to the data source is broken. This can occur only after the connection has been opened. A connection in this state may be closed and then re-opened. For future release). An empty string means either error occurred or the handle is invalid",
        "6": "The handle to the connection if used on either recordset or query handle. Note: There is no guarantee that the objects behind the connection handles still exist in the system.",
        "7": "Checks whether a new transaction can be opened. The function perform a check how many transaction levels have been already opened and returns TRUE if a new one can be opened, otherwise FALSE. The function doesn't check ability of the external DB to open transactions. The functions returns FALSE for recordset handles.",
        "hGeneral, Type": "SQLInfo(hGeneral, Type)",
        "hGeneral": "The handle either to:",
        "nType": "The type of information to get:"
      },
      "helpPath": "SQLInfo.html"
    },
    "sqlisnullfield": {
      "name": "SQLIsNullField",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sField",
        "nRowIndex=-1"
      ],
      "doc": "Checks presence of null value in field from a recordset.",
      "returns": "TRUE if the value is NULL, FALSE otherwise.",
      "paramDocs": {
        "hGeneral, sField, nRowIndex=-1": "SQLIsNullField(hGeneral, sField, nRowIndex=-1)",
        "hGeneral": "The handle either to:",
        "sField": "The name of the field or column.",
        "nRowIndex": "The number of the row which data is requested. The first row has index 0. -1 means that an internal pointer is used instead. The pointer can be moved forward and backward by executing SQLNext() or SQLPrev() functions."
      },
      "helpPath": "SQLIsNullField.html"
    },
    "sqlnext": {
      "name": "SQLNext",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "Gets the next database record from an SQL query.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral": "SQLNext(hGeneral)"
      },
      "helpPath": "SQLNext.html"
    },
    "sqlnofields": {
      "name": "SQLNoFields",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "When the hGeneral is the connection handle, the function returns the number of fields or columns that were returned by the last SQL statement.",
      "returns": "The number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral": "SQLNoFields(hGeneral)"
      },
      "helpPath": "SQLNoFields.html"
    },
    "sqlnumchange": {
      "name": "SQLNumChange",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Gets the number of records that were modified in the last SQL Insert, Update, or Delete statement.",
      "returns": "The number of records that were modified. A value of 0 is returned if no fields were returned or if an error has occurred. (For details of an error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL": "SQLNumChange(hSQL)"
      },
      "helpPath": "SQLNumChange.html"
    },
    "sqlnumfields": {
      "name": "SQLNumFields",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "When hGeneral is the connection handle, the function returns the number of fields or columns that were returned by the last SQL statement.",
      "returns": "The number of fields. A value of 0 is returned if no fields were returned or if an error has been detected. (For details of an error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral": "SQLNumFields(hGeneral)"
      },
      "helpPath": "SQLNumFields.html"
    },
    "sqlopen": {
      "name": "SQLOpen",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Opens an SQL connection between the DB connection object specified by the function's parameter and the database defined by the connection string given before as the parameter to either SQLCreate or SQLConnect function.",
      "returns": "0 if success, otherwise an error code (For details call the SQLErrMsg() function)",
      "paramDocs": {
        "hSQL": "SQLOpen(hSQL)"
      },
      "helpPath": "SQLOpen.html"
    },
    "sqlparamsclearall": {
      "name": "SQLParamsClearAll",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Remove all parameters associated with a particular connection object.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL": "SQLParamsClearAll(hSQL)"
      },
      "helpPath": "SQLParamsClearAll.html"
    },
    "sqlparamssetasint": {
      "name": "SQLParamsSetAsInt",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL",
        "ParamName",
        "ParamValue"
      ],
      "doc": "Adds or replace a parameterized query parameter and its value in the specified connection.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL, ParamName, ParamValue": "SQLParamsSetAsInt(hSQL, ParamName, ParamValue)",
        "hSQL": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
        "ParamName": "The name of the parameter to add or change.",
        "ParamValue": "The value of the parameter as an integer."
      },
      "helpPath": "SQLParamsSetAsInt.html"
    },
    "sqlparamssetasreal": {
      "name": "SQLParamsSetAsReal",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL",
        "ParamName",
        "ParamValue"
      ],
      "doc": "Adds or replaces a parameterized query's parameter and its value in the specified connection.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL, ParamName, ParamValue": "SQLParamsSetAsReal(hSQL, ParamName, ParamValue)",
        "hSQL": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
        "ParamName": "The name of the parameter to add or change.",
        "ParamValue": "The value of the parameter as a real."
      },
      "helpPath": "SQLParamsSetAsReal.html"
    },
    "sqlparamssetasstring": {
      "name": "SQLParamsSetAsString",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL",
        "ParamName",
        "ParamValue",
        "nStrType"
      ],
      "doc": "Adds or replaces a parameterized query's parameter and its value in the specified connection.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "0": "Allowing ADO engine to use the default string type of the protocol. For SQLClient, OleDB and ODBC, the default string type is NVarChar (A variable-length stream of Unicode characters ranging between 1 and 4,000 characters);",
        "1": "Forcing the string type to be NVarChar;",
        "2": "Forcing the string type to be NChar (A fixed-length stream of Unicode characters ranging between 1 and 4,000 characters);",
        "3": "Forcing the string type to be VarChar (A variable-length stream of non-Unicode characters ranging between 1 and 8,000 characters. VarChar is used when the database column is varchar(max));",
        "4": "Forcing the string type to be Char (A fixed-length stream of non-Unicode characters ranging between 1 and 8,000 characters).",
        "hSQL, ParamName, ParamValue, nStrType": "SQLParamsSetAsString(hSQL, ParamName, ParamValue, nStrType)",
        "hSQL": "The handle to the DB connection object, returned from either SQLCreate() or SQLConnect() function. The handle identifies the DB connection object where details of the associated SQL connection are stored.",
        "ParamName": "The name of the parameter to add or change.",
        "ParamValue": "The value of the parameter as a string.",
        "nStrType": "The index specifying the type of the string:"
      },
      "helpPath": "SQLParamsSetAsString.html"
    },
    "sqlprev": {
      "name": "SQLPrev",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "Gets the previous database record from an SQL query.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hGeneral": "SQLPrev(hGeneral)"
      },
      "helpPath": "SQLPrev.html"
    },
    "sqlquerycreate": {
      "name": "SQLQueryCreate",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "The function creates a new query and returns its handle.",
      "returns": "The handle to the query if successful, otherwise the invalid handle.",
      "paramDocs": {
        "hSQL": "SQLQueryCreate(hSQL)"
      },
      "helpPath": "SQLQueryCreate.html"
    },
    "sqlquerydispose": {
      "name": "SQLQueryDispose",
      "returnType": "UNKNOWN",
      "params": [
        "hQuery"
      ],
      "doc": "The function disposes the query which handle is given as the argument.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hQuery": "SQLQueryDispose(hQuery)"
      },
      "helpPath": "SQLQueryDispose.html"
    },
    "sqlrollback": {
      "name": "SQLRollBack",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Rolls back (discards) all changes made to the database within the current transaction.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL": "SQLRollBack(hSQL)"
      },
      "helpPath": "SQLRollBack.html"
    },
    "sqlrowcount": {
      "name": "SQLRowCount",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral"
      ],
      "doc": "Gets the number of rows in the recordset.",
      "returns": "The number of rows in the given recordset for disconnected recordsets. For the connected recordset, the function returns always -1.",
      "paramDocs": {
        "hGeneral": "SQLRowCount(hGeneral)"
      },
      "helpPath": "SQLRowCount.html"
    },
    "sqlset": {
      "name": "SQLSet",
      "returnType": "UNKNOWN",
      "params": [
        "hGeneral",
        "sString"
      ],
      "doc": "Sets a query string in the SQL buffer.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg() function).",
      "paramDocs": {
        "hGeneral, sString": "SQLSet(hGeneral, sString)",
        "hGeneral": "The handle either to the DB connection object (returned from either SQLCreate() or SQLConnect() function) or to the query handle (returned from SQLQueryCreate()). When it is the connection handle, the operation is performed on the first query in that DB connection object. When it is the query handle, the operation is performed on that query through the DB object which is associated to it.",
        "sString": "The query string to set in the SQL buffer. The string needs to contain the first part of an SQL query."
      },
      "helpPath": "SQLSet.html"
    },
    "sqltraceoff": {
      "name": "SQLTraceOff",
      "returnType": "UNKNOWN",
      "params": [
        "hSQL"
      ],
      "doc": "Turns off the debug trace. Use this function to stop tracing function calls that are made to the database.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "hSQL": "The handle to the DB connection object: INVALID HANDLE - The trace is deactivated for all DB connections (default), otherwise - The trace is deactivated for this specific DB connection object."
      },
      "helpPath": "SQLTraceOff.html"
    },
    "sqltraceon": {
      "name": "SQLTraceOn",
      "returnType": "UNKNOWN",
      "params": [
        "sFileName",
        "hSQL",
        "nTraceLevel"
      ],
      "doc": "Turns on a debug trace. Use this function to begin tracing function calls that are made to the database.",
      "returns": "0 (zero) if successful, otherwise an error number is returned. (For details of the 307 error code, call the SQLErrMsg function).",
      "paramDocs": {
        "sFileName, hSQL, nTraceLevel": "SQLTraceOn(sFileName, hSQL, nTraceLevel)",
        "sFileName": "The output file name for the debug trace. Currently ignored.",
        "hSQL": "The handle to the DB connection object: INVALID HANDLE - The trace is activated for all DB connections (default), otherwise - The trace is activated for this specific DB connection object.",
        "nTraceLevel": "Defines the level of details written to the trace file. The following values are allowed:"
      },
      "helpPath": "SQLTraceOn.html"
    },
    "sqrt": {
      "name": "Sqrt",
      "returnType": "UNKNOWN",
      "params": [
        "Number"
      ],
      "doc": "Gets the square root of a number.",
      "returns": "The square root of Number.",
      "paramDocs": {
        "Number": "Sqrt(Number)"
      },
      "helpPath": "Sqrt.html"
    },
    "strcalcwidth": {
      "name": "StrCalcWidth",
      "returnType": "UNKNOWN",
      "params": [
        "sText",
        "iFont"
      ],
      "doc": "Retrieves the pixel width of a string using a particular font.",
      "returns": "The pixel width of a string using the particular font.",
      "paramDocs": {
        "sText, iFont": "StrCalcWidth(sText, iFont)",
        "sText": "The text to determine the pixel width of",
        "iFont": "The font number used to calculate the pixel width of the text. (To use the default font, set to -1)."
      },
      "helpPath": "StrCalcWidth.html"
    },
    "strclean": {
      "name": "StrClean",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Removes control characters from a string.",
      "returns": "The string with all control characters removed.",
      "paramDocs": {
        "String": "StrClean(String)"
      },
      "helpPath": "StrClean.html"
    },
    "strendswith": {
      "name": "StrEndsWith",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sSource",
        "STRING sSearchTerm"
      ],
      "doc": "Verifies whether the given string ends with a specific string.",
      "paramDocs": {
        "STRING": "StrEndsWith(STRING sSource, STRING sSearchTerm)",
        "sSource": "sSource",
        "sSearchTerm": "sSearchTerm"
      },
      "helpPath": "StrEndsWith.htm"
    },
    "strfill": {
      "name": "StrFill",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "Length"
      ],
      "doc": "Fills a string with a number of occurrences of another string.",
      "returns": "The filled string.",
      "paramDocs": {
        "String, Length": "StrFill(String, Length)",
        "String": "The string to be repeated.",
        "Length": "The length of the string."
      },
      "helpPath": "StrFill.html"
    },
    "strformat": {
      "name": "StrFormat",
      "returnType": "UNKNOWN",
      "params": [
        "Variable",
        "Width",
        "DecPlaces",
        "EngUnits"
      ],
      "doc": "Converts a variable into a formatted string.",
      "returns": "The variable (as a formatted string).",
      "paramDocs": {
        "Variable, Width, DecPlaces, EngUnits": "StrFormat(Variable, Width, DecPlaces, EngUnits)",
        "Variable": "The variable to format into a string.",
        "Width": "The width of the variable after it has been converted to string format.",
        "DecPlaces": "The number of decimal places in the converted string.",
        "EngUnits": "The engineering units of the variable."
      },
      "helpPath": "StrFormat.html"
    },
    "strgetchar": {
      "name": "StrGetChar",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "iOffset"
      ],
      "doc": "Gets a single character from a string or buffer. Use this function to read a string, character by character.",
      "returns": "The character at the offset in the string.",
      "paramDocs": {
        "String, iOffset": "StrGetChar(String, iOffset)",
        "String": "The source string. Must be a String type variable.",
        "iOffset": "The offset in the string, commencing at 0."
      },
      "helpPath": "StrGetChar.html"
    },
    "strleft": {
      "name": "StrLeft",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "N"
      ],
      "doc": "Gets the left-most characters from a string.",
      "returns": "A string containing the left-most N characters of String.",
      "paramDocs": {
        "String, N": "StrLeft(String, N)",
        "String": "The source string.",
        "N": "The number of characters to get from the source string."
      },
      "helpPath": "StrLeft.html"
    },
    "strlength": {
      "name": "StrLength",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Gets the length of a string.",
      "returns": "The length of the string (as an integer).",
      "paramDocs": {
        "String": "StrLength(String)"
      },
      "helpPath": "StrLength.html"
    },
    "strlistcontainsitem": {
      "name": "StrListContainsItem",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sItem",
        "STRING sList",
        "STRING sDelim"
      ],
      "doc": "Checks whether the string passed is an item contained in a delimited list of strings.",
      "paramDocs": {
        "STRING": "StrListContainsItem(STRING sItem, STRING sList, STRING sDelim)",
        "sItem": "sItem",
        "sList": "sList",
        "sDelim": "sDelim"
      },
      "helpPath": "StrListContainsItem.htm"
    },
    "strlower": {
      "name": "StrLower",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string to lowercase.",
      "returns": "The string (as lowercase).",
      "paramDocs": {
        "String": "StrLower(String)"
      },
      "helpPath": "StrLower.html"
    },
    "strmid": {
      "name": "StrMid",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "Offset",
        "Characters"
      ],
      "doc": "Gets characters from the middle of a string.",
      "returns": "A string containing the number of characters from the offset.",
      "paramDocs": {
        "String, Offset, Characters": "StrMid(String, Offset, Characters)",
        "String": "The source string.",
        "Offset": "The offset in the string, commencing at 0.",
        "Characters": "The number of characters to get, commencing at the offset."
      },
      "helpPath": "StrMid.html"
    },
    "strpad": {
      "name": "StrPad",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "PadString",
        "Length"
      ],
      "doc": "Pads a string with a number of occurrences of another string.",
      "returns": "A padded string.",
      "paramDocs": {
        "String, PadString, Length": "StrPad(String, PadString, Length)",
        "String": "The source string.",
        "PadString": "The padding string.",
        "Length": "The length of the string. If a positive length is specified, padding will be added to the right of the string. If a negative length is specified, padding will be added to the left of the string."
      },
      "helpPath": "StrPad.html"
    },
    "strreplace": {
      "name": "StrReplace",
      "returnType": "UNKNOWN",
      "params": [
        "sString",
        "sFindSubstring [",
        "sReplaceSubstring [",
        "sTerminators]]"
      ],
      "doc": "Replaces a substring in a string with replacement substring.",
      "returns": "The replaced string.",
      "paramDocs": {
        "sString": "StrReplace(sString, sFindSubstring [, sReplaceSubstring [, sTerminators]])",
        "sFindSubstring": "The substring to search for.",
        "sReplaceSubstring": "The replacement substring. If this is not specified, it defaults to an empty string, that is, the matched substring will be removed from the original string."
      },
      "helpPath": "StrReplace.htm"
    },
    "strright": {
      "name": "StrRight",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "N"
      ],
      "doc": "Gets the rightmost characters from a string.",
      "returns": "A string containing the rightmost N characters of String.",
      "paramDocs": {
        "String, N": "StrRight(String, N)",
        "String": "The source string.",
        "N": "The number of characters to get from the source string."
      },
      "helpPath": "StrRight.html"
    },
    "strsearch": {
      "name": "StrSearch",
      "returnType": "UNKNOWN",
      "params": [
        "Offset",
        "String",
        "Substring"
      ],
      "doc": "Searches for a string within a string, commencing at a specified offset.",
      "returns": "The index in the search string, or -1 if the sub-string does not exist in the string.",
      "paramDocs": {
        "Offset, String, Substring": "StrSearch(Offset, String, Substring)",
        "Offset": "The offset in the string, commencing at 0.",
        "String": "The source string.",
        "Substring": "The substring to search for."
      },
      "helpPath": "StrSearch.html"
    },
    "strsetchar": {
      "name": "StrSetChar",
      "returnType": "UNKNOWN",
      "params": [
        "sText",
        "iOffset",
        "Char"
      ],
      "doc": "Sets a single character into a string or buffer.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sText, iOffset, Char": "StrSetChar(sText, iOffset, Char)",
        "sText": "The destination string. Must be a String type variable.",
        "iOffset": "The offset in the string, commencing at 0.",
        "Char": "The ASCII character to set into the string."
      },
      "helpPath": "StrSetChar.html"
    },
    "strsplit": {
      "name": "StrSplit",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sSource",
        "STRING sDelim",
        "INT bNoTrim"
      ],
      "doc": "Splits a string into sub-strings based on the specified delimiter.",
      "paramDocs": {
        "STRING": "StrSplit(STRING sSource, STRING sDelim, INT bNoTrim)",
        "sSource": "sSource",
        "sDelim": "sDelim",
        "bNoTrim": "bNoTrim"
      },
      "helpPath": "StrSplit.htm"
    },
    "strtobool": {
      "name": "StrToBool",
      "returnType": "BOOLEAN",
      "params": [
        "sVal"
      ],
      "doc": "Converts a string value to a Boolean value.",
      "returns": "Boolean value of 0 or 1.",
      "paramDocs": {
        "sVal": "StrToBool(sVal)"
      },
      "helpPath": "StrToBool.htm"
    },
    "strtochar": {
      "name": "StrToChar",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Gets the ASCII code of the first character in a string.",
      "returns": "The ASCII code of the first character in String.",
      "paramDocs": {
        "String": "StrToChar(String)",
        "String.": "The ASCII code of the first character in String."
      },
      "helpPath": "StrToChar.html"
    },
    "strtodate": {
      "name": "StrToDate",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a \"date\" string into a time/date variable.",
      "returns": "A time/date variable, or 274 if the time/date is out of range.",
      "paramDocs": {
        "String": "StrToDate(String)"
      },
      "helpPath": "StrToDate.html"
    },
    "strtofmt": {
      "name": "StrToFmt",
      "returnType": "UNKNOWN",
      "params": [
        "hFmt",
        "String"
      ],
      "doc": "Converts a string into field data for a format template.",
      "returns": "The string (formatted as template field data).",
      "paramDocs": {
        "hFmt, String": "StrToFmt(hFmt, String)",
        "hFmt": "The format template handle, returned from the FmtOpen() function. The handle identifies the table where all data on the associated format template is stored.",
        "String": "The source string."
      },
      "helpPath": "StrToFmt.html"
    },
    "strtogrp": {
      "name": "StrToGrp",
      "returnType": "UNKNOWN",
      "params": [
        "hGrp",
        "Str"
      ],
      "doc": "Converts a string into a group and places it into a group number.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hGrp, Str": "StrToGrp(hGrp, Str)",
        "hGrp": "The group handle, returned from the GrpOpen() function. The group handle identifies the table where all data on the associated group is stored.",
        "Str": "The string to convert."
      },
      "helpPath": "StrToGrp.html"
    },
    "strtohex": {
      "name": "StrToHex",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a hexadecimal string into an integer.",
      "returns": "An integer (converted from String).",
      "paramDocs": {
        "String": "StrToHex(String)"
      },
      "helpPath": "StrToHex.html"
    },
    "strtoint": {
      "name": "StrToInt",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string into an integer.",
      "returns": "An integer (converted from String).",
      "paramDocs": {
        "String": "StrToInt(String)"
      },
      "helpPath": "StrToInt.html"
    },
    "strtolines": {
      "name": "StrToLines",
      "returnType": "UNKNOWN",
      "params": [
        "String",
        "MaxChars",
        "nLines"
      ],
      "doc": "Converts a string into separate lines that contain no more than the number of characters specified in the MaxChars argument.",
      "returns": "A string containing the input string with new line characters inserted into it.",
      "paramDocs": {
        "String,MaxChars, nLines": "StrToLines(String,MaxChars, nLines)",
        "String": "The string to convert.",
        "MaxChars": "The maximum number of characters permitted in each new line produced by the StrToLines() function.",
        "nLines": "Output Parameter: Returns the number of lines produced by the StrToLines() function from the input string. This should be a Cicode INT type variable."
      },
      "helpPath": "StrToLines.html"
    },
    "strtolocaltext": {
      "name": "StrToLocalText",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Converts a native string into the local version of that string.",
      "returns": "The local version of the text if it was found, otherwise the native text or \"#MESS\" is returned, depending on the setting of the [Language]DisplayError parameter.",
      "paramDocs": {
        "sText": "StrToLocalText(sText)"
      },
      "helpPath": "StrToLocalText.html"
    },
    "strtoperiod": {
      "name": "StrToPeriod",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string into a time period.",
      "returns": "A period (converted from String), or -1 if no conversion can be performed.",
      "paramDocs": {
        "String": "StrToPeriod(String)"
      },
      "helpPath": "StrToPeriod.html"
    },
    "strtoreal": {
      "name": "StrToReal",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string into a floating-point number.",
      "returns": "A floating-point number (converted from String).",
      "paramDocs": {
        "String": "StrToReal(String)"
      },
      "helpPath": "StrToReal.html"
    },
    "strtotime": {
      "name": "StrToTime",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a \"time\" string into a time/date variable.",
      "returns": "A time/date variable, or -1 if no conversion can be performed.",
      "paramDocs": {
        "String": "StrToTime(String)"
      },
      "helpPath": "StrToTime.html"
    },
    "strtotimestamp": {
      "name": "StrToTimestamp",
      "returnType": "UNKNOWN",
      "params": [
        "STRING String [",
        "INT Format [",
        "INT UTC]]"
      ],
      "doc": "This function converts timestamp in a STRING format into a TIMESTAMP format.",
      "returns": "This function returns a date in TIMESTAMP format if successful, otherwise returns TIMESTAMP of January 1, 1601, 00:00:00 (UTC). If the function is unsuccessful you can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "STRING String [, INT Format [, INT UTC]]": "TIMESTAMP StrToTimestamp(STRING String [, INT Format [, INT UTC]])",
        "String": "The date and time as a STRING or TIMESTAMP",
        "Format": "The format of the string. Should be 15. Other types reserved for future use.",
        "UTC": "If 1, the date is considered to be in UTC. Otherwise, local time is used. This field is only applicable for format STRING formats (i.e. format is not equal 15)."
      },
      "helpPath": "StrToTimestamp.html"
    },
    "strtovalue": {
      "name": "StrToValue",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string into a floating-point number.",
      "returns": "A floating-point number (converted from String).",
      "paramDocs": {
        "String": "StrToValue(String)"
      },
      "helpPath": "StrToValue.html"
    },
    "strtrim": {
      "name": "StrTrim",
      "returnType": "STRING",
      "params": [
        "String"
      ],
      "doc": "Removes leading and trailing spaces from a string. Internal spaces are not removed from the string.",
      "returns": "String with leading and trailing spaces removed.",
      "paramDocs": {
        "String": "StrTrim(String)"
      },
      "helpPath": "StrTrim.html"
    },
    "strtruncfont": {
      "name": "StrTruncFont",
      "returnType": "UNKNOWN",
      "params": [
        "sText",
        "sFont [",
        "iLength] [",
        "iLengthMode]"
      ],
      "doc": "Returns the truncated string using a particular font (specified by name) or the specified number of characters.",
      "returns": "A truncated string or the original one.",
      "paramDocs": {
        "sText, sFont [, iLength] [, iLengthMode]": "StrTruncFont(sText, sFont [, iLength] [, iLengthMode])",
        "sText": "The text to truncate",
        "sFont": "The name of the font that is used to display the text. The Font Name needs to be defined in the Fonts database. If the font is not found, the default font is used.",
        "iLength": "Length of the Text to display, either in characters or pixels depending on iLengthMode (default -1, no truncation)",
        "iLengthMode": "The length mode of the text string:"
      },
      "helpPath": "StrTruncFont.html"
    },
    "strtruncfonthnd": {
      "name": "StrTruncFontHnd",
      "returnType": "UNKNOWN",
      "params": [
        "sText",
        "hFont [",
        "iLength] [",
        "iLengthMode]"
      ],
      "doc": "Returns the truncated string using a particular font (specified by font number) or the specified number of characters.",
      "returns": "A truncated string or the original one.",
      "paramDocs": {
        "sText, hFont [, iLength] [, iLengthMode]": "StrTruncFontHnd(sText, hFont [, iLength] [, iLengthMode])",
        "sText": "The text to truncate",
        "hFont": "The font handle used to calculate the pixel width of the text. (To use the default font, set to -1).",
        "iLength": "Length of the Text to display, either in characters or pixels depending on iLengthMode (default -1, no truncation)",
        "iLengthMode": "The length mode of the text string:"
      },
      "helpPath": "StrTruncFontHnd.html"
    },
    "strtruncfonttooltip": {
      "name": "StrTruncFontTooltip",
      "returnType": "UNKNOWN",
      "params": [
        "INT nANForTooltip",
        "STRING sText",
        "STRING sFont",
        "INT nPixels"
      ],
      "doc": "Returns a truncated string with ellipsis, and sets an AN with a tooltip containing the complete string if a truncation occurs.",
      "paramDocs": {
        "INT": "StrTruncFontTooltip(INT nANForTooltip, STRING sText, STRING sFont, INT nPixels)",
        "nANForTooltip": "nANForTooltip",
        "sText": "sText",
        "sFont": "sFont",
        "nPixels": "nPixels"
      },
      "helpPath": "StrTruncFontTooltip.htm"
    },
    "strupper": {
      "name": "StrUpper",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Converts a string to uppercase.",
      "returns": "The string (as uppercase).",
      "paramDocs": {
        "String": "StrUpper(String)"
      },
      "helpPath": "StrUpper.html"
    },
    "strword": {
      "name": "StrWord",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Gets the first word from a string. The word is removed from the string to allow the function to be repeated.",
      "returns": "A string containing the first word from String .",
      "paramDocs": {
        "String": "StrWord(String)"
      },
      "helpPath": "StrWord.html"
    },
    "subscriptionaddcallback": {
      "name": "SubscriptionAddCallback",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle",
        "sCallback"
      ],
      "doc": "Adds a function callback to a tag subscription.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "iHandle, sCallback": "SubscriptionAddCallback(iHandle, sCallback)",
        "iHandle": "iHandle",
        "sCallback": "sCallback"
      },
      "helpPath": "SubscriptionAddCallback.html"
    },
    "subscriptiongetattribute": {
      "name": "SubscriptionGetAttribute",
      "returnType": "STRING",
      "params": [
        "iHandle",
        "sAttribute [",
        "iOffset]"
      ],
      "doc": "Reads the specified attribute value of a subscribed tag.",
      "returns": "String representation of the cached value for a subscribed tag. On error, an empty string and an error is set.",
      "paramDocs": {
        "iHandle, sAttribute [, iOffset]": "SubscriptionGetAttribute(iHandle, sAttribute [, iOffset] )",
        "iHandle": "iHandle",
        "sAttribute": "sAttribute",
        "iOffset": "iOffset"
      },
      "helpPath": "SubscriptionGetAttribute.html"
    },
    "subscriptiongetinfo": {
      "name": "SubscriptionGetInfo",
      "returnType": "STRING",
      "params": [
        "iHandle",
        "sAttribute"
      ],
      "doc": "Reads the specified text information about a subscribed tag.",
      "returns": "String representation of the requested information for a subscribed tag. On error, returns an empty string and an error is set.",
      "paramDocs": {
        "iHandle, sAttribute": "SubscriptionGetInfo(iHandle, sAttribute )",
        "iHandle": "iHandle",
        "sAttribute": "sAttribute"
      },
      "helpPath": "SubscriptionGetInfo.html"
    },
    "subscriptiongetquality": {
      "name": "SubscriptionGetQuality",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle"
      ],
      "doc": "Reads quality of a subscribed tag.",
      "returns": "The quality for a subscribed tag. On error, QUAL_BAD.",
      "paramDocs": {
        "iHandle": "SubscriptionGetQuality(iHandle )"
      },
      "helpPath": "SubscriptionGetQuality.html"
    },
    "subscriptiongettag": {
      "name": "SubscriptionGetTag",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle",
        "sOffset"
      ],
      "doc": "Reads a value, quality and timestamps of a subscribed tag.",
      "returns": "Returns a value, quality and timestamps of a subscribed tag. The type of the returned value depends on a type of the subscribed tag. The quality and timestamps of the subscribed tag are read and passed with the returned value.",
      "paramDocs": {
        "iHandle, sOffset": "SubscriptionGetTag(iHandle, sOffset )",
        "iHandle": "iHandle",
        "sOffset": "sOffset"
      },
      "helpPath": "SubscriptionGetTag.html"
    },
    "subscriptiongettimestamp": {
      "name": "SubscriptionGetTimestamp",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle",
        "sAttribute"
      ],
      "doc": "Reads the specified timestamp of a subscribed tag.",
      "returns": "The requested timestamp for a subscribed tag. On error, 0 (INVALID TIMESTAMP).",
      "paramDocs": {
        "iHandle, sAttribute": "SubscriptionGetTimestamp(iHandle, sAttribute )",
        "iHandle": "iHandle",
        "sAttribute": "sAttribute"
      },
      "helpPath": "SubscriptionGetTimestamp.html"
    },
    "subscriptiongetvalue": {
      "name": "SubscriptionGetValue",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle",
        "sOffset"
      ],
      "doc": "Reads a value of a subscribed tag.",
      "returns": "Returns a value of a subscribed tag. The type of the returned variable depends on a type of the subscribed tag. The quality and timestamps of the subscribed tag are not read i.e. quality of the returned value can be consider as GOOD and its timestamps as 0 (INVALID TIMESTAMP).",
      "paramDocs": {
        "iHandle, sOffset": "SubscriptionGetValue(iHandle, sOffset )",
        "iHandle": "iHandle",
        "sOffset": "sOffset"
      },
      "helpPath": "SubscriptionGetValue.html"
    },
    "subscriptionremovecallback": {
      "name": "SubscriptionRemoveCallback",
      "returnType": "UNKNOWN",
      "params": [
        "iHandle",
        "sCallback"
      ],
      "doc": "Removes a function callback from a tag subscription.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "iHandle, sCallback": "SubscriptionRemoveCallback(iHandle, sCallback)",
        "iHandle": "iHandle",
        "sCallback": "sCallback"
      },
      "helpPath": "SubscriptionRemoveCallback.html"
    },
    "switchconfig": {
      "name": "SwitchConfig",
      "returnType": "UNKNOWN",
      "params": [
        "nApp"
      ],
      "doc": "Switches focus to a specific Plant SCADA configuration application.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "Graphics Builder (CTDRAW32.EXE)",
        "2": "Not in Use",
        "3": "Plant SCADA Studio (CITECTIDE.EXE)",
        "4": "Cicode Editor (CTCICODE.EXE)",
        "nApp": "SwitchConfig(nApp)"
      },
      "helpPath": "SwitchConfig.html"
    },
    "systime": {
      "name": "SysTime",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the internal system millisecond counter. The counter is not based on time, but counts from 0 up to the maximum integer value and then back to 0.",
      "returns": "The Plant SCADA internal system millisecond counter (as an integer).",
      "paramDocs": {},
      "helpPath": "SysTime.html"
    },
    "systimedelta": {
      "name": "SysTimeDelta",
      "returnType": "UNKNOWN",
      "params": [
        "Start"
      ],
      "doc": "Calculates the time difference between a start time and the current time, and updates the start time to the current time.",
      "returns": "The time difference from a start time and the current time.",
      "paramDocs": {
        "Start": "SysTimeDelta(Start)"
      },
      "helpPath": "SysTimeDelta.html"
    },
    "tablelookup": {
      "name": "TableLookup",
      "returnType": "UNKNOWN",
      "params": [
        "Table",
        "Size",
        "Value"
      ],
      "doc": "Searches for a value in a table, and returns the position (offset) of the value in the table.",
      "returns": "The offset to the table value, or -1 if the value does not exist.",
      "paramDocs": {
        "Table, Size, Value": "TableLookup(Table, Size, Value)",
        "Table": "The table to search. The table needs to be an array of real numbers. Must be a Real type variable.",
        "Size": "The maximum number of items in the table.",
        "Value": "The value to locate."
      },
      "helpPath": "TableLookup.html"
    },
    "tablemath": {
      "name": "TableMath",
      "returnType": "UNKNOWN",
      "params": [
        "Table",
        "Size",
        "Command [",
        "Mode]"
      ],
      "doc": "Performs mathematical operations on a table of real (floating-point) numbers.",
      "returns": "Returns the value related to the requested mathematical operation performed on the table (Minimum, Maximum, Average, Standard deviation or Total).\\",
      "paramDocs": {
        "0": "Minimum",
        "1": "Maximum",
        "2": "Average",
        "3": "Standard deviation",
        "4": "Total",
        "Mode": "Performs mathematical operations on a table of real (floating-point) numbers. This function supports minimum, maximum, average, standard deviation, and total operations on a table of values. Use this function for operating on tables returned from the trend system with the TrnGetTable() function. You can set the Mode to either accept or ignore invalid or gated data returned from TrnGetTable().",
        "Table, Size, Command [, Mode]": "TableMath(Table, Size, Command [, Mode] )",
        "Table": "Any table of floating-point numbers. Must be a Real type variable.",
        "Size": "The maximum number of items in the table.",
        "Command": "The mathematical operation to perform on the table:"
      },
      "helpPath": "TableMath.html"
    },
    "tableshift": {
      "name": "TableShift",
      "returnType": "UNKNOWN",
      "params": [
        "Table",
        "Size",
        "Count"
      ],
      "doc": "Shifts table items in a table by a number of positions.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Table, Size, Count": "TableShift(Table, Size, Count)",
        "Table": "The table to shift, an array of real numbers. Must be a Real type variable.",
        "Size": "The maximum number of items in the table.",
        "Count": "The number of positions to shift the table items. A negative Count moves items to the right and a positive Count moves items to the left."
      },
      "helpPath": "TableShift.html"
    },
    "tagbrowseclose": {
      "name": "TagBrowseClose",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The TagBrowseClose function terminates an active data browse session and cleans up resources associated with the session.",
      "returns": "0 if successful -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session)": "INT TagBrowseClose(LONG Session)"
      },
      "helpPath": "TagBrowseClose.html"
    },
    "tagbrowsefirst": {
      "name": "TagBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The TagBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 if successful -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session)": "INT TagBrowseFirst(LONG Session)",
        "Session": "The handle to a browse session previously returned by a TagBrowseOpen call."
      },
      "helpPath": "TagBrowseFirst.html"
    },
    "tagbrowsegetfield": {
      "name": "TagBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session",
        "STRING FieldName"
      ],
      "doc": "The TagBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string if successful. An empty string may or may not be an indication that an error has been detected. The last error should be checked in this instance to determine if an error has actually occurred. -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session, STRING FieldName)": "STRING TagBrowseGetField(LONG Session, STRING FieldName)",
        "Session": "The handle to a browse session previously returned by a TagBrowseOpen call.",
        "Fieldname": "The name of the field that references the value to be returned. Supported fields are:"
      },
      "helpPath": "TagBrowseGetField.html"
    },
    "tagbrowsenext": {
      "name": "TagBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The TagBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 if successful -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session)": "INT TagBrowseNext(LONG Session)",
        "Session": "The handle to a browse session previously returned by a TagBrowseOpen call."
      },
      "helpPath": "TagBrowseNext.html"
    },
    "tagbrowsenumrecords": {
      "name": "TagBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The TagBrowseNumRecords function gets the number of records for a given browsing session.",
      "returns": "Number of records (INT) if successful -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session)": "INT TagBrowseNumRecords(LONG Session)"
      },
      "helpPath": "TagBrowseNumRecords.html"
    },
    "tagbrowseopen": {
      "name": "TagBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields",
        "STRING Sort[",
        "STRING Clusters]"
      ],
      "doc": "The TagBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "Session handle (LONG) if successful, -1 if unsuccessful.",
      "paramDocs": {
        "(STRING Filter, STRING Fields, STRING Sort[, STRING Clusters])": "LONG TagBrowseOpen(STRING Filter, STRING Fields, STRING Sort[, STRING Clusters])",
        "Field": "Comma separated list of record fields to be returned during the browsing session. An empty field string will return all possible fields.",
        "Sort": "Comma delimited list of record fields to be returned in order of sorting preferences (each with an indication of whether the sort is A - ascending or D - descending). For example \"TYPE:D\". By default tag browsing records are sorted by the tag primary key Cluster.TagName. which is implicitly appended to the list of sorting fields, since all the other fields may end up not being unique."
      },
      "helpPath": "TagBrowseOpen.html"
    },
    "tagbrowseprev": {
      "name": "TagBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "LONG Session"
      ],
      "doc": "The TagBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 if successful -1 if unsuccessful.",
      "paramDocs": {
        "(LONG Session)": "INT TagBrowsePrev(LONG Session)",
        "Session": "The handle to a browse session previously returned by a TagBrowseOpen call."
      },
      "helpPath": "TagBrowsePrev.html"
    },
    "tagdebug": {
      "name": "TagDebug",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a dialog which allows you to select from a list of the configured variable tags in your system.",
      "returns": "The name of the tag entered in the dialog.",
      "paramDocs": {},
      "helpPath": "TagDebug.html"
    },
    "tagdebugform": {
      "name": "TagDebugForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "The TagDebugForm Cicode function displays a dialog that allows you to select a variable tag and perform some basic read/write operations on it.",
      "returns": "The name of the tag entered in the dialog.",
      "paramDocs": {},
      "helpPath": "TagDebugForm.html"
    },
    "tageventformat": {
      "name": "TagEventFormat",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns a handle to the format of the data used by the TagEventQueue().",
      "returns": "The format handle.",
      "paramDocs": {},
      "helpPath": "TagEventFormat.html"
    },
    "tageventqueue": {
      "name": "TagEventQueue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Opens the tag update event queue. The I/O server writes events into this queue as they are processed.",
      "returns": "The queue handle of the Tag Update Event queue.",
      "paramDocs": {},
      "helpPath": "TagEventQueue.html"
    },
    "taggetproperty": {
      "name": "TagGetProperty",
      "returnType": "STRING",
      "params": [
        "STRING Name",
        "STRING Property [",
        "INT CachedMode] [",
        "STRING ClusterName]"
      ],
      "doc": "This function reads a property of a variable tag from the data source. This function replaces TagInfo.",
      "returns": "String representation of the property of the tag. If unsuccessful, an empty string and an error code is set.",
      "paramDocs": {
        "Name": "STRING TagGetProperty(STRING Name, STRING Property [, INT CachedMode] [, STRING ClusterName] )",
        "Property": "The property to read. Property names are case sensitive. Supported properties are:",
        "Address": "Returns the configured address of the tag (as specified in the variable tags form).",
        "ArraySize": "Array size of the associated tag. Returns 1 for non-array types.",
        "ClusterName": "Name of the cluster the tag resides on.",
        "DataBitWidth": "Number of bits used to store the value",
        "Description": "Tag description",
        "EngUnitsHigh": "Maximum scaled value",
        "EngUnitsLow": "Minimum scaled value",
        "Equipment": "Name of the equipment associated with the Tag.",
        "Format": "Format bit string. The format information is stored in the integer as follows:",
        "FormatDecPlaces": "Number of decimal places for default format",
        "FormatWidth": "Number of characters used in default format",
        "FullName": "Full name of the tag in the form cluster.tagname.",
        "Item": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "RangeHigh": "Maximum unscaled value",
        "RangeLow": "Minimum unscaled value",
        "TagName": "Name of the tag specified.",
        "Type": "General type of tag. Allowed values are:",
        "Units": "Engineering Units for example, %, mm, Volts.",
        "Custom1 ... Custom8": "User-defined strings.",
        "CachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "TagGetProperty.html"
    },
    "taggetscale": {
      "name": "TagGetScale",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "INT Percent",
        "INT EngUnits [",
        "INT CachedMode] [",
        "STRING ClusterName]"
      ],
      "doc": "Gets the value of a tag at a specified scale from the datasource.",
      "returns": "The scale of the tag (as a string).",
      "paramDocs": {
        "0": "Do not return the value with engineering units",
        "1": "Return the value with engineering units",
        "STRING Name, INT Percent, INT EngUnits [, INT CachedMode] [, STRING ClusterName]": "TagGetScale(STRING Name, INT Percent, INT EngUnits [, INT CachedMode] [, STRING ClusterName] )",
        "Name": "The name of the tag, or the equipment and item name of a variable tag (using equipment.item notation). The tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\".",
        "Percent": "The percentage of full scale of the returned value.",
        "EngUnits": "Flag to determine if the value is returned with engineering units:",
        "CachedMode": "Optional parameter that specifies from where to retrieve the value for the property.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagGetScale.html"
    },
    "taggetvalue": {
      "name": "TagGetValue",
      "returnType": "UNKNOWN",
      "params": [
        "STRING TagName [",
        "INT Item] [",
        "INT Index] [",
        "LONG PollTime] [",
        "INT ScaleMode] [",
        "REAL Deadband] [",
        "INT Lightweight] [",
        "LONG KeepAliveSeconds]"
      ],
      "doc": "Reads the value, quality and timestamp of a tag based on the tag subscription.",
      "returns": "Returns the value, quality and timestamp of a subscribed tag. The data type of the value returned depends on the type of the subscribed tag and also the tag extension. The quality and timestamp of the subscribed tag are read and passed with the value returned by the function.",
      "paramDocs": {
        "STRING TagName [, INT Item] [, INT Index] [, LONG PollTime] [, INT ScaleMode] [, REAL Deadband] [, INT Lightweight] [, LONG KeepAliveSeconds]": "TagGetValue(STRING TagName [, INT Item] [, INT Index] [, LONG PollTime] [, INT ScaleMode] [, REAL Deadband] [, INT Lightweight] [, LONG KeepAliveSeconds])",
        "TagName": "TagName",
        "Item": "Item",
        "Index": "Optional index for an array variable. If not specified, it has a default value of 0. Since the TagName parameter does not support array indexing, use the Index parameter to access an element in an array. Note that the address of the first element in an array is 0 (zero).",
        "PollTime": "PollTime",
        "ScaleMode": "ScaleMode",
        "Deadband": "Deadband",
        "Lightweight": "Lightweight",
        "KeepAliveSeconds": "KeepAliveSeconds"
      },
      "helpPath": "TagGetValue.htm"
    },
    "taginfo": {
      "name": "TagInfo",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "INT Type [",
        "STRING ClusterName] [",
        "INT CachedMode]"
      ],
      "doc": "Gets information about a variable tag. This function allows you to develop generic Cicode and Super Genies.",
      "returns": "The value of the information as a string.",
      "paramDocs": {
        "0": "The Tag name from the variables table. This is the same as sName argument. (Returned to be compatible with the AssInfo() function). An empty string is returned if Type is 0.",
        "1": "Engineering units",
        "2": "Raw zero scale",
        "3": "Raw full scale",
        "4": "Engineering zero scale",
        "5": "Engineering full scale",
        "6": "Width of the format",
        "7": "Number of decimal places of format",
        "8": "The Tag format as a long integer. The format information is stored in the integer as follows:",
        "9": "Logical Unit Number - I/O device number (for internal use)",
        "10": "Raw Type - Protocol's raw data type number for this tag. Type numbers are:",
        "11": "Bit Width - Tag's size in bits. For example, an INT is 16 bits",
        "12": "Unit Type - Protocol's unit type number for this tag",
        "13": "Unit Address - Tag's address after the protocol DBF's template is applied.",
        "14": "Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.",
        "15": "Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.",
        "16": "Comment - As defined in the variable tags list.",
        "17": "ClusterName of the tag. If the tag is not resolved, returns an empty string.",
        "18": "Full name (cluster.tagname) of the tag. If the tag is not resolved, returns an empty string.",
        "19": "Reserved for internal operation.",
        "20": "Configured Address of the tag. If the tag is not resolved, returns an empty string.",
        "21": "Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).",
        "22": "Name of the equipment associated with the Tag. If the tag is not resolved, returns an empty string.",
        "23": "General Type.",
        "24": "Reserved for internal use.",
        "25": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "26": "Custom 1 - a user-defined string.",
        "27": "Custom 2 - a user-defined string.",
        "28": "Custom 3 - a user-defined string.",
        "29": "Custom 4 - a user-defined string.",
        "30": "Custom 5 - a user-defined string.",
        "31": "Custom 6 - a user-defined string.",
        "32": "Custom 7 - a user-defined string.",
        "33": "Custom 8 - a user-defined string.",
        "STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode]": "STRING TagInfo(STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode] )",
        "Name": "The name of the tag or the equipment and item reference of a variable tag (using equipment.item notation) from which to get information. The tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Type": "The type of information to get:",
        "ClusterName": "ClusterName",
        "CachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "TagInfo.html"
    },
    "taginfoex": {
      "name": "TagInfoEx",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Name",
        "INT Type [",
        "STRING ClusterName] [",
        "INT CachedMode]"
      ],
      "doc": "This function replaces TagInfo and is identical in operation. It supports online changes.",
      "returns": "The value of the information as a string. If unsuccessful, an empty string is returned. The error code can be obtained by calling the IsError Cicode function.",
      "paramDocs": {
        "0": "The Tag name from the variables table. This is the same as the Name argument. (Returned to be compatible with the AssInfo() function).",
        "1": "Engineering units",
        "2": "Raw zero scale",
        "3": "Raw full scale",
        "4": "Engineering zero scale",
        "5": "Engineering full scale",
        "6": "Width of the format",
        "7": "Number of decimal places of format",
        "8": "The Tag format as a long integer. The format information is stored in the integer as follows:",
        "9": "Logical Unit Number - I/O device number (for internal use)",
        "10": "General Type - Protocol's general data type number for this tag. Type numbers are:",
        "11": "Bit Width - Tag's size in bits. For example, an INT is 16 bits",
        "12": "Unit Type - Protocol's unit type number for this tag",
        "13": "Unit Address - Tag's address after the protocol DBF's template is applied.",
        "14": "Unit Count - Array size. For example, if the tag's address is I1[50], the unit count is 50.",
        "15": "Record Number - Tag's record number in variable.DBF - 1. That is, the first tag has a record number of 0.",
        "16": "Comment - As defined in the variable tags list.",
        "17": "ClusterName of the tag.",
        "18": "Full name (cluster.tagname) of the tag.",
        "19": "Reserved for internal operation.",
        "20": "Configured Address of the tag. If the tag is not resolved, returns an empty string.",
        "21": "Network Number - I/O device number (as defined by the Number field of the I/O Devices dialog).",
        "22": "Name of the equipment associated with the Tag. If the tag is not resolved, returns an empty string.",
        "23": "Reserved for internal use.",
        "24": "Reserved for internal use.",
        "25": "Name of the equipment item associated with the Tag. If the tag is not resolved, returns an empty string.",
        "26": "Custom 1 - a user-defined string.",
        "27": "Custom 2 - a user-defined string.",
        "28": "Custom 3 - a user-defined string.",
        "29": "Custom 4 - a user-defined string.",
        "30": "Custom 5 - a user-defined string.",
        "31": "Custom 6 - a user-defined string.",
        "32": "Custom 7 - a user-defined string.",
        "33": "Custom 8 - a user-defined string.",
        "STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode]": "STRING TagInfoEx(STRING Name, INT Type [, STRING ClusterName] [, INT CachedMode] )",
        "Name": "The name of the tag or the equipment and item name of a variable tag (using equipment.item notation) from which to get information. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Type": "The type of information to get:",
        "ClusterName": "ClusterName",
        "CachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "TagInfoEx.html"
    },
    "tagramp": {
      "name": "TagRamp",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "INT PercentInc"
      ],
      "doc": "This function will increment a Tag by the amount defined by iPercentInc. It is often used for incrementing a tag while a button is held down.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Tag, INT PercentInc": "TagRamp(STRING Tag, INT PercentInc)",
        "Tag": "The variable tag name (or alarm property name), as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\".",
        "PercentInc": "The percentage by which you want to increase the value of the variable. A negative number will decrease the variable. The increment is calculated as a percentage of the full range."
      },
      "helpPath": "TagRamp.html"
    },
    "tagrdbreload": {
      "name": "TagRDBReload",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Works in conjunction with the TagInfo function. Reloads the variable tag database so when TagInfo is called it picks up all online changes to the tag database.",
      "returns": "Returns 1 if the tag database was successfully reloaded, and 0 if the tag database fails to load.",
      "paramDocs": {},
      "helpPath": "TagRDBReload.html"
    },
    "tagread": {
      "name": "TagRead",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "INT nOffset [",
        "STRING ClusterName]]"
      ],
      "doc": "Reads a variable from an I/O device or a local variable.",
      "paramDocs": {
        "(STRING Tag [, INT nOffset [, STRING ClusterName]])": "TagRead(STRING Tag [, INT nOffset [, STRING ClusterName]])",
        "Tag": "A string that can be one of the following:",
        "Offset": "The offset for an array variable. This argument is optional - if not specified, it has a default value of 0.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagRead.html"
    },
    "tagreadex": {
      "name": "TagReadEx",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "INT Offset [",
        "STRING ClusterName]]"
      ],
      "doc": "Reads the value, quality or timestamp of a particular tag from the I/O device.",
      "returns": "The function can return:",
      "paramDocs": {
        "STRING Tag [, INT Offset [, STRING ClusterName]]": "TagReadEx(STRING Tag [, INT Offset [, STRING ClusterName]])",
        "Tag": "A string that can be one of the following:",
        "Offset": "The offset for an array variable. This argument is optional - if not specified, it has a default value of 0.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagReadEx.html"
    },
    "tagresolve": {
      "name": "TagResolve",
      "returnType": "UNKNOWN",
      "params": [
        "STRING TagName"
      ],
      "doc": "This function can be used to increment a reference count on a tag to keep it resolved, making it readily available to a client.",
      "returns": "The returned integer is a handle to the tag that has been resolved, or -1 if an error occurred.",
      "paramDocs": {
        "(STRING TagName)": "TagResolve(STRING TagName)",
        "TagName": "The name of the tag or the equipment and item name (using equipment.item notation) associated with that tag to resolve (in the format \"clusterName.tagName\" or \"clusterName.equipment.item\" if you need to specify a cluster)."
      },
      "helpPath": "TagResolve.html"
    },
    "tagscalestr": {
      "name": "TagScaleStr",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "INT Percent",
        "INT EngUnits [",
        "STRING ClusterName] [",
        "INT CachedMode]"
      ],
      "doc": "Gets the value of a tag at a specified scale.",
      "returns": "The scale of the tag (as a string).",
      "paramDocs": {
        "0": "Return the value without engineering units",
        "1": "Return the value with engineering units",
        "STRING Tag, INT Percent , INT EngUnits [,STRING ClusterName] [,INT CachedMode]": "STRING TagScaleStr(STRING Tag, INT Percent , INT EngUnits [,STRING ClusterName] [,INT CachedMode] )",
        "Tag": "The name of the tag, or the equipment and item name of a variable tag (using equipment.item notation).",
        "Percent": "The percentage of full scale of the returned value.",
        "EngUnits": "Determines if the value is returned with engineering units:",
        "CachedMode": "Optional parameter that specifies from where to retrieve the value for the property."
      },
      "helpPath": "TagScaleStr.html"
    },
    "tagsetoverridebad": {
      "name": "TagSetOverrideBad",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "INT Synch [",
        "STRING ClusterName]]"
      ],
      "doc": "Sets a quality Override element for a specified tag to Bad Non Specific.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(STRING Tag [,INT Synch [, STRING ClusterName]])": "TagSetOverrideBad(STRING Tag [,INT Synch [, STRING ClusterName]])",
        "Tag": "The variable tag name or the equipment and item name (using equipment.item notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Synch": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to True, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
        "Override Mode": "Setting the value of the OverrideMode element to anything other than 3 will overwrite the quality that has been applied to the Override element using this function. See the example below. Also see the topic Override Mode in Plant SCADA's Scheduler documentation."
      },
      "helpPath": "TagSetOverrideBad.html"
    },
    "tagsetoverridegood": {
      "name": "TagSetOverrideGood",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "INT Synch [",
        "STRING ClusterName]]"
      ],
      "doc": "Sets a quality Override element for a specified tag to Good Non Specific.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Tag": "The variable tag name or the equipment and item name (using <equipment>.<item> notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Synch": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to True, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
        "Override Mode": "Setting the value of the OverrideMode element to anything other than 3 will overwrite the quality that has been applied to the Override element using this function. See the example below. Also see the topic Override Mode in Plant SCADA's Scheduler documentation."
      },
      "helpPath": "TagSetOverrideGood.html"
    },
    "tagsetoverridequality": {
      "name": "TagSetOverrideQuality",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "QUALITY qualityNew [",
        "INT Synch [",
        "STRING ClusterName]]"
      ],
      "doc": "Sets a quality of Override element for a specified tag.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(STRING Tag, QUALITY qualityNew [,INT Synch [, STRING ClusterName]])": "TagSetOverrideQuality(STRING Tag, QUALITY qualityNew [,INT Synch [, STRING ClusterName]])",
        "Tag": "Tag",
        "qualityNew": "qualityNew",
        "Synch": "Synch",
        "OverrideMode": "Setting the value of the OverrideMode element to anything other than 3 will overwrite the quality that has been applied to the Override element using this function. See the example below. Also see the topicOverrideModeinPlant SCADA's Scheduler documentation."
      },
      "helpPath": "TagSetOverrideQuality.html"
    },
    "tagsetoverrideuncertain": {
      "name": "TagSetOverrideUncertain",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag [",
        "INT Synch [",
        "STRING ClusterName]]"
      ],
      "doc": "Sets a quality Override element for a specified tag to Uncertain Non Specific.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "(STRING Tag [,INT Synch [, STRING ClusterName]])": "TagSetOverrideUncertain(STRING Tag [,INT Synch [, STRING ClusterName]])",
        "Tag": "The variable tag name or the equipment and item name (using equipment.item notation) associated with that tag as a string. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Synch": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). By default, this parameter is set to True, synchronous (blocking), and the function will wait until the write has completed and returned from the server before further code execution. If you specify this parameter the other parameters need to be explicitly specified.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks.",
        "OverrideMode": "Setting the value of the OverrideMode element to anything other than 3 will overwrite the quality that has been applied to the Override element using this function. See the example below. Also see the topicOverrideModeinPlant SCADA's Scheduler documentation."
      },
      "helpPath": "TagSetOverrideUncertain.html"
    },
    "tagsubscribe": {
      "name": "TagSubscribe",
      "returnType": "UNKNOWN",
      "params": [
        "STRING TagName [",
        "INT PollTime] [",
        "STRING ScaleMode] [",
        "REAL Deadband] [",
        "STRING Callback] [",
        "INT Lightweight] [",
        "INT NoUpdateForDuplicateValues]"
      ],
      "doc": "Subscribes a tag so that Cicode functions can be called when a tag's value changes.",
      "returns": "Integer representing the subscription handle that can be used to read values, hook to events or unsubscribe. If unsuccessful, -1 is returned and an error is set. Even though a subscription handle is returned immediately, it can't be used to get attributes until the subscription has been confirmed as this is an asynchronous Cicode function call. The typical Cicode error is 423 when a subscription handled is used too soon. We recommend the use of a callback function or the direct use of the tag extension, e.g. <tag>.VT",
      "paramDocs": {
        "STRING TagName [, INT PollTime] [, STRING ScaleMode] [, REAL Deadband] [, STRING Callback] [, INT Lightweight] [, INT NoUpdateForDuplicateValues]": "TagSubscribe(STRING TagName [, INT PollTime] [, STRING ScaleMode] [, REAL Deadband] [, STRING Callback] [, INT Lightweight] [, INT NoUpdateForDuplicateValues])",
        "TagName": "TagName",
        "PollTime": "PollTime",
        "ScaleMode": "ScaleMode",
        "Deadband": "Deadband",
        "Callback": "Callback",
        "subsHandle": "FUNCTION evtHandler(INT subsHandle)...END",
        "Lightweight": "Lightweight",
        "NoUpdateForDuplicateValues": "NoUpdateForDuplicateValues"
      },
      "helpPath": "TagSubscribe.html"
    },
    "tagunresolve": {
      "name": "TagUnresolve",
      "returnType": "UNKNOWN",
      "params": [
        "INT iHandle"
      ],
      "doc": "This function is used to decrement a reference count implemented on a tag by TagResolve.",
      "returns": "The returned integer represents any error that occurs when the unresolve is attempted (0 for no error).",
      "paramDocs": {
        "(INT iHandle)": "TagUnresolve(INT iHandle)",
        "Handle": "The tag handle returned from a TagResolve() function call."
      },
      "helpPath": "TagUnresolve.html"
    },
    "tagunsubscribe": {
      "name": "TagUnsubscribe",
      "returnType": "UNKNOWN",
      "params": [
        "INT Handle"
      ],
      "doc": "Unsubscribes the tag subscription specified by the integer subscription handle that was returned from the TagSubscribe function.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT Handle": "TagUnsubscribe(INT Handle)",
        "Handle": "Handle"
      },
      "helpPath": "TagUnsubscribe.html"
    },
    "tagwrite": {
      "name": "TagWrite",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "STRING sValue [",
        "INT Offset] [",
        "INT Synch] [",
        "STRING ClusterName]"
      ],
      "doc": "Writes to an I/O device variable by specifying the variable tag name or the variable tag name and the name of the requested element having read/write access.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Tag, STRING sValue [, INT Offset] [, INT Synch] [, STRING ClusterName]": "TagWrite(STRING Tag, STRING sValue [, INT Offset] [, INT Synch] [, STRING ClusterName])",
        "Tag": "A string that can be one of the following:",
        "Value": "The value to be written to the I/O device variable. The value is specified as a string, however if an integer or real is used the compiler will convert it to a string. The function converts the string into the correct format, and then writes it to the variable.",
        "Offset": "Optional offset for an array variable. Default is 0.",
        "Synch": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, by default. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagWrite.html"
    },
    "tagwriteeventque": {
      "name": "TagWriteEventQue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Opens the tag write event queue. The TagWriteEventQue is a queue of data containing details of tag value changes initiated by the process.",
      "returns": "The handle of the tag write event queue, or -1 if the queue cannot be opened.",
      "paramDocs": {
        "TagWriteEventQue()": "TagWriteEventQue()",
        "Tag Functions": "Tag Functions"
      },
      "helpPath": "TagWriteEventQue.html"
    },
    "tagwriteintarray": {
      "name": "TagWriteIntArray",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "INT Length",
        "VAR LONG Values",
        "INT Offset",
        "INT Sync",
        "STRING ClusterName"
      ],
      "doc": "This function writes an array of integers to a tag.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Tag, INT Length, VAR LONG Values, INT Offset, INT Sync, STRING ClusterName": "TagWriteIntArray(STRING Tag, INT Length, VAR LONG Values, INT Offset, INT Sync, STRING ClusterName)",
        "Tag": "The string can refer to either: the variable tag name, the equipment and item name (using equipment.item notation) associated with that tag, the alarm name and the alarm property name, the tag name and the tag element name. If the element name is not specified, the writing will be performed to the Field VQT element. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Length": "The number of elements written to the tag.",
        "Value": "The element you select in the array to be the first. The array contains the values you are writing to the variable tag. See example below. Must be a Long type variable.",
        "Offset": "Optional offset inside the variable tag array where you start writing to. Default is 0.",
        "Sync": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, by default. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagWriteIntArray.html"
    },
    "tagwriterealarray": {
      "name": "TagWriteRealArray",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Tag",
        "INT Length",
        "VAR REAL Value [",
        "INT Offset] [",
        "INT Sync] [",
        "STRING ClusterName]"
      ],
      "doc": "This function writes an array of REAL values to a variable tag.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "STRING Tag, INT Length, VAR REAL Value [, INT Offset] [, INT Sync] [, STRING ClusterName]": "TagWriteRealArray(STRING Tag, INT Length, VAR REAL Value [, INT Offset] [, INT Sync] [, STRING ClusterName])",
        "Tag": "The string can refer to either: the variable tag name, the equipment and item name (using equipment.item notation) associated with that tag, the alarm name and the alarm property name, the tag name and the tag element name. If the element name is not specified, the writing will be performed to the Field VQT element. The name of the tag can be prefixed by the name of the cluster that is \"ClusterName.Tag\" or \"ClusterName.Equipment.Item\".",
        "Length": "The number of elements written to the tag.",
        "Value": "The element you select in the array to be the first. The array contains the values you are writing to the variable tag. See example below.",
        "Offset": "Optional offset inside the variable tag array where you start writing to. Default is 0.",
        "Sync": "An optional boolean argument that specifies whether the command is synchronous (blocking) or asynchronous (non- blocking). If it is specified as synchronous (blocking) the function will wait until the write has completed and returned from the server before further code execution. This parameter is \"False\", or asynchronous, by default. If you specify this parameter the rest of the parameters need to be explicitly specified, including nOffset which should be set as 0 if the tag is not an array tag.",
        "ClusterName": "Specifies the name of the cluster in which the Tag resides. The argument is enclosed in quotation marks."
      },
      "helpPath": "TagWriteRealArray.html"
    },
    "tan": {
      "name": "Tan",
      "returnType": "UNKNOWN",
      "params": [
        "Angle"
      ],
      "doc": "Calculates the trigonometric tangent of an angle.",
      "returns": "The tan of Angle.",
      "paramDocs": {
        "Angle": "Tan(Angle)"
      },
      "helpPath": "Tan.html"
    },
    "taskcall": {
      "name": "TaskCall",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sArgs"
      ],
      "doc": "Calls a Cicode function by specifying the function name and providing an arguments string.",
      "returns": "The result of the function call (as a string). If a void function is called, an empty string is returned. To see if an error occurred (such as an invalid function name or invalid arguments) call IsError()..",
      "paramDocs": {
        "(sName, sArgs)": "TaskCall(sName, sArgs)"
      },
      "helpPath": "TaskCall.html"
    },
    "taskcluster": {
      "name": "TaskCluster",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the name of the cluster context in which the current task is executing.",
      "returns": "The cluster name of the current context or an empty string if the task is executing without a cluster context.",
      "paramDocs": {},
      "helpPath": "TaskCluster.html"
    },
    "taskgetsignal": {
      "name": "TaskGetSignal",
      "returnType": "UNKNOWN",
      "params": [
        "Hnd"
      ],
      "doc": "Retrieves a value that indicates the signal that is currently set for a specific task.",
      "returns": "The value of the current signal. (0 (zero) represents normal operation, 1 indicates the task is stopped).",
      "paramDocs": {
        "Hnd": "TaskGetSignal(Hnd)"
      },
      "helpPath": "TaskGetSignal.html"
    },
    "taskhnd": {
      "name": "TaskHnd",
      "returnType": "UNKNOWN",
      "params": [
        "[sName]"
      ],
      "doc": "Gets the task handle of a specific task. You can then use the task handle with other task functions to control the task.",
      "returns": "The task handle, identifying the table where all data on the task is stored.",
      "paramDocs": {
        "[sName]": "TaskHnd( [sName] )",
        "sName": "The thread name of the task. The thread name is the name of the function that was passed to the TaskNew() function. For example, if. . ."
      },
      "helpPath": "TaskHnd.html"
    },
    "taskkill": {
      "name": "TaskKill",
      "returnType": "UNKNOWN",
      "params": [
        "hTask"
      ],
      "doc": "Kills a task. The Cicode task will be stopped and will not run again.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hTask": "TaskKill(hTask)"
      },
      "helpPath": "TaskKill.html"
    },
    "tasknew": {
      "name": "TaskNew",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sArg",
        "Mode [",
        "sClusterName]"
      ],
      "doc": "Creates a new Cicode task and returns the task handle.",
      "returns": "The task handle, or -1 if the task cannot be successfully created. The task handle identifies the table where data on the associated task is stored.",
      "paramDocs": {
        "0": "Task runs forever.",
        "1": "Task runs until the current page is changed.",
        "2": "Task runs until the current window is freed.",
        "4": "This mode is deprecated and not active. Currently, by default, task requests I/O device data before starting.",
        "8": "If the task already exists, the function will exit without launching the new task.",
        "16": "Task doesn't wait for necessary I/O device data and starts immediately.",
        "sName": "Creates a new Cicode task and returns the task handle. You pass the sName of the function (that creates the task) as a string, not as the function tag, and pass the arguments for that function in Arg. After the task is created, it runs in parallel to the calling task. The new task will run forever unless it returns from the function or is killed by another task.",
        "sName, sArg, Mode [, sClusterName]": "TaskNew(sName, sArg, Mode [, sClusterName] )",
        "sArg": "The set of arguments to be passed to the function. Individual arguments need to be separated by commas (,). Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If the string in quotes is not enclosed, then the string is only the first tag found. The entire set of arguments need to be enclosed in quotes (\"\").",
        "Mode": "The mode of the task:",
        "sClusterName": "The name of the cluster context to be applied to the new Cicode task. This is optional if you have one cluster or are resolving the task via the current cluster context. The argument is enclosed in quotation marks \"\". You may pass \"-\" as the ClusterName argument to run the requested Cicode task without a cluster context."
      },
      "helpPath": "TaskNew.html"
    },
    "tasknewex": {
      "name": "TaskNewEx",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sArg",
        "Mode",
        "SubscriptionRate [",
        "sClusterName]"
      ],
      "doc": "Creates a new Cicode task with an individual subscription rate and returns the task handle.",
      "returns": "The task handle, or -1 if the task cannot be successfully created. The task handle identifies the table where data on the associated task is stored.",
      "paramDocs": {
        "0": "Task runs forever.",
        "1": "Task runs until the current page is changed.",
        "2": "Task runs until the current window is freed.",
        "4": "This mode is deprecated and not active. Currently, by default, task requests all I/O device data before starting.",
        "8": "If the task already exists, the function will exit without launching the new task.",
        "16": "Task doesn't wait for necessary I/O device data and starts immediately.",
        "sName": "Creates a new Cicode task with an individual subscription rate and returns the task handle. You pass the sName of the function (that creates the task) as a string, not as the function tag, and pass the arguments for that function in Arg. After the task is created, it runs in parallel to the calling task. The new task will run forever with tags updated at the specified time interval unless it returns from the function or is killed by another task.",
        "sName, sArg, Mode, SubscriptionRate [, sClusterName]": "TaskNewEx(sName, sArg, Mode, SubscriptionRate [, sClusterName] )",
        "sArg": "The set of arguments to be passed to the function. Individual arguments need to be separated by commas (,). Enclose string arguments in quotes \"\" and use the string escape character (^) around strings enclosed within a string. If you do not enclose the string in quotes, then the string is only the first tag found. The entire set of arguments need to be enclosed in quotes (\"\").",
        "Mode": "The mode of the task:",
        "SubscriptionRate": "SubscriptionRate",
        "sClusterName": "The name of the cluster context to be applied to the new Cicode task. This is optional if you have one cluster or are resolving the task via the current cluster context. The argument is enclosed in quotation marks \"\". You may pass \"-\" as the ClusterName argument to run the requested Cicode task without a cluster context."
      },
      "helpPath": "TaskNewEx.html"
    },
    "taskresume": {
      "name": "TaskResume",
      "returnType": "UNKNOWN",
      "params": [
        "hTask"
      ],
      "doc": "Resumes a task that was suspended by the TaskSuspend() function. After a task is resumed, it runs on the next time-slice.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hTask": "TaskResume(hTask)"
      },
      "helpPath": "TaskResume.html"
    },
    "tasksetsignal": {
      "name": "TaskSetSignal",
      "returnType": "UNKNOWN",
      "params": [
        "Hnd",
        "nSignal"
      ],
      "doc": "Manually applies a signal to a specified task.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Hnd, nSignal": "TaskSetSignal(Hnd, nSignal)",
        "Hnd": "The task's handle. To retrieve this use the function TaskHnd().",
        "nSignal": "Allows you to signal a specified task. Set to 0 (zero) for normal operation, 1 to stop the task or any other number that represents a defined signal."
      },
      "helpPath": "TaskSetSignal.html"
    },
    "tasksuspend": {
      "name": "TaskSuspend",
      "returnType": "UNKNOWN",
      "params": [
        "hTask"
      ],
      "doc": "Suspends a task. The task will stop running and will start again only when TaskResume() is called.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hTask": "TaskSuspend(hTask)"
      },
      "helpPath": "TaskSuspend.html"
    },
    "testrandomwave": {
      "name": "TestRandomWave",
      "returnType": "UNKNOWN",
      "params": [
        "[Period] [",
        "Low] [",
        "High] [",
        "Offset]"
      ],
      "doc": "Generates a random wave. The height of the wave is restricted by minimum and maximum values.",
      "returns": "The value of the random wave.",
      "paramDocs": {
        "[Period] [, Low] [, High] [, Offset]": "TestRandomWave( [Period] [, Low] [, High] [, Offset] )",
        "Period": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
        "Low": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
        "High": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
        "Offset": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0."
      },
      "helpPath": "TestRandomWave.html"
    },
    "testsawwave": {
      "name": "TestSawWave",
      "returnType": "UNKNOWN",
      "params": [
        "[Period] [",
        "Low] [",
        "High] [",
        "Offset]"
      ],
      "doc": "Generates a saw wave. The height of the wave is restricted by minimum and maximum values.",
      "returns": "The value of the saw wave.",
      "paramDocs": {
        "[Period] [, Low] [, High] [, Offset]": "TestSawWave( [Period] [, Low] [, High] [, Offset] )",
        "Period": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
        "Low": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
        "High": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
        "Offset": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0."
      },
      "helpPath": "TestSawWave.html"
    },
    "testsinwave": {
      "name": "TestSinWave",
      "returnType": "UNKNOWN",
      "params": [
        "[Period] [",
        "Low] [",
        "High] [",
        "Offset]"
      ],
      "doc": "Generates a sine wave. The height of the wave is restricted by minimum and maximum values.",
      "returns": "The value of the sine wave.",
      "paramDocs": {
        "[Period] [, Low] [, High] [, Offset]": "TestSinWave( [Period] [, Low] [, High] [, Offset] )",
        "Period": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
        "Low": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
        "High": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
        "Offset": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0."
      },
      "helpPath": "TestSinWave.html"
    },
    "testsquarewave": {
      "name": "TestSquareWave",
      "returnType": "UNKNOWN",
      "params": [
        "[Period] [",
        "Low] [",
        "High] [",
        "Offset]"
      ],
      "doc": "Generates a square wave. The height of the wave is restricted by minimum and maximum values.",
      "returns": "The value of the square wave.",
      "paramDocs": {
        "[Period] [, Low] [, High] [, Offset]": "TestSquareWave( [Period] [, Low] [, High] [, Offset] )",
        "Period": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
        "Low": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
        "High": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
        "Offset": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0."
      },
      "helpPath": "TestSquareWave.html"
    },
    "testtriangwave": {
      "name": "TestTriangWave",
      "returnType": "UNKNOWN",
      "params": [
        "[Period] [",
        "Low] [",
        "High] [",
        "Offset]"
      ],
      "doc": "Generates a triangular wave. The height of the wave is restricted by minimum and maximum values.",
      "returns": "The value of the triangular wave.",
      "paramDocs": {
        "[Period] [, Low] [, High] [, Offset]": "TestTriangWave( [Period] [, Low] [, High] [, Offset] )",
        "Period": "The number of seconds required to generate one cycle of the wave. If no period is entered, the period has a default of 60.",
        "Low": "The lowest value of the wave. If no low value is entered, this value has a default of 0.",
        "High": "The highest value of the wave. If no high value is entered, this value has a default of 100.",
        "Offset": "The offset in seconds, to generate the wave. If no offset is entered, the offset has a default of 0."
      },
      "helpPath": "TestTriangWave.html"
    },
    "timecurrent": {
      "name": "TimeCurrent",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the current system time/date in time/date variable format.",
      "returns": "A time/date variable.",
      "paramDocs": {},
      "helpPath": "TimeCurrent.html"
    },
    "timehour": {
      "name": "TimeHour",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the hour value from a time/date variable.",
      "returns": "The hour (as an integer).",
      "paramDocs": {
        "Time": "The time/date variable."
      },
      "helpPath": "TimeHour.html"
    },
    "timeinfo": {
      "name": "TimeInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nInfo"
      ],
      "doc": "Returns the time format currently used on the Plant SCADA Server.",
      "returns": "Depending on the nInfo argument passed to the function, a string containing:",
      "paramDocs": {
        "1": "The current time hour format:",
        "2": "The current time delimiter.",
        "3": "The current morning time extension.",
        "4": "The current evening time extension.",
        "nInfo": "TimeInfo(nInfo)"
      },
      "helpPath": "TimeInfo.html"
    },
    "timeinttotimestamp": {
      "name": "TimeIntToTimestamp",
      "returnType": "UNKNOWN",
      "params": [
        "INT TimeInt [",
        "INT Millisecond [",
        "INT UTC]]"
      ],
      "doc": "Converts a time INTEGER which is represented as a number of seconds since 01/01/1970 to a TIMESTAMP.",
      "returns": "A TIMESTAMP variable or INVALID_TIMESTAMP if invalid.",
      "paramDocs": {
        "TimeInt": "The number of seconds since 01/01/1970.",
        "Millesecond": "The number of milliseconds since last second (optional).",
        "UTC": "Coordinated Universal Time (optional):"
      },
      "helpPath": "TimeIntToTimestamp.html"
    },
    "timemidnight": {
      "name": "TimeMidNight",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Returns the number of seconds between midnight on January 1, 1970, and the midnight immediately prior to the specified time/date.",
      "returns": "A time/date variable.",
      "paramDocs": {
        "Time": "TimeMidNight(Time)"
      },
      "helpPath": "TimeMidNight.html"
    },
    "timemin": {
      "name": "TimeMin",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the minutes value from a time/date variable.",
      "returns": "The minute (as an integer).",
      "paramDocs": {
        "Time": "TimeMin(Time)"
      },
      "helpPath": "TimeMin.html"
    },
    "timesec": {
      "name": "TimeSec",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Gets the seconds value from a time/date variable.",
      "returns": "The second (as an integer).",
      "paramDocs": {
        "Time": "TimeSec(Time)"
      },
      "helpPath": "TimeSec.html"
    },
    "timeset": {
      "name": "TimeSet",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Sets the new system time. You can set the time only on the computer which this function is called.",
      "returns": "The error status of the set",
      "paramDocs": {
        "Time": "TimeSet(Time)"
      },
      "helpPath": "TimeSet.html"
    },
    "timestampadd": {
      "name": "TimestampAdd",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP Timestamp",
        "INT Offset [",
        "INT Part]"
      ],
      "doc": "Adds an offset to a TIMESTAMP variable.",
      "returns": "The TIMESTAMP variable, or INVALID_TIMESTAMP if invalid.",
      "paramDocs": {
        "Timestamp": "The timestamp to which Offset will be added",
        "Offset": "The offset to add, expressed in units of the part parameter",
        "Part": "Indicates which part to add:"
      },
      "helpPath": "TimestampAdd.html"
    },
    "timestampcreate": {
      "name": "TimestampCreate",
      "returnType": "UNKNOWN",
      "params": [
        "INT Year",
        "INT Month",
        "INT Day",
        "INT Hour",
        "INT Minute",
        "INT Second",
        "INT Millisecond [",
        "INT bUtc]"
      ],
      "doc": "Returns a TIMESTAMP variable created from the parts.",
      "returns": "The composed TIMESTAMP variable, or INVALID_TIMESTAMP if invalid",
      "paramDocs": {
        "Timestamp": "The timestamp from which the part will be extracted.",
        "Year": "The year part.",
        "Month": "The month part.",
        "Day": "The day part.",
        "Hour": "The hour part.",
        "Minute": "The minute part.",
        "Second": "The second part.",
        "Millisecond": "The millisecond part.",
        "UTC": "Coordinated Universal Time (optional):"
      },
      "helpPath": "TimestampCreate.html"
    },
    "timestampcurrent": {
      "name": "TimestampCurrent",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Return the current system date and time as a TIMESTAMP variable.",
      "returns": "A TIMESTAMP variable containing the current system date and time.",
      "paramDocs": {},
      "helpPath": "TimestampCurrent.html"
    },
    "timestampdifference": {
      "name": "TimestampDifference",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns the difference between two TIMESTAMP variables as a number of milliseconds.",
      "returns": "The time period between Timestamp1 and Timestamp2. The value is equal or greater than zero. If error, returns 0 with an error code.",
      "paramDocs": {
        "Timestamp 1": "The TIMESTAMP variable 1.",
        "Timestamp 2": "The TIMESTAMP variable 2.",
        "Part": "The type of time units being used for the result:",
        "bCumulative": "Defines how to pass results which values are greater than their time units (see example below)."
      },
      "helpPath": "TimestampDifference.html"
    },
    "timestampformat": {
      "name": "TimestampFormat",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP Timestamp",
        "STRING Format [",
        "INT UTC]"
      ],
      "doc": "Formats a TIMESTAMP variable into a string.",
      "returns": "A string containing the converted time/date, or an empty string if invalid.",
      "paramDocs": {
        "Timestamp": "The timestamp variable.",
        "Format": "The format of the string is the same as .NET Framework DateTime format. Specifically be reminded that the format is case sensitive. For example 'MM' is the zero padded month number, whereas 'mm' is the zero padded current minute within the hour. Therefore no Year, Day or Seconds will be displayed if they are specified in uppercase as: YYYY, DD, SS. The correct display will only occur when they are specified in lowercase as: yyyy, dd, ss.",
        "UTC": "Coordinated Universal Time (optional):"
      },
      "helpPath": "TimestampFormat.html"
    },
    "timestampgetpart": {
      "name": "TimestampGetPart",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP Timestamp",
        "INT Part [",
        "INT bUtc]"
      ],
      "doc": "Returns one part (year, month, day, etc) of the TIMESTAMP variable.",
      "returns": "The required part of the TIMESTAMP variable.",
      "paramDocs": {
        "Timestamp": "The timestamp from which the part will be extracted.",
        "Part": "Indicates which part to extract:",
        "UTC": "Coordinated Universal Time (optional):"
      },
      "helpPath": "TimestampGetPart.html"
    },
    "timestampsub": {
      "name": "TimestampSub",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP Timestamp",
        "INT Offset [",
        "INT Part]"
      ],
      "doc": "Subtracts an offset from a TIMESTAMP variable.",
      "returns": "The TIMESTAMP variable, or INVALID_TIMESTAMP if invalid.",
      "paramDocs": {
        "Timestamp": "The timestamp to which Offset will be subtracted",
        "Offset": "The offset to subtract, expressed in units of the part parameter",
        "Part": "Indicates which part to subtract:"
      },
      "helpPath": "TimestampSub.html"
    },
    "timestamptostr": {
      "name": "TimestampToStr",
      "returnType": "UNKNOWN",
      "params": [
        "Timestamp",
        "INT Format [",
        "INT UTC]"
      ],
      "doc": "Converts a TIMESTAMP variable into a string.",
      "returns": "A string containing the converted time/date or period variable, or an empty string if invalid.",
      "paramDocs": {
        "Timestamp": "Specifies the TIMESTAMP variable.",
        "Format": "The format number determines which of date/time patterns are used for formatting returned string. Date/time patterns are defined in regional settings on a particular computer and can vary depend on national or individual preferences. The possible format numbers together with examples based on en-US regional settings are listed below:",
        "UTC (optional - short for Universal Time Coordinate)": "UTC (optional - short for Universal Time Coordinate):"
      },
      "helpPath": "TimestampToStr.html"
    },
    "timestamptotimeint": {
      "name": "TimestampToTimeInt",
      "returnType": "UNKNOWN",
      "params": [
        "TIMESTAMP Timestamp [",
        "INT UTC]"
      ],
      "doc": "Converts a TIMESTAMP variable into a time INTEGER which is represented as a number of seconds since 01/01/1970.",
      "returns": "Time as a number of seconds since 01/01/1970 in UTC or local time depending on the last input parameter,-1 if invalid.",
      "paramDocs": {
        "Timestamp": "The timestamp variable.",
        "UTC": "Coordinated Universal Time (optional):"
      },
      "helpPath": "TimestampToTimeInt.html"
    },
    "timetooledate": {
      "name": "TimeToOLEDate",
      "returnType": "UNKNOWN",
      "params": [
        "Time",
        "Local"
      ],
      "doc": "Converts a time/date value to an OLE DATE value (this should be stored in a REAL).",
      "returns": "Returns an OLE date value.",
      "paramDocs": {
        "Time, Local": "TimeToOLEDate(Time, Local)",
        "Time": "Time/date variable.",
        "Local": "0 - The return value is output as UTC time."
      },
      "helpPath": "TimeToOLEDate.html"
    },
    "timetostr": {
      "name": "TimeToStr",
      "returnType": "UNKNOWN",
      "params": [
        "Time",
        "Format [",
        "UTC]"
      ],
      "doc": "Converts a time/date variable into a string. Use this function for calculating time differences or run times, and so on.",
      "returns": "A string containing the converted time/date or period variable, or an empty string if invalid.",
      "paramDocs": {
        "0": "Short time format, hh:mm AM/PM.",
        "1": "Long time format, hh:mm:ss AM/PM.",
        "2": "Short date format, based on the system locale setting. For example, dd/mm/yy for English (Australia); mm/dd/yy for English (United States); or dd.mm.yy for German (Germany).",
        "3": "Long date format, day month year.",
        "4": "Time and date, weekday month day year hh:mm:ss AM/PM.",
        "5": "Long time period, hh:mm:ss. Time needs to be in seconds.",
        "6": "Millisecond time period, hh:mm:ss.xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.",
        "7": "Short time period, hh:mm. Time needs to be in seconds.",
        "8": "Long time period, \"xxxxx Days hh Hours mm min ss sec\". Time needs to be in seconds.",
        "9": "Extended date format, based on the system locale setting. For example, dd/mm/yyyy for English (Australia); mm/dd/yyyy for English (United States); or dd.mm.yyyy for German (Germany).",
        "10": "Local TimeDate format, yyyy-mm-dd hh:mm:ss",
        "11": "Time of Day, hh:mm:ss tt format with no date",
        "Format": "Converts a time/date variable into a string. Use this function for calculating time differences or run times, and so on. Set Format to 6 to convert time periods that are in milliseconds, such as the times that are returned from the SysTime() and SysTimeDelta() functions.",
        "Time, Format [, UTC]": "TimeToStr(Time, Format [, UTC] )",
        "Time": "The time/date variable.",
        "UTC": "Coordinated Universal Time (optional)"
      },
      "helpPath": "TimeToStr.html"
    },
    "timeutcoffset": {
      "name": "TimeUTCOffset",
      "returnType": "UNKNOWN",
      "params": [
        "Time"
      ],
      "doc": "Determines the local time bias from UTC that was in force at a specified time.",
      "returns": "The local time bias in seconds.",
      "paramDocs": {
        "Time": "TimeUTCOffset(Time)"
      },
      "helpPath": "TimeUTCOffset.html"
    },
    "time": {
      "name": "Time",
      "returnType": "UNKNOWN",
      "params": [
        "[Format]"
      ],
      "doc": "Gets the current time in string format.",
      "returns": "The current time (as a string).",
      "paramDocs": {
        "0": "Short time format, hh:mm AM/PM",
        "1": "Long time format., hh:mm:ss AM/PM",
        "[Format]": "Time( [Format] )",
        "Format": "The format of the time:"
      },
      "helpPath": "Time_CIREF.html"
    },
    "toggle": {
      "name": "Toggle",
      "returnType": "UNKNOWN",
      "params": [
        "sTag"
      ],
      "doc": "Toggles a digital tag on or off. If the variable tag is ON (1), this function will turn it OFF.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTag": "Toggle(sTag)"
      },
      "helpPath": "Toggle.html"
    },
    "tracemsg": {
      "name": "TraceMsg",
      "returnType": "UNKNOWN",
      "params": [
        "String"
      ],
      "doc": "Displays a message in the Kernel and Debugger debug windows.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "String": "TraceMsg(String)"
      },
      "helpPath": "TraceMsg.html"
    },
    "trenddspcursorcomment": {
      "name": "TrendDspCursorComment",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Displays the Trend Comment for the currently selected pen on the displayed trend graph.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN": "TrendDspCursorComment(nAN)"
      },
      "helpPath": "TrendDspCursorComment.html"
    },
    "trenddspcursorscale": {
      "name": "TrendDspCursorScale",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Percent"
      ],
      "doc": "Displays a scale value for the current pen in the current pen font.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Percent": "TrendDspCursorScale(nAN, Percent)",
        "nAN": "The AN of the trend.",
        "Percent": "The percentage of full scale to display for the current pen, as an integer."
      },
      "helpPath": "TrendDspCursorScale.html"
    },
    "trenddspcursortag": {
      "name": "TrendDspCursorTag",
      "returnType": "UNKNOWN",
      "params": [
        "AN [",
        "Mode]"
      ],
      "doc": "Displays the trend tag name of the current pen in the pen font.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "AN [, Mode] )": "TrendDspCursorTag(AN [, Mode] )",
        "AN": "The AN of the trend.",
        "Mode": "An optional argument used to specify whether the trend tag name is displayed with a cluster prefix. Set:"
      },
      "helpPath": "TrendDspCursorTag.html"
    },
    "trenddspcursortime": {
      "name": "TrendDspCursorTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Format"
      ],
      "doc": "Displays the cursor time of the current pen in the current pen font.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Short time format, hh:mm AM/PM.",
        "1": "Long time format, hh:mm:ss AM/PM.",
        "2": "Short date format, dd/mm/yy.",
        "3": "Long date format, day month year.",
        "4": "Time and date, weekday month day year hh:mm:ss AM/PM.",
        "5": "Long time period, hh:mm:ss. Time needs to be in seconds.",
        "6": "Millisecond time period, hh:mm:ss:xxx (\"xxx\" represents milliseconds). Time needs to be in milliseconds.",
        "7": "Short time period, hh:mm. Time needs to be in seconds.",
        "8": "Long time period, days:hh:mm:sec. Time needs to be in seconds.",
        "9": "Extended date format, dd/mm/yyyy.",
        "nAN, Format": "TrendDspCursorTime(nAN, Format)",
        "nAN": "The AN number of the trend.",
        "Format": "Format of the string:"
      },
      "helpPath": "TrendDspCursorTime.html"
    },
    "trenddspcursorvalue": {
      "name": "TrendDspCursorValue",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Display the cursor value of the current pen in the current pen font.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN": "TrendDspCursorValue(nAN)",
        "AN": "The AN of the trend."
      },
      "helpPath": "TrendDspCursorValue.html"
    },
    "trendgetan": {
      "name": "TrendGetAn",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the AN number of the trend beneath the current mouse position.",
      "returns": "The AN of the trend, or 0 (zero) if the mouse is not positioned over a valid trend.",
      "paramDocs": {},
      "helpPath": "TrendGetAn.html"
    },
    "trendpopup": {
      "name": "TrendPopUp",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "sTag1 [",
        "sTag2..sTag8]"
      ],
      "doc": "Displays a pop-up trend with the specified trend pens.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPage, sTag1 [, sTag2..sTag8]": "TrendPopUp(sPage, sTag1 [, sTag2..sTag8] )",
        "sPage": "The name of the trend page (drawn with the Graphics Builder).",
        "sTag1": "The First trend tag to display on the page.",
        "sTag2..sTag8": "The trend tags to display on the page."
      },
      "helpPath": "TrendPopUp.html"
    },
    "trendrun": {
      "name": "TrendRun",
      "returnType": "UNKNOWN",
      "params": [
        "iPageType"
      ],
      "doc": "Initializes the cursor and rubber-band features on a trend page.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal trend page template",
        "1": "Compare trend page template",
        "iPageType": "TrendRun(iPageType)"
      },
      "helpPath": "TrendRun.html"
    },
    "trendsetdate": {
      "name": "TrendSetDate",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Value"
      ],
      "doc": "Sets the end date for all pens on a trend. Samples taken after this date will not be displayed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Value": "Sets the end date for all pens on a trend. Samples taken after this date will not be displayed. You can enter the date in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter an end date.",
        "nAN, Value": "TrendSetDate(nAN, Value)",
        "nAN": "The AN of the trend."
      },
      "helpPath": "TrendSetDate.html"
    },
    "trendsetscale": {
      "name": "TrendSetScale",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Percent [",
        "Value]"
      ],
      "doc": "Sets the scale of the current pen or of all pens on a trend.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Zero scale",
        "100": "Full scale",
        "Value": "Sets the scale of the current pen or of all pens on a trend. You can enter a scale in the Value argument, or leave the Value blank. A form is then displayed in run time for the operator to enter a value for the scale.",
        "nAN, Percent [, Value]": "TrendSetScale(nAN, Percent [, Value] )",
        "nAN": "The AN of the trend.",
        "Percent": "The scale to be set:"
      },
      "helpPath": "TrendSetScale.html"
    },
    "trendsetspan": {
      "name": "TrendSetSpan",
      "returnType": "UNKNOWN",
      "params": [
        "AN [",
        "Value]"
      ],
      "doc": "Sets the span time of the trend. The span time is the time period covered in the trend window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Value": "Sets the span time of the trend. The span time is the time period covered in the trend window. You can enter a span time in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter a value for the span time.",
        "AN [, Value]": "TrendSetSpan(AN [, Value] )",
        "nAN": "The AN of the trend."
      },
      "helpPath": "TrendSetSpan.html"
    },
    "trendsettime": {
      "name": "TrendSetTime",
      "returnType": "UNKNOWN",
      "params": [
        "AN [",
        "Value]"
      ],
      "doc": "Sets the end time for all the pens on a trend. Samples taken after this time will not be displayed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Value": "Sets the end time for all the pens on a trend. Samples taken after this time will not be displayed. You can enter an end time in the Value argument, or leave the Value blank - a form is then displayed in run time for the operator to enter a value for the end time.",
        "AN [, Value]": "TrendSetTime(AN [, Value] )",
        "nAN": "The AN of the trend."
      },
      "helpPath": "TrendSetTime.html"
    },
    "trendsettimebase": {
      "name": "TrendSetTimebase",
      "returnType": "UNKNOWN",
      "params": [
        "AN [",
        "Value]"
      ],
      "doc": "Sets a new sampling period for a trend.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Value": "Sets a new sampling period for a trend. You can enter a sampling period in the Value argument, or leave the Value blank. A form is then displayed in run time for the operator to enter a value for the sampling period.",
        "AN [, Value]": "TrendSetTimebase(AN [, Value] )",
        "nAN": "The AN of the trend."
      },
      "helpPath": "TrendSetTimebase.html"
    },
    "trendwin": {
      "name": "TrendWin",
      "returnType": "UNKNOWN",
      "params": [
        "sPage",
        "X",
        "Y",
        "Mode",
        "sTag1 [",
        "sTag2..sTag8]"
      ],
      "doc": "Displays a trend page (in a new window) with the specified trend pens.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Normal page.",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode helps prevent this window from being opened more then once.",
        "256": "Display the entire window. This mode commands that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode helps prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "sPage, X, Y, Mode, sTag1 [, sTag2..sTag8]": "TrendWin(sPage, X, Y, Mode, sTag1 [, sTag2..sTag8] )",
        "sPage": "The name of the trend page (drawn with the Graphics Builder).",
        "X": "The x pixel coordinate of the top left corner of the window.",
        "Y": "The y pixel coordinate of the top left corner of the window.",
        "Mode": "The mode of the window:",
        "sTag1": "The firs trend tag to display on the page.",
        "sTag2..sTag8": "The trend tags to display on the page."
      },
      "helpPath": "TrendWin.html"
    },
    "trendzoom": {
      "name": "TrendZoom",
      "returnType": "UNKNOWN",
      "params": [
        "SourceAN",
        "TimeZoom",
        "ScaleZoom [",
        "DestAn]"
      ],
      "doc": "Zooms\" a specified trend in either one or both axes.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "TimeZoom": "\"Zooms\" a specified trend in either one or both axes. Set the zoom values (TimeZoom and/or ScaleZoom) to greater than one to \"zoom in\" or to less than one to \"zoom out\".",
        "SourceAn": "If you specify a destination AN, you can zoom one trend (at SourceAn) onto another (at DestAn), in the same way as on the standard zoom trend page.",
        "SourceAN, TimeZoom, ScaleZoom [, DestAn]": "TrendZoom(SourceAN, TimeZoom, ScaleZoom [, DestAn] )",
        "SourceAN": "The AN on which the source trend is located.",
        "ScaleZoom": "The scale by which the Scale axis will be changed (as a real number).",
        "DestAn": "The AN on which the destination or target trend is located. If you do not enter a DestAn, it is set to the same AN as SourceAn."
      },
      "helpPath": "TrendZoom.html"
    },
    "trnaddhistory": {
      "name": "TrnAddHistory",
      "returnType": "UNKNOWN",
      "params": [
        "FileName [",
        "sClusterName]"
      ],
      "doc": "Adds an old (backed up) trend history file to the trend system so that its data can be used.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "FileName [, sClusterName]": "TrnAddHistory(FileName [, sClusterName] )",
        "FileName": "The file name and directory path of an old history file. The old file does not need to reside in the same directory as existing active trends to be restored.",
        "sClusterName": "Specifies the name of the cluster in which the Trend Server resides. This is optional if you have one cluster or are resolving the trend server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnAddHistory.html"
    },
    "trnbrowseclose": {
      "name": "TrnBrowseClose",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "The TrnBrowseClose function terminates an active data browse session and cleans up all resources associated with the session.",
      "returns": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "TrnBrowseClose(iSession)"
      },
      "helpPath": "TrnBrowseClose.html"
    },
    "trnbrowsefirst": {
      "name": "TrnBrowseFirst",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The TrnBrowseFirst function places the data browse cursor at the first record.",
      "returns": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "TrnBrowseFirst(iSession)"
      },
      "helpPath": "TrnBrowseFirst.html"
    },
    "trnbrowsegetfield": {
      "name": "TrnBrowseGetField",
      "returnType": "UNKNOWN",
      "params": [
        "INT Session",
        "STRING FieldName"
      ],
      "doc": "The TrnBrowseGetField function retrieves the value of the specified field from the record the data browse cursor is currently referencing.",
      "returns": "The value of the specified field as a string. An empty string may or may not be an indication that an error has been detected. This should be checked in this instance to determine if an error has actually occurred.",
      "paramDocs": {
        "INT Session, STRING FieldName": "STRING TrnBrowseGetField(INT Session, STRING FieldName)",
        "Session": "Session",
        "FieldName": "FieldName"
      },
      "helpPath": "TrnBrowseGetField.html"
    },
    "trnbrowsenext": {
      "name": "TrnBrowseNext",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The TrnBrowseNext function moves the data browse cursor forward one record.",
      "returns": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "TrnBrowseNext(iSession)"
      },
      "helpPath": "TrnBrowseNext.html"
    },
    "trnbrowsenumrecords": {
      "name": "TrnBrowseNumRecords",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The TrnBrowseNumRecords function returns the number of records that match the filter criteria.",
      "returns": "The number of records that have matched the filter criteria. A value of 0 denotes that no records have matched. A value of -1 denotes that the browse session is unable to provide a fixed number. This may be the case if the data being browsed changed during the browse session.",
      "paramDocs": {
        "iSession": "TrnBrowseNumRecords(iSession)"
      },
      "helpPath": "TrnBrowseNumRecords.html"
    },
    "trnbrowseopen": {
      "name": "TrnBrowseOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING Filter",
        "STRING Fields [",
        "STRING Clusters]"
      ],
      "doc": "The TrnBrowseOpen function initiates a new browse session and returns a handle to the new session that can be used in subsequent data browse function calls.",
      "returns": "Returns an integer handle to the browse session. Returns -1 if unsuccessful.",
      "paramDocs": {
        "Filter": "INT TrnBrowseOpen( STRING Filter, STRING Fields [, STRING Clusters] )",
        "Fields": "Fields",
        "Clusters": "Clusters"
      },
      "helpPath": "TrnBrowseOpen.html"
    },
    "trnbrowseprev": {
      "name": "TrnBrowsePrev",
      "returnType": "UNKNOWN",
      "params": [
        "iSession"
      ],
      "doc": "The TrnBrowsePrev function moves the data browse cursor back one record.",
      "returns": "0 (zero) if the trend browse session exists, otherwise an error code is returned.",
      "paramDocs": {
        "iSession": "TrnBrowsePrev(iSession)"
      },
      "helpPath": "TrnBrowsePrev.html"
    },
    "trnclientinfo": {
      "name": "TrnClientInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Type",
        "Data",
        "Error"
      ],
      "doc": "Gets information about the trend that is being displayed at the AN point.",
      "returns": "The requested information (as a string) if successful, otherwise a hardware alarm is generated.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "1": "The number of samples configured for the trend. If you select Type 1, the Data argument is ignored.",
        "nAN, Pen, Type, Data, Error": "TrnClientInfo(nAN, Pen, Type, Data, Error)",
        "hAN": "The AN point number at which the trend is displayed.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "nType": "The type of information you would like returned.",
        "Data": "For future enhancements; is currently ignored.",
        "Error": "Output Parameter: If the function is successful, the error is set to 0 (zero). If unsuccessful, an error value is set, and a hardware alarm is triggered. Must be a Long type variable."
      },
      "helpPath": "TrnClientInfo.html"
    },
    "trncompareplot": {
      "name": "TrnComparePlot",
      "returnType": "UNKNOWN",
      "params": [
        "sPort",
        "sTitle",
        "sComment",
        "AN",
        "iMode",
        "nSamples",
        "iTime1",
        "rPeriod1",
        "iTime2",
        "rPeriod2",
        "Tag1......Tag8",
        "rLoScale1",
        "rHiScale1",
        "......rLoScale8",
        "rHiScale8"
      ],
      "doc": "Prints two trends, one overlaid on the other.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "black and white (default)",
        "1": "Color",
        "sPort, sTitle, sComment,": "TrnComparePlot(sPort, sTitle, sComment, AN, iMode, nSamples, iTime1, rPeriod1, iTime2, rPeriod2, Tag1......Tag8, rLoScale1, rHiScale1,......rLoScale8, rHiScale8)",
        "sPort": "The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks. For example LPT1:, to print to the local printer, or \\\\Pserver\\canon1 using UNC to print to a network printer.",
        "sTitle": "The title of the trend plot.",
        "sComment": "The comment that is to display beneath the title of the trend plot. You do not have to enter a comment.",
        "nAN": "Sets the display mode. A value of 0 causes the default display mode to be used. Otherwise, the display mode of the specified AN is set.",
        "iMode": "The color mode of the printer.",
        "nSamples": "The number of data points on the plot.",
        "iTime1": "The end point in time (the most recent point) for the first trend.",
        "rPeriod1": "The period (in seconds) of the first trend. This can differ from the actual trend period. If you do not enter a period, it defaults to the sample period of Tag1.",
        "iTime2": "The end point in time (the most recent point) for the second trend.",
        "rPeriod2": "The period (in seconds) of the second trend. This can differ from the actual trend period. If you do not enter a period, it defaults to the sample period of Tag5.",
        "Tag1. . .Tag8": "The trend tags for the plot. Tags 1 to 4 needs to be for the first trend, and tags 5 to 8 needs to be for the second.",
        "rLoScale1, HiScale1,....LoScale8, HiScale8": "rLoScale1, HiScale1,....LoScale8, HiScale8"
      },
      "helpPath": "TrnComparePlot.html"
    },
    "trndelete": {
      "name": "TrnDelete",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Deletes a trend that is displayed on a current page.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN": "TrnDelete(nAN)"
      },
      "helpPath": "TrnDelete.html"
    },
    "trndelhistory": {
      "name": "TrnDelHistory",
      "returnType": "UNKNOWN",
      "params": [
        "FileName [",
        "sClusterName]"
      ],
      "doc": "Removes a trend history file that has been added to the trend system by the TrnAddHistory() function.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "FileName [, sClusterName]": "TrnDelHistory(FileName [, sClusterName] )",
        "FileName": "The trend history file to disconnect from the historical trend system.",
        "sClusterName": "Specifies the name of the cluster in which the Trend Server resides. This is optional if you have one cluster or are resolving the trend server via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnDelHistory.html"
    },
    "trnecho": {
      "name": "TrnEcho",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "nMode"
      ],
      "doc": "Enables and disables the echo of the trend display.",
      "returns": "The current echo mode, otherwise 0 (zero) is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "Disable echo of the trend display.",
        "1": "Enable echo of the trend display, to show changes.",
        "nAN, nMode": "TrnEcho(nAN, nMode)",
        "nAN": "The animation number of the trend.",
        "nMode": "The mode of the echo:"
      },
      "helpPath": "TrnEcho.html"
    },
    "trneventgettable": {
      "name": "TrnEventGetTable",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "EventNo",
        "Period",
        "Length",
        "Table",
        "TimeTable",
        "Mode [",
        "sClusterName]"
      ],
      "doc": "Stores event trend data in an event table and the associated time stamp in a time table, for a specified trend tag.",
      "returns": "The actual number of samples read. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code. If EventNo is 0 (zero) then the EventNo will be set to the current event number.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Leave invalid/gated trend samples as they are.",
        "2": "Order returned trend samples from newest to oldest.",
        "4": "Set the condense method to use the minimum of the samples.",
        "8": "Set the condense method to use the maximum of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "Period": "Stores event trend data in an event table and the associated time stamp in a time table, for a specified trend tag. Data is stored at the specified Period, working backwards from the starting point specified by EventNo. If Period differs from the trend period configured in the Trend Tags database, the values to be stored are calculated from the trend data. Values are either averaged or interpolated.",
        "Tag, EventNo, Period, Length, Table, TimeTable, Mode [, sClusterName]": "TrnEventGetTable(Tag, EventNo, Period, Length, Table, TimeTable, Mode [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "EventNo": "The starting event number for entries in the trend table.",
        "Length": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table.",
        "Table": "The Cicode array in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
        "TimeTable": "The table of integer values in which the time stamp is stored. Must be a Long type variable.",
        "Mode": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).",
        "n": "the number of missed samples that the user wants to gap fill) x 4096.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnEventGetTable.html"
    },
    "trneventgettablems": {
      "name": "TrnEventGetTableMS",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "EventNo",
        "Period",
        "Length",
        "Table",
        "TimeTable",
        "Mode",
        "MSTimeTable [",
        "sClusterName]"
      ],
      "doc": "Stores event trend data and time data (including milliseconds) for a specified trend tag.",
      "returns": "The actual number of samples read. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Leave invalid/gated trend samples as they are.",
        "2": "Order returned trend samples from newest to oldest.",
        "4": "Set the condense method to use the minimum of the samples.",
        "8": "Set the condense method to use the maximum of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "Period": "Stores event trend data and time data (including milliseconds) for a specified trend tag. The event trend data is stored in an event table, and the time stamp in time tables. Data is stored at the specified Period, working backwards from the starting point specified by EventNo. If Period differs from the trend period configured in the Trend Tags database, the values to be stored are calculated from the trend data. Values are either averaged or interpolated.",
        "Tag, EventNo, Period, Length, Table, TimeTable, Mode, MSTimeTable [, sClusterName]": "TrnEventGetTableMS(Tag, EventNo, Period, Length, Table, TimeTable, Mode, MSTimeTable [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "EventNo": "The starting event number for entries in the trend table.",
        "Length": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table.",
        "Table": "The Cicode array in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
        "TimeTable": "The table of integer values in which the time stamp is stored. Must be a Long type variable.",
        "Mode": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).",
        "n": "the number of missed samples that the user wants to gap fill) x 4096.",
        "MSTimeTable": "The table of integer values in which the millisecond component of the time stamp is stored. Must be a Long type variable.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnEventGetTableMS.html"
    },
    "trneventsettable": {
      "name": "TrnEventSetTable",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "EventNo",
        "Period",
        "Length",
        "Table",
        "TimeTable [",
        "sClusterName]"
      ],
      "doc": "Adds new event to a trend, or overwrites existing points with new values.",
      "returns": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "EventNo": "Sets event trend data and time data for a specified trend tag. The event trend data is set in an event table, and the time stamp in time tables. Data is set at the period specified, working backwards from the starting point specified by EventNo.",
        "Tag, EventNo, Period, Length, Table, TimeTable [, sClusterName]": "TrnEventSetTable(Tag, EventNo, Period, Length, Table, TimeTable [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "Period": "This will be the interval (in seconds) between trend values when they are set (that is, it will be the perceived sampling period for the trend). This period can differ from the actual trend period. Set to 0 (zero) to default to the actual trend period.",
        "Length": "The number of trend values in the trend table.",
        "Table": "The table of floating-point values in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
        "TimeTable": "The table of integer values in which the time stamp is stored. If you would like events to stay in correct time-stamp order, sort the values in this table in ascending order. When EventNo is non-zero the values in this table may be zero. This will result in the values of the requested events being overwritten but the time-stamps staying the same. Must be a Long type variable.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnEventSetTable.html"
    },
    "trneventsettablems": {
      "name": "TrnEventSetTableMS",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "EventNo",
        "Period",
        "Length",
        "Table",
        "TimeTable",
        "MSTimeTable [",
        "sClusterName]"
      ],
      "doc": "Sets event trend data and time data (including milliseconds) for a specified trend tag.",
      "returns": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "EventNo": "Sets event trend data and time data (including milliseconds) for a specified trend tag. The event trend data is set in an event table, and the time stamp in time tables. Data is set at the period specified, working backwards from the starting point specified by EventNo.",
        "Tag, EventNo, Period, Length, Table, TimeTable, MSTimeTable [": "TrnEventSetTableMS(Tag, EventNo, Period, Length, Table, TimeTable, MSTimeTable [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "Period": "This will be the interval (in seconds) between trend values when they are set (that is it will be the perceived sampling period for the trend). This period can differ from the actual trend period. Set to 0 (zero) to default to the actual trend period.",
        "Length": "Number of trend values in the trend table.",
        "Table": "Table of floating-point values in which the trend data is stored. You can enter the name of an array here (see example). Must be a Real type variable.",
        "TimeTable": "Table of integer values in which the time stamp is stored. If you would like events to stay in correct time-stamp order, sort the values in this table in ascending order. When EventNo is non-zero the values in this table may be zero. This will result in the values of the requested events being overwritten but the timestamps staying the same. Must be a Long type variable.",
        "MSTimeTable": "The table of integer values in which the millisecond component of the time stamp is stored. Must be a Long type variable.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnEventSetTableMS.html"
    },
    "trnexportclip": {
      "name": "TrnExportClip",
      "returnType": "UNKNOWN",
      "params": [
        "Time",
        "Period",
        "Length",
        "Mode",
        "ClipMode",
        "sTag1 ... sTag8",
        "iDisplayMode1 ... iDisplayMode 8"
      ],
      "doc": "Exports trend data to the Windows Clipboard.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Export the Date and Time, followed by the tags.",
        "2": "Export the Time only, followed by the tags.",
        "4": "Ignore any invalid or gated values. (Only supported for periodic trends.)",
        "8": "The time returned will have millisecond accuracy.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "1048576": "Display as periodic regardless of trend type.",
        "Time": "Exports trend data to the Windows Clipboard. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.",
        "ClipMode": "You can use the ClipMode argument to make the output more useful. For example, to paste the data into Excel, use ClipMode 2 for CSV format. If you use ClipMode 1 or 3, the default paste menu option causes data to be pasted into the user's spreadsheet as text. If you use ClipMode 3, use the Paste Special option to paste the required format. Please be aware that not all packages support multiple clipboard formats in this way.",
        "Time, Period, Length, Mode, ClipMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8": "TrnExportClip(Time, Period, Length, Mode, ClipMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)",
        "Period": "The period (in seconds) of the entries being exported. (This period can differ from the actual trend period.)",
        "Length": "The length of the data table, that is The number of rows of samples to be exported. for example if you put the length as 12, and you declare two tags to be exported, you get a grid with 12 rows of samples. Each row has values for each of the two tags making a total of 24 samples.",
        "Mode": "The format mode to be used:",
        "sTag1 ... sTag8": "The trend tag names for the data being exported.",
        "iDisplayMode1 ... iDisplayMode8": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).",
        "n": "the number of missed samples that the user wants to gap fill) x 4096."
      },
      "helpPath": "TrnExportClip.html"
    },
    "trnexportcsv": {
      "name": "TrnExportCSV",
      "returnType": "UNKNOWN",
      "params": [
        "Filename",
        "Time",
        "Period",
        "Length",
        "Mode",
        "sTag1 ... sTag8",
        "iDisplayMode1 ... iDisplayMode 8"
      ],
      "doc": "Exports trend data to a file in CSV (Comma Separated Variable) format.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Export the Date and Time, followed by the tags.",
        "2": "Export the Time only, followed by the tags.",
        "4": "Ignore any invalid or gated values. (This mode is only supported for periodic trends.)",
        "8": "The time returned will have millisecond accuracy.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "Time": "Exports trend data to a file in CSV (Comma Separated Variable) format. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.",
        "Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8": "TrnExportCSV(Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)",
        "Filename": "The name of the destination path and file.",
        "Period": "The period (in seconds) of the entries being exported. (This period can differ from the actual trend period.)",
        "Length": "The length of the data table, that is, The number of rows of samples to be exported. for example if you put the length as 12, and you declare two tags to be exported, you get a grid with 12 rows of samples. Each row has values for each of the two tags making a total of 24 samples.",
        "Mode": "The format mode to be used:",
        "sTag1 ... sTag8": "The trend tag names for the data being exported.",
        "iDisplayMode1 ... iDisplayMode8": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends)."
      },
      "helpPath": "TrnExportCSV.html"
    },
    "trnexportdbf": {
      "name": "TrnExportDBF",
      "returnType": "UNKNOWN",
      "params": [
        "Filename",
        "Time",
        "Period",
        "Length",
        "Mode",
        "sTag1 ... sTag8",
        "iDisplayMode1 ... iDisplayMode 8"
      ],
      "doc": "Exports trend data to a file in dBASE III format.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Export the Date and Time, followed by the tags.",
        "2": "Export the Time only, followed by the tags.",
        "4": "Ignore any invalid or gated values. (This mode is only supported for periodic trends.)",
        "8": "The time returned will have millisecond accuracy.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "Time": "Exports trend data to a file in dBASE III format. The data is set at the specified Time and Period, and listed from earliest to latest. Any gated or invalid data is written as 0.0.",
        "Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8": "TrnExportDBF(Filename, Time, Period, Length, Mode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)",
        "Filename": "The name of the destination path and file.",
        "Period": "The period (in seconds) of the entries being exported. (This period can differ from the actual trend period.)",
        "Length": "The length of the data table, that is The number of rows of samples to be exported. for example if you put the length as 12, and you declare two tags to be exported, you get a grid with 12 rows of samples. Each row has values for each of the two tags making a total of 24 samples.",
        "Mode": "The format mode to be used:",
        "sTag1 ... sTag8": "The trend tag names for the data being exported. Tag names longer than 10 characters will be truncated, as the standard DBF field format is 10 characters.",
        "iDisplayMode1 ... iDisplayMode8": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends)."
      },
      "helpPath": "TrnExportDBF.html"
    },
    "trnexportdde": {
      "name": "TrnExportDDE",
      "returnType": "UNKNOWN",
      "params": [
        "sApplication",
        "sDocument",
        "sTopic",
        "Time",
        "Period",
        "Length",
        "Mode",
        "DDEMode",
        "sTag1 ... sTag8",
        "iDisplayMode1 ... iDisplayMode 8"
      ],
      "doc": "Exports trend data via DDE.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Export the Date and Time, followed by the tags.",
        "2": "Export the Time only, followed by the tags.",
        "4": "Ignore any invalid or gated values. (This mode is only supported for periodic trends.)",
        "8": "The time returned will have millisecond accuracy.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "sApplication, sDocument, sTopic, Time, Period, Length, Mode, DDEMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8": "TrnExportDDE(sApplication, sDocument, sTopic, Time, Period, Length, Mode, DDEMode, sTag1 ... sTag8, iDisplayMode1 ... iDisplayMode 8)",
        "sApplication": "The application name to export the data.",
        "sDocument": "The document in the application to export the data.",
        "sTopic": "The topic in the application to export the data. Be aware you may have to use a special topic format to make the data export correctly. See your application documentation for details; For example with Excel you need to specify the matrix of rows and columns as \"R1C1:R8C50\" depending on the size of the data.",
        "Filename": "The name of the destination path and file.",
        "Time": "The starting time for the data being exported.",
        "Period": "The period (in seconds) of the entries being exported. (This period can differ from the actual trend period.)",
        "Length": "The length of the data table, that is The number of rows of samples to be exported. for example if you put the length as 12, and you declare two tags to be exported, you get a grid with 12 rows of samples. Each row has values for each of the two tags making a total of 24 samples.",
        "Mode": "The format mode to be used:",
        "DDEMode": "The format for the data being exported. CSV format allows the application to separate the data into each individual element, however not every application will support this mode. See you applications documentation for details.",
        "sTag1 ... sTag8": "The trend tag names for the data being exported. Tag names longer than 10 characters will be truncated, as the standard DBF field format is 10 characters.",
        "iDisplayMode1 ... iDisplayMode8": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).",
        "n": "the number of missed samples that the user wants to gap fill) x 4096."
      },
      "helpPath": "TrnExportDDE.html"
    },
    "trnflush": {
      "name": "TrnFlush",
      "returnType": "UNKNOWN",
      "params": [
        "Name [",
        "sClusterName]"
      ],
      "doc": "Writes acquired trend data to disk without waiting for the trend buffer to be filled.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Name [, sClusterName]": "TrnFlush(Name [, sClusterName] )",
        "sName": "The name of the logging tag (can be prefixed by the name of the cluster that is ClusterName.Tag). Set to \" * \" to flush all trend data.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnFlush.html"
    },
    "trngetbufevent": {
      "name": "TrnGetBufEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Offset"
      ],
      "doc": "Gets the event number of a trend at an offset for a specified pen.",
      "returns": "The event number. If Offset is not within boundaries, 0 (zero) is returned. If AN or Pen is invalid, 0 (zero) is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Offset": "TrnGetBufEvent(nAN, Pen, Offset)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Offset": "The trend buffer offset, in samples. The number of samples can range from 0 to the maximum number of samples that can display on the trend - 1."
      },
      "helpPath": "TrnGetBufEvent.html"
    },
    "trngetbuftime": {
      "name": "TrnGetBufTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Offset"
      ],
      "doc": "Gets the time and date of a trend at an offset for a specified pen.",
      "returns": "A time/date variable. If Offset is not within boundaries, 0 (zero) is returned. If nAN or Pen is invalid, 0(zero) is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "Offset": "Gets the time and date of a trend at an offset for a specified pen. The Offset should be a value between 0 (zero) and the number of samples displayed on the trend.",
        "nAN, Pen, Offset": "TrnGetBufTime(nAN, Pen, Offset)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetBufTime.html"
    },
    "trngetbufvalue": {
      "name": "TrnGetBufValue",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Offset"
      ],
      "doc": "Gets the value of a trend at an offset for a specified pen.",
      "returns": "The trend value. If the actual value is gated or invalid, the standard invalid or gated values are returned (no error is set). You can check this return value using TrnIsValidValue().",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Offset": "TrnGetBufValue(nAN, Pen, Offset)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Offset": "The trend buffer offset, in samples. The number of samples can range from -1 to the maximum number of samples that can display on the trend minus 1."
      },
      "helpPath": "TrnGetBufValue.html"
    },
    "trngetcluster": {
      "name": "TrnGetCluster",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the cluster name of a trend graph on a page.",
      "returns": "The name of the cluster the trend graph is associated with.",
      "paramDocs": {
        "nAN": "TrnGetCluster(nAN)"
      },
      "helpPath": "TrnGetCluster.html"
    },
    "trngetcursorevent": {
      "name": "TrnGetCursorEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the event number of a trend, at the trend cursor position for a specified pen.",
      "returns": "The event number, or 0 (zero) if the trend cursor is disabled.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen": "TrnGetCursorEvent(nAN, Pen)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetCursorEvent.html"
    },
    "trngetcursormstime": {
      "name": "TrnGetCursorMSTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the time (in milliseconds from the previous midnight) at a trend cursor for a specified pen.",
      "returns": "The number of milliseconds since the previous midnight. If the trend cursor is disabled, 0 (zero) is returned. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "AN, Pen": "TrnGetCursorMSTime(nAN, Pen)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetCursorMSTime.html"
    },
    "trngetcursorpos": {
      "name": "TrnGetCursorPos",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the offset of a trend cursor from its origin, in samples.",
      "returns": "The offset of a trend cursor from its origin, in samples, or -1 if the trend cursor is disabled.",
      "paramDocs": {
        "nAN": "TrnGetCursorPos(nAN)"
      },
      "helpPath": "TrnGetCursorPos.html"
    },
    "trngetcursortime": {
      "name": "TrnGetCursorTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the time and date at a trend cursor for a specified pen.",
      "returns": "A time/date variable. If the trend cursor is disabled, 0 (zero) is returned. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen": "TrnGetCursorTime(nAN, Pen)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetCursorTime.html"
    },
    "trngetcursorvalue": {
      "name": "TrnGetCursorValue",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the value at a trend cursor for a specified pen.",
      "returns": "The trend value. If the actual value is gated or invalid, the standard invalid or gated values are returned (no error is set). You can check this return value using TrnIsValidValue().",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen": "TrnGetCursorValue(nAN, Pen)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetCursorValue.html"
    },
    "trngetcursorvaluestr": {
      "name": "TrnGetCursorValueStr",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "EngUnits"
      ],
      "doc": "Gets the value at a trend cursor for a specified pen.",
      "returns": "The trend value (as a string). If trend data is invalid, or an argument passed to the function is invalid \"<na>\" is returned. If the actual value is gated (not triggered) \"<gated>\" is returned. If the trend cursor is disabled, an empty string is returned.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "1": "Include the engineering units at the end of the formatted string.",
        "nAN, Pen, EngUnits": "TrnGetCursorValueStr(nAN, Pen, EngUnits)",
        "nAN": "The AN where the trend is located.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "EngUnits": "Engineering units mode:"
      },
      "helpPath": "TrnGetCursorValueStr.html"
    },
    "trngetdefscale": {
      "name": "TrnGetDefScale",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "LoScale",
        "HiScale [",
        "sClusterName]"
      ],
      "doc": "Gets the default engineering zero and full scales of a trend tag.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Tag, LoScale, HiScale [, sClusterName]": "TrnGetDefScale(Tag, LoScale, HiScale [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is \"ClusterName.Tag\").",
        "LoScale": "The engineering zero scale. Must be a Real type variable.",
        "HiScale": "The engineering full scale. Must be a Real type variable.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnGetDefScale.html"
    },
    "trngetdisplaymode": {
      "name": "TrnGetDisplayMode",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "PenNumber"
      ],
      "doc": "Returns the display mode of the selected trend pen.",
      "returns": "An integer representing the trend's display mode:",
      "paramDocs": {
        "0": "The pen currently in focus.",
        "1": "1 - Leave invalid/gated trend samples as they are.",
        "2": "2 - Order returned trend samples from newest to oldest.",
        "4": "4 - Set the condense method to use the minimum of the samples.",
        "8": "8 - Set the condense method to use the maximum of the samples.",
        "12": "12 - Set the condense method to use the newest of the samples.",
        "128": "128 - Set the stretch method to use a ratio.",
        "256": "256 - Set the stretch method to use raw samples.",
        "1048576": "1048576 - display as periodic regardless of trend type.",
        "nAN, PenNumber": "TrnGetDisplayMode(nAN, PenNumber)",
        "nAN": "The AN of the chosen trend.",
        "PenNumber": "The trend pen number:",
        "1...8": "Pen1. . .Pen8.",
        "n": "n - the number of missed samples that the user wants to gap fill) x 4096."
      },
      "helpPath": "TrnGetDisplayMode.html"
    },
    "trngetevent": {
      "name": "TrnGetEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent"
      ],
      "doc": "Gets the event number of the trend at a percentage along the trend, using the current event as the base point.",
      "returns": "The event number.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Percent": "TrnGetEvent(nAN, Pen, Percent)",
        "nAN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Percent": "The percentage of the trend from the starting event, from 0 (the start event) to 100 (the end event)."
      },
      "helpPath": "TrnGetEvent.html"
    },
    "trngetformat": {
      "name": "TrnGetFormat",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Width",
        "DecPlaces"
      ],
      "doc": "Gets the format of a trend tag being plotted by a specified pen.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Width, DecPlaces": "TrnGetFormat(nAN, Pen, Width, DecPlaces)",
        "nAN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Width": "Variable denoting the width of the format.",
        "DecPlaces": "Variable denoting the number of decimal places in the format."
      },
      "helpPath": "TrnGetFormat.html"
    },
    "trngetgatedvalue": {
      "name": "TrnGetGatedValue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns the internally stored value for <GATED>.",
      "returns": "The internally stored value for <GATED>.",
      "paramDocs": {},
      "helpPath": "TrnGetGatedValue.html"
    },
    "trngetinvalidvalue": {
      "name": "TrnGetInvalidValue",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Returns the internally stored value for <INVALID>.",
      "returns": "The internally stored value for <INVALID>.",
      "paramDocs": {},
      "helpPath": "TrnGetInvalidValue.html"
    },
    "trngetmode": {
      "name": "TrnGetMode",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the mode (real-time or historical trending) of the trend pen.",
      "returns": "The current mode, 0 for real-time or 1 for historical.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen": "TrnGetMode(nAN, Pen)",
        "nAN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetMode.html"
    },
    "trngetmstime": {
      "name": "TrnGetMSTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent"
      ],
      "doc": "Gets the time (in milliseconds from the previous midnight) of the trend (plotted by a specified pen) at a percentage along the trend, using the time and date of the right-most sample displayed.",
      "returns": "The number of milliseconds since the previous midnight. Zero (0) is returned if an error is detected.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Percent": "TrnGetMSTime(nAN, Pen, Percent)",
        "nAN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Percent": "The percentage of the trend from the time and date of the right-most sample displayed (end time), from 0 to 100."
      },
      "helpPath": "TrnGetMSTime.html"
    },
    "trngetpen": {
      "name": "TrnGetPen",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen [",
        "Mode]"
      ],
      "doc": "Gets the trend tag being plotted by a specified pen.",
      "returns": "The trend tag (as a string) being plotted by Pen. If nAN or Pen is invalid, an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen [, Mode]": "TrnGetPen(nAN, Pen [, Mode] )",
        "nAN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Mode": "An optional argument used to specify whether the trend tag name is returned with a cluster prefix. Set:"
      },
      "helpPath": "TrnGetPen.html"
    },
    "trngetpencomment": {
      "name": "TrnGetPenComment",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Retrieves the comment of a pen.",
      "returns": "The comment of the pen as a string.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen": "TrnGetPenComment(nAN, Pen)",
        "AN": "AN",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetPenComment.html"
    },
    "trngetpenfocus": {
      "name": "TrnGetPenFocus",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the number of the pen currently in focus.",
      "returns": "The pen currently in focus (between 1 and 8). If nAN is invalid, -1 is returned and an error code is set.",
      "paramDocs": {
        "nAN": "TrnGetPenFocus(nAN)",
        "AN": "The AN of the chosen trend."
      },
      "helpPath": "TrnGetPenFocus.html"
    },
    "trngetpenno": {
      "name": "TrnGetPenNo",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Tag"
      ],
      "doc": "Gets the pen number of a pen name.",
      "returns": "The pen number, or 0 (zero) if an error is detected.",
      "paramDocs": {
        "nAN, Tag": "TrnGetPenNo(nAN, Tag)",
        "AN": "The AN of the chosen trend.",
        "Tag": "The trend tag."
      },
      "helpPath": "TrnGetPenNo.html"
    },
    "trngetperiod": {
      "name": "TrnGetPeriod",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the current display period of a trend.",
      "returns": "The current display period of a trend (in seconds), or 0 (zero) if an error code is detected.",
      "paramDocs": {
        "nAN": "TrnGetPeriod(nAN)",
        "AN": "The AN of the chosen trend."
      },
      "helpPath": "TrnGetPeriod.html"
    },
    "trngetscale": {
      "name": "TrnGetScale",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent"
      ],
      "doc": "Gets the display scale of the trend tag being plotted by a specified pen.",
      "returns": "The scale of the trend tag being plotted by Pen. If nAN or Pen is invalid, 0 (zero) is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Percent": "TrnGetScale(nAN, Pen, Percent)",
        "AN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Percent": "The percentage of the full scale, from 0 to 100."
      },
      "helpPath": "TrnGetScale.html"
    },
    "trngetscalestr": {
      "name": "TrnGetScaleStr",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent",
        "EngUnits"
      ],
      "doc": "Gets the scale of the trend tag being plotted by a specified pen.",
      "returns": "The scale of the trend tag being plotted by Pen (as a string). If nAN or Pen is invalid, <na> is returned and an error code is set.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "1": "Include the engineering units at the end of the formatted string.",
        "nAN, Pen, Percent, EngUnits": "TrnGetScaleStr(nAN, Pen, Percent, EngUnits)",
        "AN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Percent": "The percentage of the full scale, from 0 to 100.",
        "EngUnits": "Engineering units mode:"
      },
      "helpPath": "TrnGetScaleStr.html"
    },
    "trngetspan": {
      "name": "TrnGetSpan",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the span time of a trend (if the span was set by the TrnSetSpan() function).",
      "returns": "The span time, in seconds. 0(zero) is returned if the AN is invalid or if the span was not set by the TrnSetSpan() function.",
      "paramDocs": {
        "nAN": "TrnGetSpan(nAN)",
        "AN": "The AN of the chosen trend."
      },
      "helpPath": "TrnGetSpan.html"
    },
    "trngettable": {
      "name": "TrnGetTable",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "Time",
        "Period",
        "Length",
        "Table",
        "DisplayMode [",
        "Milliseconds] [",
        "sClusterName]"
      ],
      "doc": "This function allows you to tabulate values from a specific section of trend. The values in the table (possibly an array variable) are arranged by time.",
      "returns": "The actual number of samples read. 0(zero) is returned if an error occurs. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "Convert invalid/gated trend samples to zero.",
        "1": "Leave invalid/gated trend samples as they are.",
        "2": "Order returned trend samples from oldest to newest.",
        "4": "Set the condense method to use the minimum of the samples.",
        "8": "Set the condense method to use the maximum of the samples.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "16777216": "Do not synchronize samples to the nearest display period.",
        "Period": "If the period (Period) is different to the trend's sampling period (configured in the Trend Tags database), the returned values are determined by DisplayMode.",
        "Tag, Time, Period, Length, Table, DisplayMode [, Milliseconds] [, sClusterName]": "TrnGetTable(Tag, Time, Period, Length, Table, DisplayMode [, Milliseconds] [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "Time": "The end time and date (long integer) of the desired trend section. Once you have entered the end time and date (Time), period (Period), and number of trend tag values collected (Length), the start time and date will be calculated automatically. For example, if Time = StrToDate(\"21/07/20\") + StrToTime(\"09:00\"), Period = 30, and Length = 60, the start time would be 08:30. In other words, the trend values for the period between 8.30am and 9am (on July 21, 2020) would be tabulated.",
        "Length": "The number of trend values to store in the trend table, from 1 to the maximum number of items in the table. This argument has a max of 4000 (in v6). Specifying a length of greater than 4000 results in a return value of 0 and IsError()=274 (INVALID_ARGUMENT). This limit can be configured using the citect.ini parameter [Trend]MaxRequestLength.",
        "Table": "Variable containing the Cicode array in which the trend data is stored. You can enter the name of an array here (see the example).",
        "DisplayMode": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends).",
        "n": "the number of missed samples that the user wants to gap fill) x 4096.",
        "Milliseconds": "This argument allows you to set your sample request time with millisecond precision. After defining the time and date in seconds with the Time argument, you can then use this argument to define the milliseconds component of the time.",
        "sClusterName": "Name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnGetTable.html"
    },
    "trngettime": {
      "name": "TrnGetTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent"
      ],
      "doc": "Gets the time and date of the trend (plotted by a specified pen) at a percentage along the trend, using the time and date of the right-most sample displayed.",
      "returns": "A time/date variable. 0 (zero) is returned if an error is detected.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Percent": "TrnGetTime(nAN, Pen, Percent)",
        "AN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Percent": "The percentage of the trend from the time and date of the right-most sample displayed (end time), from 0 to 100."
      },
      "helpPath": "TrnGetTime.html"
    },
    "trngetunits": {
      "name": "TrnGetUnits",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Gets the data units for the trend tag plotted by a specified Pen.",
      "returns": "The data units for the trend tag plotted by Pen, otherwise an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "Pen": "Gets the data units for the trend tag plotted by a specified Pen.",
        "nAN, Pen": "TrnGetUnits(nAN, Pen)",
        "AN": "The AN of the chosen trend.",
        "1...8": "Pen1. . .Pen8"
      },
      "helpPath": "TrnGetUnits.html"
    },
    "trninfo": {
      "name": "TrnInfo",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "Type [",
        "sClusterName]"
      ],
      "doc": "Gets the configured values of a trend tag.",
      "returns": "The value (as a string), otherwise an empty string is returned, and an error code is set. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "1": "Trend Type",
        "2": "Sample Period (to obtain the Display Period, use the TrnGetPeriod function)",
        "3": "Trend File Name (without file extension)",
        "4": "Area",
        "5": "Privilege",
        "6": "Current Event Number. Valid only for event type trends",
        "7": "Engineering Units",
        "8": "The storage method used for the tag. A returned value of 2 represents two byte storage (scaled), 8 represents eight byte storage (floating point).",
        "9": "The file period of the tag in seconds. If the file period is set to monthly or yearly, a file period cannot be calculated as months and years vary in length. Therefore, a file period of 0 will be returned for trends with such file periods.",
        "Tag, Type [, sClusterName]": "TrnInfo(Tag, Type [, sClusterName] )",
        "Tag": "The name of the trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "nType": "The type of information required:",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnInfo.html"
    },
    "trnisvalidvalue": {
      "name": "TrnIsValidValue",
      "returnType": "UNKNOWN",
      "params": [
        "TrendValue"
      ],
      "doc": "Determines whether a logged trend value is <VALID>, <GATED> or <INVALID>.",
      "returns": "0 for <VALID>",
      "paramDocs": {
        "TrendValue": "TrnIsValidValue(TrendValue)"
      },
      "helpPath": "TrnIsValidValue.html"
    },
    "trnnew": {
      "name": "TrnNew",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Trend [",
        "Tag1 ... Tag8] [",
        "sClusterName]"
      ],
      "doc": "Creates a new trend at run time.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Trend [, Tag1 ... Tag8] [, sClusterName]": "TrnNew(nAN, Trend [, Tag1 ... Tag8] [, sClusterName] )",
        "AN": "The AN where the bottom right-hand corner of the trend is located.",
        "Trend": "The trend definition number (as a STRING).",
        "Tag1 . . .Tag8": "The trend tags. (These tags cannot be prefixed with cluster name, cluster should be specified with the ClusterName argument).",
        "sClusterName": "The name of the cluster in which all the trend tags reside. This is optional if you have one cluster or are resolving the trends via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnNew.html"
    },
    "trnplot": {
      "name": "TrnPlot",
      "returnType": "UNKNOWN",
      "params": [
        "sPort",
        "nSamples",
        "iTime",
        "rPeriod",
        "sTitle",
        "AN",
        "Tag1......Tag8",
        "iMode",
        "sComment",
        "rLoScale1",
        "rHiScale1",
        "......rLoScale8",
        "rHiScale8"
      ],
      "doc": "Prints the trend line of one or more trend tags.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Black and White",
        "1": "Color",
        "sPort, nSamples, iTime, rPeriod, sTitle, AN, Tag1......Tag8,": "TrnPlot(sPort, nSamples, iTime, rPeriod, sTitle, AN, Tag1......Tag8, iMode, sComment, rLoScale1, rHiScale1, ......rLoScale8, rHiScale8)",
        "sPort": "The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks. For example LPT1:, to print to the local printer, or \\\\Pserver\\canon1 using UNC to print to a network printer.",
        "nSamples": "The number of data points on the plot.",
        "iTime": "For periodic trend or event trends displayed as periodic:",
        "rPeriod": "The period (in seconds) of the trend plot. This can differ from the actual trend period.",
        "sTitle": "The title of the trend plot.",
        "Tag1. . .Tag8": "The trend tags.",
        "AN": "The AN of the chosen trend. If you enter 0 (zero), the display mode will default to 258. (This is the display mode that is passed into TrnGetTable() when it is called internally by TrnPlot().) If you call TrnPlot() from a report, you need to enter 0 (zero) here.",
        "iMode": "The color mode of the printer.",
        "sComment": "The comment that is to display beneath the title of the trend plot. You may pass an empty string if no comment is required.",
        "rLoScale1, HiScale1,......LoScale8, HiScale8": "The minimum and maximum on the vertical scale for the trend line of each of the tags (Tag1. . . Tag8)."
      },
      "helpPath": "TrnPlot.html"
    },
    "trnprint": {
      "name": "TrnPrint",
      "returnType": "UNKNOWN",
      "params": [
        "sPort",
        "sTitle",
        "AN",
        "iModeColor",
        "iDisplayForm"
      ],
      "doc": "Prints the trend that is displayed on the screen (at nAN) using the current display mode for each trend.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Black and White",
        "1": "Color",
        "nAN": "Prints the trend that is displayed on the screen (at nAN) using the current display mode for each trend. You can specify the trend title, the target printer, whether to print in color or black and white, and whether to display the Plot Setup form when the function is called.",
        "sPort, sTitle, AN,": "TrnPrint(sPort, sTitle, AN, iModeColor, iDisplayForm)",
        "sPort": "The name of the printer port to which the plot will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1:\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer.",
        "sTitle": "The title to print at the top of the trend plot. If you omit the title in sTitle, the page title will be used.",
        "AN": "The AN where the trend plot is located.",
        "iModeColor": "The color mode of the printer.",
        "-1": "Color to be decided (Default). Plant SCADA refers to the [GENERAL]PrinterColorMode parameter to determine print color. If there is no setting for this parameter, it will default to black and white.",
        "DisplayForm": "Defines whether or not the Plot Setup form will display when the function is called. This form allows you to enter the color mode of the printer, and define the printer setup etc. (See Printing Trend Data for more information on this form.)"
      },
      "helpPath": "TrnPrint.html"
    },
    "trnsamplesconfigured": {
      "name": "TrnSamplesConfigured",
      "returnType": "UNKNOWN",
      "params": [
        "nAN"
      ],
      "doc": "Gets the number of samples configured for the currently displayed trend.",
      "returns": "The number of samples configured for the trend, or 0 (zero) if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "nAN": "TrnSamplesConfigured(nAN)",
        "AN": "The AN where the trend is located."
      },
      "helpPath": "TrnSamplesConfigured.html"
    },
    "trnscroll": {
      "name": "TrnScroll",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "nScroll [",
        "nMode]"
      ],
      "doc": "Scrolls the trend pen by a specified percentage (of span), or number of samples.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "The trend will be scrolled by a percentage of span. Default.",
        "2": "The trend will be scrolled by a number of samples. This mode is not available if the user puts the trend into the 'trend span' mode by setting the span. In this case no scrolling would take place; the user needs to use nMode 1.",
        "nAN, Pen, nScroll [, nMode]": "TrnScroll(nAN, Pen, nScroll [, nMode] )",
        "AN": "The AN where the trend is located. Set to -1 for all trends on the current page.",
        "Pen": "The trend pen number. Set to -1 for all pens.",
        "nScroll": "The amount by which the trend will be scrolled. Use nMode to specify whether the trend will be scrolled by percentage or by number of samples.",
        "nMode": "nMode"
      },
      "helpPath": "TrnScroll.html"
    },
    "trnselect": {
      "name": "TrnSelect",
      "returnType": "UNKNOWN",
      "params": [
        "Window",
        "Page",
        "AN [",
        "sClusterName]"
      ],
      "doc": "Sets up a page for a trend. This function allows you to set up a trend before the trend page is displayed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Window, Page, AN [, sClusterName]": "TrnSelect(Window, Page, AN [, sClusterName] )",
        "Window": "The window number (returned from the WinNumber function).",
        "-3": "for the current window.",
        "-2": "for the next window displayed.",
        "Page": "The name of the page that displays the trend.",
        "AN": "The AN where the trend displays, or -3 for the first trend on the page.",
        "sClusterName": "The name of the cluster that is associated with any trend tag for this trend graph. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnSelect.html"
    },
    "trnsetcursor": {
      "name": "TrnSetCursor",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Samples"
      ],
      "doc": "Moves the trend cursor by a specified number of samples.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Samples": "TrnSetCursor(nAN, Samples)",
        "AN": "The AN where the trend is located. Set to -1 for all trends on the current page.",
        "Samples": "The number of samples to move the cursor."
      },
      "helpPath": "TrnSetCursor.html"
    },
    "trnsetcursorpos": {
      "name": "TrnSetCursorPos",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Position"
      ],
      "doc": "Moves the trend cursor to a specified x-axis point, offset from the trend cursor origin.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Position": "TrnSetCursorPos(nAN, Position)",
        "AN": "The AN where the trend is located. Set to -1 for all trends on the current page.",
        "Position": "The x-axis point at which to position the trend cursor, offset from the trend cursor origin."
      },
      "helpPath": "TrnSetCursorPos.html"
    },
    "trnsetdisplaymode": {
      "name": "TrnSetDisplayMode",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "PenNumber",
        "DisplayMode"
      ],
      "doc": "Specifies how raw trend samples are displayed on the screen.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The current pen",
        "1": "Leave invalid/gated trend samples as they are.",
        "2": "Order returned trend samples from newest to oldest.",
        "4": "Set the condense method to use the minimum of the samples.",
        "8": "Set the condense method to use the maximum of the samples.",
        "12": "Set the condense method to use the newest of the samples.",
        "128": "Set the stretch method to use a ratio.",
        "256": "Set the stretch method to use raw samples.",
        "1048576": "display as periodic regardless of trend type.",
        "nAN, PenNumber, DisplayMode": "TrnSetDisplayMode(nAN, PenNumber, DisplayMode)",
        "AN": "The animation number of the chosen trend.",
        "PenNumber": "The pen number of the chosen trend. Specify:",
        "1-8": "Pens 1 through 8",
        "-1": "All pens",
        "DisplayMode": "The Display Mode parameters allow you to enter a single integer to specify the display options for a trend (for a maximum of eight trends)."
      },
      "helpPath": "TrnSetDisplayMode.html"
    },
    "trnsetevent": {
      "name": "TrnSetEvent",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Event"
      ],
      "doc": "Sets the start event of a trend pen. This function only operates on an event-based trend.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "nAN, Pen, Event": "TrnSetEvent(nAN, Pen, Event)",
        "AN": "The AN of the chosen trend.",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Event": "The number of the start event."
      },
      "helpPath": "TrnSetEvent.html"
    },
    "trnsetpen": {
      "name": "TrnSetPen",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Tag"
      ],
      "doc": "Sets the trend tag of a trend pen. The trend pen changes to the specified tag and the trend is refreshed.",
      "returns": "0 (zero) if successful, otherwise an error code is returned. Be aware that if a mixture of periodic and event trends is detected, the return value is 0 (zero), but the hardware alarm #329 is set.",
      "paramDocs": {
        "0": "The pen currently in focus.",
        "nAN, Pen, Tag": "TrnSetPen(nAN, Pen, Tag)",
        "AN": "The AN where the trend is located.",
        "-1": "All trends on the current trend page.",
        "-2": "The function being called is using the special AN setup by the TrnSelect() function.",
        "Pen": "The pen for which the trend tag will be changed.",
        "1...8": "Pen1....Pen8",
        "Tag": "The trend tag. If Tag = ! the pen is deleted."
      },
      "helpPath": "TrnSetPen.html"
    },
    "trnsetpenfocus": {
      "name": "TrnSetPenFocus",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen"
      ],
      "doc": "Sets the focus to a specified pen.",
      "returns": "The old pen focus number, or -1 if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "0": "Keep the current focus.",
        "nAN, Pen": "TrnSetPenFocus(nAN, Pen)",
        "AN": "The AN of the chosen trend.",
        "Pen": "The trend pen:",
        "-4": "Make the next pen the focus pen; without skipping blank pens.",
        "-3": "Make the previous pen the focus pen; without skipping blank pens.",
        "-2": "Make the next pen the focus pen; skip blank pens.",
        "-1": "Make the previous pen the focus pen; skip blank pens.",
        "1...8": "Change Pen1. . .8 to be the focus pen."
      },
      "helpPath": "TrnSetPenFocus.html"
    },
    "trnsetperiod": {
      "name": "TrnSetPeriod",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Period"
      ],
      "doc": "Sets the display period (time base) of a trend.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Period": "TrnSetPeriod(nAN, Period)",
        "AN": "The AN where the trend is located. Set to -1 for every trend on the current page.",
        "Period": "The new sampling period (in seconds) of the trend. To set the display period to the sampling period, set this argument to 0 (zero),"
      },
      "helpPath": "TrnSetPeriod.html"
    },
    "trnsetscale": {
      "name": "TrnSetScale",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Percent",
        "Scale"
      ],
      "doc": "Sets a new scale for a trend pen.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The pen currently in focus",
        "100": "Set the full scale.",
        "nAN, Pen, Percent, Scale": "TrnSetScale(nAN, Pen, Percent, Scale)",
        "AN": "The AN where the trend is located. Set to -1 for all trends on the current page.",
        "Pen": "The trend pen number:",
        "-1": "All pens",
        "1...8": "Pen1...Pen8",
        "Percent": "The scale mode:",
        "-2": "Set both zero and full scales to the default scales.",
        "Scale": "The new value of the scale. Scale is ignored if Percent is -2."
      },
      "helpPath": "TrnSetScale.html"
    },
    "trnsetspan": {
      "name": "TrnSetSpan",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Span"
      ],
      "doc": "Sets the span time of a trend. The span time is the total time displayed in the trend window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "nAN, Span": "TrnSetSpan(nAN, Span)",
        "AN": "The AN of the chosen trend.",
        "Span": "The span time (in seconds)."
      },
      "helpPath": "TrnSetSpan.html"
    },
    "trnsettable": {
      "name": "TrnSetTable",
      "returnType": "UNKNOWN",
      "params": [
        "Tag",
        "Time",
        "Period",
        "Length",
        "Table [",
        "Milliseconds] [",
        "sClusterName]"
      ],
      "doc": "Writes trend tag data from a table to the trend logging system.",
      "returns": "The actual number of samples written. The return value is 0 if an error is detected. You can call the IsError() function to get the actual error code.",
      "paramDocs": {
        "Period": "Writes trend tag data from a table to the trend logging system (starting at the top of the table, and continuing to the bottom). Each value is written with a time and date, as specified by Period. If Period differs from the trend sampling period (defined in the Trend Tags database), the trend's sample values will be calculated (averaged or interpolated) from the tabulated trend data.",
        "Tag, Time, Period, Length, Table [, Milliseconds] [, sClusterName]": "TrnSetTable(Tag, Time, Period, Length, Table [, Milliseconds] [, sClusterName] )",
        "Tag": "The trend tag enclosed in quotation marks \"\" (can be prefixed by the name of the cluster that is ClusterName.Tag).",
        "Time": "The time and date (long integer) to be associated with the first value in the table when it is set. Once you have entered the end time and date (Time), set period (Period), and number of trend tag values to be set (Length), the start time and date will be calculated automatically. For example, if Time = StrToDate(\"22/07/20\") + StrToTime(\"09:00\"), Period = 30, and Length = 60, the start time would be 08:30. In other words, the first value from the table would be set with time 9am, and the last would be set with time 8.30am (on July 22, 2020).",
        "Length": "The number of trend values in the trend table.",
        "Table": "Variable containing the table of floating-point values in which the trend data is stored. You can enter the name of an array here (see the example). Must be a Real type variable.",
        "Milliseconds": "This argument allows you to set the time of the first sample in the table with millisecond precision. After defining the time and date in seconds with the Time argument, you can then use this argument to define the milliseconds component of the time.",
        "sClusterName": "The name of the cluster in which the trend tag resides. This is optional if you have one cluster or are resolving the trend via the current cluster context. The argument is enclosed in quotation marks \"\"."
      },
      "helpPath": "TrnSetTable.html"
    },
    "trnsettime": {
      "name": "TrnSetTime",
      "returnType": "UNKNOWN",
      "params": [
        "nAN",
        "Pen",
        "Time"
      ],
      "doc": "Sets the end time and date of a trend pen.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "The trend where the cursor is positioned",
        "nAN, Pen, Time": "TrnSetTime(nAN, Pen, Time)",
        "AN": "The AN where the trend is located, or:",
        "-1": "All trends on the current page",
        "Pen": "The trend pen number:",
        "1...8": "Pen1. . .Pen8",
        "Time": "The end time and date of the trend. Samples taken after this time and date will not be displayed. Set to 0 (zero) to set the trend to the current time (real-time mode)."
      },
      "helpPath": "TrnSetTime.html"
    },
    "usercreate": {
      "name": "UserCreate",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sFullName",
        "sPassword",
        "sType"
      ],
      "doc": "Creates a record for a new user. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName, sFullName, sPassword, sType": "UserCreate(sName, sFullName, sPassword, sType )",
        "sName": "The name of the user.",
        "sFullName": "The full name of the user.",
        "sPassword": "The password of the user.",
        "sType": "The generic type of user. The type needs to be defined in the Users database (with the Users form)."
      },
      "helpPath": "UserCreate.html"
    },
    "usercreateform": {
      "name": "UserCreateForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a form to create a record for a new user. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "UserCreateForm.html"
    },
    "userdelete": {
      "name": "UserDelete",
      "returnType": "UNKNOWN",
      "params": [
        "sName"
      ],
      "doc": "Deletes the record for a user. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName": "UserDelete(sName)"
      },
      "helpPath": "UserDelete.html"
    },
    "usereditform": {
      "name": "UserEditForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays a form to allow the user to create or delete any user record in the database. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "UserEditForm.html"
    },
    "userinfo": {
      "name": "UserInfo",
      "returnType": "UNKNOWN",
      "params": [
        "nType"
      ],
      "doc": "Gets information about the operator who is currently logged-in to the system.",
      "returns": "The information (as a string). If an error is detected, an empty string is returned.",
      "paramDocs": {
        "0": "Flag to indicate whether any user other than a view-only user is logged in",
        "1": "The login name of the user",
        "2": "The full name of the user",
        "3": "The time the user logged in",
        "4": "The time the user entered the last command",
        "5": "The number of commands entered by the user",
        "6": "The type of login:",
        "nType": "UserInfo(nType)"
      },
      "helpPath": "UserInfo.html"
    },
    "userlogin": {
      "name": "UserLogin",
      "returnType": "UNKNOWN",
      "params": [
        "sUserName",
        "sPassword",
        "[sLanguage]"
      ],
      "doc": "Logs a user into the Plant SCADA system, using either Windows integrated security or Plant SCADA security.",
      "returns": "0 (zero) if successful.",
      "paramDocs": {
        "sUserName, sPassword, [sLanguage]": "UserLogin(sUserName, sPassword, [sLanguage])",
        "sUserName": "The user's name as defined in the Users database, or the Windows User account name, in plain text.",
        "sPassword": "The user's password, as defined in the Users database or Windows account formatted as a secure string.",
        "sLanguage": "The specified language needs to tagbe one of the languages defined in the Languages view in Plant SCADA Studio's Setup activity. If the specified language is undefined, the default language is used by the login user, and a message \"Undefined language\" is shown in the prompt line."
      },
      "helpPath": "UserLogin.html"
    },
    "userpassword": {
      "name": "UserPassword",
      "returnType": "UNKNOWN",
      "params": [
        "sName [",
        "sPassword] [",
        "sOldPassword]"
      ],
      "doc": "Changes the password for the user. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName [, sPassword] [, sOldPassword]": "UserPassword(sName [, sPassword] [, sOldPassword] )",
        "sName": "The name of the user.",
        "sPassword": "The password of the user.",
        "sOldPassword": "The password assigned to the user before the UserPassword() function is run."
      },
      "helpPath": "UserPassword.html"
    },
    "userpasswordexpirydays": {
      "name": "UserPasswordExpiryDays",
      "returnType": "UNKNOWN",
      "params": [
        "sUserName [",
        "sPassword]"
      ],
      "doc": "Returns the number of days left before the user's password is due to expire. Not available for a Windows user.",
      "returns": "The return value contains either the number of days before password expiry, or one of two exception conditions:",
      "paramDocs": {
        "sUserName [, sPassword]": "UserPasswordExpiryDays(sUserName [, sPassword] )",
        "sUserName": "The name of the user.",
        "sPassword": "The password of the user."
      },
      "helpPath": "UserPasswordExpiryDays.html"
    },
    "userpasswordform": {
      "name": "UserPasswordForm",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Display a form to allow users to change their own passwords. Not available for a Windows user.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "UserPasswordForm.html"
    },
    "usersetstr": {
      "name": "UserSetStr",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sField",
        "sData"
      ],
      "doc": "Sets the value of the given field for the given user record in the project configuration (users.dbf ) on the local machine.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName, sField, sData": "UserSetStr(sName, sField, sData)",
        "sName": "The name of the user who's configuration record we wish to modify.",
        "sField": "The name of the field in users.dbf to modify.",
        "sData": "The new value of the field."
      },
      "helpPath": "UserSetStr.html"
    },
    "userupdaterecord": {
      "name": "UserUpdateRecord",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Triggers a recompile of the local project configuration, then notifies the running system that user configuration has been modified and needs to be reloaded.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "UserUpdateRecord.html"
    },
    "userverify": {
      "name": "UserVerify",
      "returnType": "UNKNOWN",
      "params": [
        "sName",
        "sPassword [",
        "sAccess] [",
        "sPrivGlobal] [",
        "sPriv1..sPriv8]"
      ],
      "doc": "Verifies a given user by authenticating the user's credential, verifies the user privileges and areas against those specified in the functions parameters.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName, sPassword [, sAccess] [, sPrivGlobal] [, sPriv1..sPriv8]": "UserVerify(sName, sPassword [, sAccess] [, sPrivGlobal] [, sPriv1..sPriv8] )",
        "sName": "The name of the user.",
        "sPassword": "The password of the user. The sPassword argument needs to be passed as a secure string.",
        "sAccess": "Specifies the required user's viewable areas.",
        "sPrivGlobal": "Specifies the required user's global privilege.",
        "sPriv1-8": "Specifies the required areas for privileges 1 - 8. That is, sPriv1 contains the areas (1,2,3,4,...,255) where the user has Privilege 1."
      },
      "helpPath": "UserVerify.html"
    },
    "variablequality": {
      "name": "VariableQuality",
      "returnType": "UNKNOWN",
      "params": [
        "Variable"
      ],
      "doc": "Extracts the quality from a given variable.",
      "returns": "The QUALITY of the given variable. If Variable is NULL, it returns quality uncertain (0x40).",
      "paramDocs": {
        "Variable": "The variable from which the quality will be extracted."
      },
      "helpPath": "VariableQuality.html"
    },
    "variabletimestamp": {
      "name": "VariableTimestamp",
      "returnType": "UNKNOWN",
      "params": [
        "Variable",
        "INT Type"
      ],
      "doc": "Extracts the timestamp from a given variable.",
      "returns": "A TIMESTAMP of the given variable depending on the type. If Variable is NULL, returns INVALID_TIMESTAMP.",
      "paramDocs": {
        "Variable": "The variable from which the timestamp will be extracted.",
        "nType": "The type of timestamp:"
      },
      "helpPath": "VariableTimestamp.html"
    },
    "verifyprivilegeform": {
      "name": "VerifyPrivilegeForm",
      "returnType": "UNKNOWN",
      "params": [
        "sOperationDescription",
        "sLogDevice",
        "sAccess",
        "sGlobalPriv",
        "sPriv1",
        "sPriv2",
        "sPriv3",
        "sPriv4",
        "sPriv5",
        "sPriv6",
        "sPriv7",
        "sPriv8"
      ],
      "doc": "Displays a form that allows a single user to enter their credentials.",
      "returns": "The name of the user that met the required privileges, otherwise \"\"",
      "paramDocs": {
        "sOperationDescription,sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8": "VerifyPrivilegeForm(sOperationDescription,sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8)",
        "sOperationDescription": "A description of the operation that requires approval.",
        "sLogDevice": "The name of a log device if logging is required, otherwise pass an empty string.",
        "sAccess": "The required user viewable areas, or pass an empty string for none.",
        "sGlobalPriv": "The required global privilege, otherwise pass an empty string."
      },
      "helpPath": "VerifyPrivilegeForm.html"
    },
    "verifyprivilegetagwrite": {
      "name": "VerifyPrivilegeTagWrite",
      "returnType": "UNKNOWN",
      "params": [
        "sTagName",
        "sValueToWrite",
        "sLogDevice",
        "sAccess",
        "sGlobalPriv",
        "sPriv1",
        "sPriv2",
        "sPriv3",
        "sPriv4",
        "sPriv5",
        "sPriv6",
        "sPriv7",
        "sPriv8"
      ],
      "doc": "Displays a form that allows any single user to enter their credentials in order to approve a write of a specific value to a specific tag.",
      "returns": "Name of user that met the required privileges (and therefore the value was written to the specified tag), otherwise \"\"",
      "paramDocs": {
        "sTagName, sValueToWrite, sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8": "VerifyPrivilegeTagWrite(sTagName, sValueToWrite, sLogDevice, sAccess, sGlobalPriv, sPriv1, sPriv2, sPriv3, sPriv4, sPriv5, sPriv6, sPriv7, sPriv8)",
        "sTagName": "The name of the tag to which a write needs to be approved.",
        "sValuetoWrite": "The value to write to the tag if approval succeeds.",
        "sLogDevice": "The name of a log device if logging is required, otherwise pass an empty string.",
        "sAccess": "The required user viewable areas, or pass an empty string for none.",
        "sGlobalPriv": "The required global privilege, otherwise pass an empty string."
      },
      "helpPath": "VerifyPrivilegeTagWrite.html"
    },
    "version": {
      "name": "Version",
      "returnType": "UNKNOWN",
      "params": [
        "nType"
      ],
      "doc": "Gets the version number of the Plant SCADA software in use.",
      "returns": "The version number as a string.",
      "paramDocs": {
        "0": "Major version number",
        "1": "Minor version number",
        "2": "Revision number",
        "3": "Version text",
        "nType": "Version(nType)"
      },
      "helpPath": "Version.html"
    },
    "whoami": {
      "name": "WhoAmI",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Displays the user name and full name of the user currently logged-in to the system.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "WhoAmI.html"
    },
    "wincopy": {
      "name": "WinCopy",
      "returnType": "UNKNOWN",
      "params": [
        "[xScale] [",
        "yScale] [",
        "bSwapBlackWhite] [",
        "sMap]"
      ],
      "doc": "Copies the graphics image of the active window to the Windows Clipboard.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "[xScale] [, yScale] [, bSwapBlackWhite] [, sMap]": "WinCopy( [xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )",
        "xScale": "The x scaling factor for the item being copied. This argument is optional, as a default setting of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image.",
        "yScale": "The y scaling factor for the item being copied. This argument is optional, as a default setting of 1 is used to maintain the current vertical scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the height of the image.",
        "bSwapBlackWhite": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
        "sMap": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:"
      },
      "helpPath": "WinCopy.html"
    },
    "winfile": {
      "name": "WinFile",
      "returnType": "UNKNOWN",
      "params": [
        "sFile [",
        "xScale] [",
        "yScale] [",
        "bSwapBlackWhite] [",
        "sMap]"
      ],
      "doc": "Writes the graphics image of the active window to a file.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sFile [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap]": "WinFile(sFile [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )",
        "sFile": "The name of the file to be created. If no path information is specified, the function will try to create the file in the bin directory (the current directory of the runtime process). Write permission is required.",
        "xScale": "The x scaling factor for the item being printed. This argument is optional, as a default setting of 1 is used to maintain the horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image .",
        "yScale": "The y scaling factor for the item being printed. This argument is optional, as a default setting of 1 is used to maintain the current vertical scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the height of the image.",
        "bSwapBlackWhite": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
        "sMap": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:"
      },
      "helpPath": "WinFile.html"
    },
    "winfree": {
      "name": "WinFree",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Removes the active display window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {},
      "helpPath": "WinFree.html"
    },
    "winfreeex": {
      "name": "WinFreeEx",
      "returnType": "UNKNOWN",
      "params": [
        "Window"
      ],
      "doc": "Removes the active display window and allows you to pass a Windows handle to the function for closing the window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Window": "WinFreeEx(Window)"
      },
      "helpPath": "WinFreeEx.htm"
    },
    "wingetclicked": {
      "name": "WinGetClicked",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the number of the Plant SCADA window that has most recently been clicked on using the left mouse button.",
      "returns": "The window number of the Plant SCADA window that has most recently been clicked on using the left mouse button. Be aware that this is not the same as the window handle, returned from the WndFind() function.",
      "paramDocs": {},
      "helpPath": "WinGetClicked.html"
    },
    "wingetfirstchild": {
      "name": "WinGetFirstChild",
      "returnType": "UNKNOWN",
      "params": [
        "Window"
      ],
      "doc": "Gets the window number of the first child of a parent window.",
      "returns": "The window number associated with the first child of the specified parent window. If a child window does not exist, 1 is returned.",
      "paramDocs": {
        "Window": "WinGetFirstChild(Window)"
      },
      "helpPath": "WinGetFirstChild.html"
    },
    "wingetfocus": {
      "name": "WinGetFocus",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the number of the Plant SCADA window that has the keyboard focus.",
      "returns": "The window number of the Plant SCADA window that has the keyboard focus. Be aware that this is not the same as the window handle, returned from the WndFind() function.",
      "paramDocs": {},
      "helpPath": "WinGetFocus.html"
    },
    "wingetname": {
      "name": "WinGetName",
      "returnType": "STRING",
      "params": [
        "[iWinNum]"
      ],
      "doc": "Gets the name previously associated with a particular window number using WinSetName.",
      "returns": "String name associated with window number iWinNum, otherwise an empty string is returned.",
      "paramDocs": {
        "[iWinNum]": "WinGetName([iWinNum])"
      },
      "helpPath": "WinGetName.html"
    },
    "wingetnextchild": {
      "name": "WinGetNextChild",
      "returnType": "UNKNOWN",
      "params": [
        "Window"
      ],
      "doc": "Gets the window number of the next child in a child link.",
      "returns": "The window number associated with the next child in the child link. If a window does not exist, 1 is returned.",
      "paramDocs": {
        "Window": "WinGetNextChild(Window)"
      },
      "helpPath": "WinGetNextChild.html"
    },
    "wingetparent": {
      "name": "WinGetParent",
      "returnType": "UNKNOWN",
      "params": [
        "[WinNum]",
        "[GetRoot]"
      ],
      "doc": "Retrieves the Window Number of the specified window's parent or root window.",
      "returns": "The window number of the parent or root window.",
      "paramDocs": {
        "[WinNum], [GetRoot]": "WinGetParent([WinNum], [GetRoot])"
      },
      "helpPath": "WinGetParent.html"
    },
    "wingetwndhnd": {
      "name": "WinGetWndHnd",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Gets the window handle for the current window.",
      "returns": "The window handle if successful, otherwise 0 (zero) is returned. Be aware that this is not the same as a Plant SCADA window number returned from the WinNumber() function.",
      "paramDocs": {},
      "helpPath": "WinGetWndHnd.html"
    },
    "wingoto": {
      "name": "WinGoto",
      "returnType": "UNKNOWN",
      "params": [
        "Window"
      ],
      "doc": "Changes the active window. The specified window is placed in front of all other windows and all keyboard commands will apply to this window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Window": "WinGoto(Window)"
      },
      "helpPath": "WinGoto.html"
    },
    "winmode": {
      "name": "WinMode",
      "returnType": "UNKNOWN",
      "params": [
        "Mode"
      ],
      "doc": "Sets the display mode of the active Plant SCADA window.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Hide the window.",
        "2": "Activate the window in an iconized state.",
        "3": "Activate the window in a maximized state.",
        "4": "Display the window in its previous state without activating it.",
        "5": "Activate the window in its current state.",
        "6": "Iconize the window.",
        "7": "Display the window in an iconized state without activating it.",
        "8": "Display the window in its current state without activating it.",
        "9": "Activate the window in its previous state.",
        "Mode": "WinMode(Mode)"
      },
      "helpPath": "WinMode.html"
    },
    "winmove": {
      "name": "WinMove",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y",
        "Width",
        "Height"
      ],
      "doc": "Moves the active window to a new location and sizes the window in a single operation.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "X, Y, Width, Height": "WinMove(X, Y, Width, Height)",
        "X, Y": "The new x and y pixel coordinates for the top-left corner of the active window.",
        "Width": "The width of the window, in pixels.",
        "Height": "The height of the window, in pixels."
      },
      "helpPath": "WinMove.html"
    },
    "winnew": {
      "name": "WinNew",
      "returnType": "UNKNOWN",
      "params": [
        "Page",
        "ClusterName"
      ],
      "doc": "Opens a new display window, with a specified page displayed.",
      "returns": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
      "paramDocs": {
        "Page,ClusterName": "WinNew(Page,ClusterName)",
        "Page": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
        "sClusterName": "The name of the cluster that will accommodate the page at runtime. This is optional if you have one cluster or are resolving the page via the current cluster context. The argument is enclosed in quotation marks \"\". If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "WinNew.html"
    },
    "winnewat": {
      "name": "WinNewAt",
      "returnType": "UNKNOWN",
      "params": [
        "Page",
        "X",
        "Y",
        "Mode[",
        "sClusterName]"
      ],
      "doc": "Opens a new display window at a specified location, with a selected page displayed.",
      "returns": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
      "paramDocs": {
        "0": "Normal page.",
        "1": "Page child window. The window is closed when a new page is displayed, for example, when the PageDisplay() or PageGoto() function is called. The parent is the current active window.",
        "2": "Window child window. The window is closed automatically when the parent window is freed with the WinFree() function. The parent is the current active window.",
        "4": "No re-size. The window is displayed with thin borders and no maximize/minimize icons. The window cannot be re-sized.",
        "8": "No icons. The window is displayed with thin borders and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "16": "No caption. The window is displayed with thin borders, no caption, and no maximize/minimize or system menu icons. The window cannot be re-sized.",
        "32": "Echo enabled. When enabled, keyboard echo, prompts, and error messages are displayed on the parent window. This mode should only be used with child windows (for example, Mode 1 and 2).",
        "64": "Always on top.",
        "128": "Open a unique window. This mode helps to prevent this window from being opened more than once.",
        "256": "Display the entire window. This mode commands that no parts of the window will appear off the screen",
        "512": "Open a unique Super Genie. This mode helps to prevent a Super Genie from being opened more than once (at the same time). However, the same Super Genie with different associations can be opened.",
        "1024": "Disables dynamic resizing of the new window, overriding the setting of the [Page]DynamicSizing parameter.",
        "4096": "Allows the window to be resized without maintaining the current aspect ratio. The aspect ratio defines the relationship between the width and the height of the window, which means this setting allows you to stretch or compress the window to any proportions. This option overrides the setting of the [Page]MaintainAspectRatio parameter.",
        "8192": "Text on a page will be resized in proportion with the maximum scale change for a resized window. For example, consider a page that is resized to three times the original width, and half the original height. If this mode is set, the font size of the text on the page will be tripled (in proportion with the maximum scale). This option overrides the setting of the [Page] ScaleTextToMax parameter.",
        "16384": "Hide the horizontal scroll bar.",
        "32768": "Hide the vertical scroll bar.",
        "65536": "Disable horizontal scrolling.",
        "131072": "Disable vertical scrolling.",
        "Page, X, Y, Mode[, sClusterName]": "WinNewAt(Page, X, Y, Mode[, sClusterName])",
        "Page": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
        "X": "The x pixel coordinate of the top left corner of the window.",
        "Y": "The y pixel coordinate of the top left corner of the window.",
        "Mode": "The mode of the window:",
        "sClusterName": "The name of the cluster that will accommodate the page at runtime. This is optional if you have one cluster or are resolving the page via the current cluster context. The argument is enclosed in quotation marks \"\". If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "WinNewAt.html"
    },
    "winnewpinat": {
      "name": "WinNewPinAt",
      "returnType": "UNKNOWN",
      "params": [
        "Page",
        "X",
        "Y[",
        "Mode][",
        "Width][",
        "Height][",
        "sClusterName]"
      ],
      "doc": "Opens a new display window at a specified location, relative to the current active window, with a selected page displayed.",
      "returns": "The window number of the window, or -1 if the window cannot be opened. Be aware that this is not the same as the window handle returned from the WndFind() function.",
      "paramDocs": {
        "Page, X, Y[, Mode][, Width][, Height][, sClusterName]": "WinNewPinAt(Page, X, Y[, Mode][, Width][, Height][, sClusterName])",
        "Page": "The name or page number of the page to display (in quotation marks \"\"). Can be prefixed by the name of a host cluster, that is \"ClusterName.Page\". This will take precedence over the use of the ClusterName parameter if the two differ.",
        "X": "The x pixel coordinate of the top left corner of the window.",
        "Y": "The y pixel coordinate of the top left corner of the window.",
        "Mode": "The mode of the window:",
        "Width": "The pixel width of the window, scaled relative to the current active window.",
        "Height": "The pixel height of the window, scaled relative to the current active window.",
        "sClusterName": "The name of the cluster that will accommodate the page at runtime. This is optional if you have one cluster or are resolving the page via the current cluster context. The argument is enclosed in quotation marks \"\". If the Page parameter is prefixed with the name of a cluster, this parameter will not be used."
      },
      "helpPath": "WinNewPinAt.html"
    },
    "winnext": {
      "name": "WinNext",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Makes the next window (in order of creation) active.",
      "returns": "The window number of the window, or -1 if there is no next window. Be aware that this is not the same as the window handle returned from the WndFind() function.",
      "paramDocs": {},
      "helpPath": "WinNext.html"
    },
    "winnumber": {
      "name": "WinNumber",
      "returnType": "UNKNOWN",
      "params": [
        "[sName]"
      ],
      "doc": "Gets the window number of the active Plant SCADA window.",
      "returns": "Window Number associated with the Name provided. If no Name is specified then the active window number is returned. If there isn't a valid window number associated with the name provided then -1 is returned.",
      "paramDocs": {
        "sName": "WinNumber([sName])"
      },
      "helpPath": "WinNumber.html"
    },
    "winpos": {
      "name": "WinPos",
      "returnType": "UNKNOWN",
      "params": [
        "X",
        "Y"
      ],
      "doc": "Moves the active window to a new location.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "X, Y": "WinPos(X, Y)"
      },
      "helpPath": "WinPos.html"
    },
    "winprev": {
      "name": "WinPrev",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Makes the previous window (in order of creation) active.",
      "returns": "The window number of the window, or -1 if there is no next window. Be aware that this is not the same as the window handle returned from the WndFind() function.",
      "paramDocs": {},
      "helpPath": "WinPrev.html"
    },
    "winprint": {
      "name": "WinPrint",
      "returnType": "UNKNOWN",
      "params": [
        "sPort [",
        "xScale] [",
        "yScale] [",
        "bSwapBlackWhite] [",
        "sMap]"
      ],
      "doc": "Sends the graphics image of the active window to a printer.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap]": "WinPrint(sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, sMap] )",
        "sPort": "The name of the printer port to which the window will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1:\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer. sPort may not contain spaces.",
        "xScale": "The x scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
        "yScale": "The y scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
        "bSwapBlackWhite": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
        "sMap": "The file name or path of a text based map file used to specify colors to swap when printing. By default Plant SCADAwill look in the bin directory for the map file. The format for the map file is:"
      },
      "helpPath": "WinPrint.html"
    },
    "winprintfile": {
      "name": "WinPrintFile",
      "returnType": "UNKNOWN",
      "params": [
        "sFile",
        "sPort [",
        "xScale] [",
        "yScale] [",
        "bSwapBlackWhite] [",
        "fromColor] [",
        "toColor]"
      ],
      "doc": "Prints a file to the system printer.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sFile, sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, fromColor] [, toColor]": "WinPrintFile(sFile, sPort [, xScale] [, yScale] [, bSwapBlackWhite] [, fromColor] [, toColor] )",
        "sFile": "The file name.",
        "sPort": "The name of the printer port to which the window will be printed. This name needs to be enclosed within quotation marks \"\". For example \"LPT1:\", to print to the local printer, or \"\\\\Pserver\\canon1\" using UNC to print to a network printer. sPort may not contain spaces",
        "xScale": "The x scaling factor for the print. The default value of 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
        "yScale": "The y scaling factor for the print. The default value 0 (zero) automatically scales the print to fit the page. A value of 1 is used to maintain the current horizontal scaling of the image. The outcome is proportional to 1; for example, 0.5 halves the width of the image (optional).",
        "bSwapBlackWhite": "Swaps the colors black and white for the purpose of printing pages with a lot of black content. Use the default value of 1 to swap black and white (optional).",
        "fromColor": "fromColor",
        "toColor": "toColor"
      },
      "helpPath": "WinPrintFile.html"
    },
    "winselect": {
      "name": "WinSelect",
      "returnType": "UNKNOWN",
      "params": [
        "Window"
      ],
      "doc": "Selects a window to make active. This function only affects the output of Cicode functions.",
      "returns": "The old window number.",
      "paramDocs": {
        "Window": "WinSelect(Window)"
      },
      "helpPath": "WinSelect.html"
    },
    "winsetname": {
      "name": "WinSetName",
      "returnType": "UNKNOWN",
      "params": [
        "sName [",
        "iWinNum]"
      ],
      "doc": "Associates a name with a particular window by its window number.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sName": "WinSetName(sName [, iWinNum] )",
        "iWinNum": "An optional parameter which specifies the window number with which to associate Name. If no number is specified the name is associated with the currently selected window number.."
      },
      "helpPath": "WinSetName.html"
    },
    "winsize": {
      "name": "WinSize",
      "returnType": "UNKNOWN",
      "params": [
        "Width",
        "Height",
        "Mode"
      ],
      "doc": "Sizes the active window. The origin of the window does not move.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "Width, Height": "WinSize(Width, Height, Mode)"
      },
      "helpPath": "WinSize.html"
    },
    "winstyle": {
      "name": "WinStyle",
      "returnType": "UNKNOWN",
      "params": [
        "Style",
        "Mode"
      ],
      "doc": "Switches on and off scrolling and scrollbar features for existing windows.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Turn option off.",
        "1": "Hide horizontal scroll bars.",
        "2": "Hide vertical scroll bars.",
        "3": "Disable horizontal scrolling.",
        "4": "Disable vertical scrolling.",
        "Style, Mode": "WinStyle(Style, Mode)",
        "Style": "One of the following:",
        "Mode": "The mode of the option:"
      },
      "helpPath": "WinStyle.html"
    },
    "wintitle": {
      "name": "WinTitle",
      "returnType": "UNKNOWN",
      "params": [
        "sTitle"
      ],
      "doc": "If a window title has been set with the [Page]WinTitle parameter, Plant SCADA uses this title when it refreshes the page (overriding the window title set with the WinTitle() function).",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sTitle": "WinTitle(sTitle)"
      },
      "helpPath": "WinTitle.html"
    },
    "wndfind": {
      "name": "WndFind",
      "returnType": "UNKNOWN",
      "params": [
        "sTitle"
      ],
      "doc": "Gets the Windows handle of any window of any application, so that the window can be manipulated.",
      "returns": "The window handle. Be aware that this is not the same as a Plant SCADA window number returned from the WinNumber() function.",
      "paramDocs": {
        "Win...": "Gets the Windows handle of any window of any application, so that the window can be manipulated. The window handle is not the same as the Plant SCADA window number and cannot be used with functions that expect the Plant SCADA window number (the Win... functions).",
        "sTitle": "WndFind(sTitle)"
      },
      "helpPath": "WndFind.html"
    },
    "wndgetfileprofile": {
      "name": "WndGetFileProfile",
      "returnType": "UNKNOWN",
      "params": [
        "sGroup",
        "sName",
        "sDefault",
        "sFile"
      ],
      "doc": "Gets a profile string from any .ini file.",
      "returns": "The profile string from sFile.",
      "paramDocs": {
        "sGroup, sName, sDefault, sFile": "WndGetFileProfile(sGroup, sName, sDefault, sFile)",
        "sGroup": "The name of the [group].",
        "sName": "The name of the variable.",
        "sDefault": "The default value.",
        "sFile": "The .ini file name.",
        "sFile.": "The profile string from sFile."
      },
      "helpPath": "WndGetFileProfile.html"
    },
    "wndhelp": {
      "name": "WndHelp",
      "returnType": "UNKNOWN",
      "params": [
        "sHelpFile",
        "Command",
        "Data"
      ],
      "doc": "Invokes the Windows Help application (WinHlp32.EXE) to display a specific topic from a specific help file.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "Displays the help topic identified by the context string/number in the Data field. The context string/number needs to be defined in the [MAP] section of the help's .HPJ file.",
        "2": "Closes the Help application. Enter an empty string for the Data argument.",
        "3": "Displays the help contents topic defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file.",
        "4": "Displays the contents topic of the designated How to Use Help file. The context string/number (specified in the Data field) needs to be defined in the [MAP] section of the .HPJ file.",
        "5": "Changes the current help contents topic to match the context string/number specified in the Data field. This topic is used instead of the one defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file. This will affect Command 3 (see above). The context string/number needs to be defined in the [MAP] section of the help's .HPJ file, and the help file needs to already be open. The change will last only until the help file is closed.",
        "8": "Displays, in a pop-up window, the help topic identified by the context string/number in the Data field. The context string/number needs to be defined in the [MAP] section of the .HPJ file.",
        "9": "Tests that the correct help file is displayed. If the correct help file is currently displayed, this command merely makes the help the active window. If the incorrect help file is displayed, WinHelp opens the correct file, and displays the help contents topic defined by the CONTENTS option in the [OPTIONS] section of the .HPJ file.",
        "11": "Displays the Plant SCADA Help Topics with either the Contents, the Index, or the Find tab selected, depending on which one was last used. Enter an empty string for the Data argument.",
        "257": "Searches the help index for your keyword (as specified in the Data field) and displays the first topic in the index with an identical match. If there is no match, displays the index with your keyword already entered. To display the index without passing a keyword, enter an empty string for the Data argument.",
        "258": "Executes the Help macro string specified in the Data field. Help needs to be running and the help file needs to be open, or the message is ignored.",
        "260": "Displays, in a pop-up window, the help topic identified by the context string/number in the Data field.",
        "261": "Searches the help index for your keyword (as specified in the Data field) and displays the first topic in the index with an identical match. If there is no match, displays the index with your keyword already entered. To display the index without passing a keyword, enter an empty string for the Data argument.",
        "sHelpFile, Command, Data": "WndHelp(sHelpFile, Command, Data)",
        "sHelpFile": "The help file to display.",
        "Command": "The type of help:",
        "Data": "The context string/number or keyword of the help topic that is requested."
      },
      "helpPath": "WndHelp.html"
    },
    "wndinfo": {
      "name": "WndInfo",
      "returnType": "UNKNOWN",
      "params": [
        "iType"
      ],
      "doc": "Gets information on the window system (such as the width and height of the various elements displayed by Windows).",
      "returns": "The system metric information.",
      "paramDocs": {
        "0": "Width of the screen.",
        "1": "Height of the screen.",
        "2": "Width of the arrow bitmap on a vertical scroll bar.",
        "3": "Height of the arrow bitmap on a horizontal scroll bar.",
        "4": "Height of the window title. This is the title height plus the height of the window frame that cannot be sized (SM_CYBORDER).",
        "5": "Width of the window frame that cannot be sized.",
        "6": "Height of the window frame that cannot be sized.",
        "7": "Width of the frame when the window has the WS_DLGFRAME style.",
        "8": "Height of the frame when the window has the WS_DLGFRAME style.",
        "9": "Height of the scroll box on vertical scroll bar.",
        "10": "Width of the scroll box (thumb) on horizontal scroll bar.",
        "12": "Height of the icon.",
        "13": "Width of the cursor.",
        "14": "Height of the cursor.",
        "15": "Height of a single-line menu bar. This is the menu height minus the height of the window frame that cannot be sized (SM_CYBORDER).",
        "16": "Width of the window client area for a fullscreen window.",
        "17": "Height of the window client area for a fullscreen window (equivalent to the height of the screen minus the height of the window title).",
        "18": "Height of a Kanji window.",
        "19": "Non-zero if the mouse hardware is installed.",
        "20": "Height of arrow bitmap on a vertical scroll bar.",
        "21": "Width of arrow bitmap on a horizontal scroll bar.",
        "22": "Non-zero if the Windows version is a debugging version.",
        "23": "Non-zero if the left and right mouse buttons are swapped.",
        "28": "Minimum width of the window.",
        "29": "Minimum height of the window.",
        "30": "Width of bitmaps contained in the title bar.",
        "31": "Height of bitmaps contained in the title bar.",
        "32": "Width of the window frame that can be sized.",
        "33": "Height of the window frame that can be sized.",
        "34": "Minimum tracking width of the window.",
        "35": "Minimum tracking height of the window.",
        "76": "x co-ordinate of upper left corner of virtual screen",
        "77": "y co-ordinate of upper left corner of virtual screen",
        "78": "width of virtual screen",
        "79": "height of virtual screen",
        "80": "number of monitors available",
        "iType": "WndInfo(iType)",
        "24-27": "Not Used"
      },
      "helpPath": "WndInfo.html"
    },
    "wndmonitorinfo": {
      "name": "WndMonitorInfo",
      "returnType": "UNKNOWN",
      "params": [
        "iMonitor",
        "iType"
      ],
      "doc": "Returns information about a particular monitor.",
      "returns": "Requested information about the selected monitor.",
      "paramDocs": {
        "0": "x co-ordinate of upper left corner of monitor.",
        "1": "y co-ordinate of upper left corner of monitor.",
        "2": "width of monitor.",
        "3": "height of monitor.",
        "4": "x co-ordinate of upper left corner of monitor working area.",
        "5": "y co-ordinate of upper left corner of monitor working area.",
        "6": "width of monitor working area.",
        "7": "height of monitor working area.",
        "iMonitor, iType": "WndMonitorInfo(iMonitor, iType)",
        "iMonitor": "Monitor Number 1 to n, where n is the number of monitors returned from WndInfo(80). Using 0 will return the value for the virtual screen. Using an unsupported monitor number (0 or n) will return -1 for all values.",
        "iType": "Type The monitor measurement to be retrieved:"
      },
      "helpPath": "WndMonitorInfo.html"
    },
    "wndmonitorinfoex": {
      "name": "WndMonitorInfoEx",
      "returnType": "UNKNOWN",
      "params": [
        "sMonitor",
        "iType"
      ],
      "doc": "Returns information about a particular monitor.",
      "returns": "Requested information about the selected monitor.",
      "paramDocs": {
        "0": "x co-ordinate of upper left corner of monitor.",
        "1": "y co-ordinate of upper left corner of monitor.",
        "2": "width of monitor.",
        "3": "height of monitor.",
        "4": "x co-ordinate of upper left corner of monitor working area.",
        "5": "y co-ordinate of upper left corner of monitor working area.",
        "6": "width of monitor working area.",
        "7": "height of monitor working area.",
        "sMonitor, iType": "WndMonitorInfoEx(sMonitor, iType)",
        "sMonitor": "Screen profile's screen name.",
        "iType": "Type The monitor measurement to be retrieved:"
      },
      "helpPath": "WndMonitorInfoEx.html"
    },
    "wndputfileprofile": {
      "name": "WndPutFileProfile",
      "returnType": "UNKNOWN",
      "params": [
        "sGroup",
        "sName",
        "sData",
        "sFile"
      ],
      "doc": "Puts a profile string into any .INI file.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "sGroup, sName, sData, sFile": "WndPutFileProfile(sGroup, sName, sData, sFile)",
        "sGroup": "The name of the [group].",
        "sName": "The name of the variable.",
        "sData": "The variable data.",
        "sFile": "The .INI file name."
      },
      "helpPath": "WndPutFileProfile.html"
    },
    "wndshow": {
      "name": "WndShow",
      "returnType": "UNKNOWN",
      "params": [
        "hWnd",
        "nMode"
      ],
      "doc": "Sets the display mode of any window of any application.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "0": "Hide the window.",
        "1": "Activate the window in normal mode.",
        "2": "Activate the window in an iconized state.",
        "3": "Activate the window in a maximized state.",
        "4": "Display the window in its previous state without activating it.",
        "5": "Activate the window in its current state.",
        "6": "Iconize the window.",
        "7": "Display the window in an iconized state without activating it.",
        "8": "Display the window in its current state without activating it.",
        "9": "Activate the window in its previous state.",
        "hWnd": "WndShow(hWnd, nMode)",
        "nMode": "The window mode:"
      },
      "helpPath": "WndShow.html"
    },
    "wndviewer": {
      "name": "WndViewer",
      "returnType": "UNKNOWN",
      "params": [
        "sViewerFile",
        "Command",
        "Data"
      ],
      "doc": "Invokes the Microsoft Multimedia application.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "1": "Displays a Viewer topic (specified in the Data field) in the main Viewer window.",
        "2": "Displays a Viewer topic (specified in the Data field) in a pop-up window.",
        "sViewerFile, Command, Data": "WndViewer(sViewerFile, Command, Data)",
        "sViewerFile": "The Multimedia Viewer file to display.",
        "Command": "The type of help:",
        "Data": "The context string of the Multimedia Viewer topic."
      },
      "helpPath": "WndViewer.html"
    },
    "xmlclose": {
      "name": "XMLClose",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc"
      ],
      "doc": "Use this function to delete an XML document in memory.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT hDoc": "INT XMLClose(INT hDoc)",
        "hDoc": "hDoc"
      },
      "helpPath": "XMLClose.html"
    },
    "xmlcreate": {
      "name": "XMLCreate",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sRootElement",
        "STRING sNamespace = \"\""
      ],
      "doc": "Use this function to create a new XML document in memory.",
      "returns": "Handle of XML document, or returns -1 on error",
      "paramDocs": {
        "STRING sRootElement, STRING sNamespace = \"\"": "INT XMLCreate(STRING sRootElement, STRING sNamespace = \"\")",
        "sRootElement": "Root element of the XML document.",
        "sNamespace": "Optional. Namespace URI of root element."
      },
      "helpPath": "XMLCreate.html"
    },
    "xmlgetattribute": {
      "name": "XMLGetAttribute",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "STRING sAttributeName"
      ],
      "doc": "Retrieves the attribute value of the node from an XML document in memory.",
      "returns": "Value of specified node's attribute",
      "paramDocs": {
        "INT hDoc, INT hNode, STRING sAttributeName": "INT XMLGetAttribute(INT hDoc, INT hNode, STRING sAttributeName)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "sAttributeName": "sAttributeName"
      },
      "helpPath": "XMLGetAttribute.html"
    },
    "xmlgetattributecount": {
      "name": "XMLGetAttributeCount",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Gets number of attribute of specified XML node.",
      "returns": "Number of attribute of specified node.",
      "paramDocs": {
        "INT hDoc, INT hNode": "INT XMLGetAttributeCount(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLGetAttributeCount.html"
    },
    "xmlgetattributename": {
      "name": "XMLGetAttributeName",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "INT iAttribute"
      ],
      "doc": "Gets name of specified XML Nodes attribute by using attribute index.",
      "returns": "Name of specified node's attribute",
      "paramDocs": {
        "INT hDoc, INT hNode, INT iAttribute": "STRING XMLGetAttributeName(INT hDoc, INT hNode, INT iAttribute)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "iAttribute": "iAttribute"
      },
      "helpPath": "XMLGetAttributeName.html"
    },
    "xmlgetattributevalue": {
      "name": "XMLGetAttributeValue",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "INT iAttribute"
      ],
      "doc": "Gets the value of the specified XML node's attribute by using attribute index.",
      "returns": "Value of specified nodes attribute.",
      "paramDocs": {
        "INT hDoc, INT hNode, INT iAttribute": "STRING XMLGetAttributeValue(INT hDoc, INT hNode, INT iAttribute)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "iAttribute": "iAttribute"
      },
      "helpPath": "XMLGetAttributeValue.html"
    },
    "xmlgetchild": {
      "name": "XMLGetChild",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "INT iChild"
      ],
      "doc": "Retrieves the child node for the specified parent node in XML document in memory.",
      "returns": "Handle of child node, or -1 on error",
      "paramDocs": {
        "INT hDoc, INT hNode, INT iChild": "INT XMLGetChild(INT hDoc, INT hNode, INT iChild)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "iChild": "iChild"
      },
      "helpPath": "XMLGetChild.html"
    },
    "xmlgetchildcount": {
      "name": "XMLGetChildCount",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Retrieves the total number of child nodes for the specified parent node in an XML document in memory.",
      "returns": "Number of child nodes, or -1 on error",
      "paramDocs": {
        "INT hDoc, INT hNode": "INT XMLGetChildCount(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLGetChildCount.html"
    },
    "xmlgetparent": {
      "name": "XMLGetParent",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Gets the parent of specified node.",
      "returns": "Handle of parent node, or error will be returned",
      "paramDocs": {
        "INT hDoc, INT hNode": "INT XMLGetParent(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLGetParent.html"
    },
    "xmlgetroot": {
      "name": "XMLGetRoot",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc"
      ],
      "doc": "Gets the root element of the specified XML document.",
      "returns": "Handle of root element, or-1 on error.",
      "paramDocs": {
        "INT hDoc": "INT XMLGetRoot(INT hDoc)",
        "hDoc": "hDoc"
      },
      "helpPath": "XMLGetRoot.html"
    },
    "xmlnodeaddchild": {
      "name": "XMLNodeAddChild",
      "returnType": "UNKNOWN",
      "params": [],
      "doc": "Creates an element node with the specified Name and Namespace and appends the node to the end of the list of child nodes of specified parent node in the XML document.",
      "returns": "Handle of the newly created node, or -1 on error.",
      "paramDocs": {
        "INT hDoc, INT hNode, STRING sName[, STRING sNamespace = \"\"": "INT XMLNodeAddChild(INT hDoc, INT hNode, STRING sName[, STRING sNamespace = \"\" ])",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "sName": "sName",
        "sNamespace": "sNamespace"
      },
      "helpPath": "XMLNodeAddChild.html"
    },
    "xmlnodefind": {
      "name": "XMLNodeFind",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "STRING sQuery"
      ],
      "doc": "Use this function to select the first XML node that matches the XPath expression.",
      "returns": "Handle of the first XML node that matches the XPath expression, or BAD HANDLE on error.",
      "paramDocs": {
        "INT hDoc, STRING sQuery": "INT XMLNodeFind(INT hDoc, STRING sQuery)",
        "hDoc": "hDoc",
        "sQuery": "sQuery"
      },
      "helpPath": "XMLNodeFind.html"
    },
    "xmlnodegetname": {
      "name": "XMLNodeGetName",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Gets the name of the specified node.",
      "returns": "Name of specified node.",
      "paramDocs": {
        "INT hDoc, INT hNode": "STRING XMLNodeGetName(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLNodeGetName.html"
    },
    "xmlnodegetvalue": {
      "name": "XMLNodeGetValue",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Gets the value of the specified node.",
      "returns": "Value of specified node",
      "paramDocs": {
        "INT hDoc, INT hNode": "STRING XMLNodeGetValue(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLNodeGetValue.html"
    },
    "xmlnoderemove": {
      "name": "XMLNodeRemove",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode"
      ],
      "doc": "Removes the specified XML node from its parent and XML document.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT hDoc, INT hNode": "INT XMLNodeRemove(INT hDoc, INT hNode)",
        "hDoc": "hDoc",
        "hNode": "hNode"
      },
      "helpPath": "XMLNodeRemove.html"
    },
    "xmlnodesetvalue": {
      "name": "XMLNodeSetValue",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "STRING sValue"
      ],
      "doc": "Sets the value of the specified node.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT hDoc, INT hNode, STRING sValue": "INT XMLNodeSetValue(INT hDoc, INT hNode, STRING sValue)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "sValue": "sValue"
      },
      "helpPath": "XMLNodeSetValue.html"
    },
    "xmlopen": {
      "name": "XMLOpen",
      "returnType": "UNKNOWN",
      "params": [
        "STRING sFilePath"
      ],
      "doc": "Reads an XML file from disk to create XML document.",
      "returns": "Handle of the XML document, or -1 on error.",
      "paramDocs": {
        "STRING sFilePath": "INT XMLOpen(STRING sFilePath)",
        "sFilePath": "sFilePath"
      },
      "helpPath": "XMLOpen.html"
    },
    "xmlsave": {
      "name": "XMLSave",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "STRING sFilePath"
      ],
      "doc": "Use this function to save XML document on disk.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT hDoc, STRING sFilePath": "INT XMLSave(INT hDoc, STRING sFilePath)",
        "hDoc": "hDoc",
        "sQuery": "sQuery"
      },
      "helpPath": "XMLSave.html"
    },
    "xmlsetattribute": {
      "name": "XMLSetAttribute",
      "returnType": "UNKNOWN",
      "params": [
        "INT hDoc",
        "INT hNode",
        "STRING sName",
        "STRING sValue"
      ],
      "doc": "Use this function to set the value of specified attribute of the node in the XML document. If the attribute does not exist, it will be created.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "INT hDoc, INT hNode, STRING sName, STRING sValue": "INT XMLSetAttribute(INT hDoc, INT hNode, STRING sName, STRING sValue)",
        "hDoc": "hDoc",
        "hNode": "hNode",
        "sName": "sName",
        "sValue": "sValue"
      },
      "helpPath": "XMLSetAttribute.html"
    },
    "_objectcallmethod": {
      "name": "_ObjectCallMethod",
      "returnType": "UNKNOWN",
      "params": [
        "hObject",
        "sMethod",
        "vParameters"
      ],
      "doc": "Calls a specific method for an ActiveX object.",
      "returns": "The return value from the method - if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hObject": "_ObjectCallMethod(hObject, sMethod, vParameters)",
        "sMethod": "The name of the method.",
        "vParameters": "A variable length parameter list of method arguments. The variables will be passed however you enter them, and will then be coerced into appropriate automation types. Likewise, any values modified by the automation call will be written back - with appropriate coercion - into the passed Cicode variable."
      },
      "helpPath": "_ObjectCallMethod.html"
    },
    "_objectgetproperty": {
      "name": "_ObjectGetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "hObject",
        "sProperty"
      ],
      "doc": "Gets a specific property of an ActiveX object.",
      "returns": "The value of the property - if successful, otherwise error code is returned.",
      "paramDocs": {
        "hObject": "_ObjectGetProperty(hObject, sProperty)",
        "sProperty": "The name of the property you want to get."
      },
      "helpPath": "_ObjectGetProperty.html"
    },
    "_objectsetproperty": {
      "name": "_ObjectSetProperty",
      "returnType": "UNKNOWN",
      "params": [
        "hObject",
        "sProperty",
        "vValue"
      ],
      "doc": "Sets a specific property of an ActiveX object.",
      "returns": "0 (zero) if successful, otherwise an error code is returned.",
      "paramDocs": {
        "hObject": "_ObjectSetProperty(hObject, sProperty, vValue)",
        "sProperty": "The name of the property you want to set.",
        "vValue": "The value to which the property will be set. This value can be of any data type. Appropriate coercion will take place when creating the equivalent automation parameter."
      },
      "helpPath": "_ObjectSetProperty.html"
    }
  }
}